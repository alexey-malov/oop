- [Основы синтаксиса языка C++](#основы-синтаксиса-языка-c)
  - [Целочисленные типы данных](#целочисленные-типы-данных)
  - [Типы данных вещественных чисел](#типы-данных-вещественных-чисел)
  - [Логический тип данных](#логический-тип-данных)
  - [Символьные литералы](#символьные-литералы)
  - [Строковые литералы](#строковые-литералы)
  - [Операторы](#операторы)
  - [Переменные](#переменные)
  - [Синонимы типов](#синонимы-типов)
  - [Перечислимый тип данных](#перечислимый-тип-данных)
  - [Приведение типа](#приведение-типа)
  - [Управление ходом выполнения программы](#управление-ходом-выполнения-программы)
  - [Функции](#функции)
  - [Структуры](#структуры)
  - [Массивы](#массивы)
  - [Ссылки](#ссылки)
  - [Пространства имён](#пространства-имён)
  - [Модель памяти C++](#модель-памяти-c)
  - [Указатели](#указатели)
  - [Статическое, автоматическое и динамическое размещение объектов в памяти](#статическое-автоматическое-и-динамическое-размещение-объектов-в-памяти)
- [Стандартная библиотека языка C++](#стандартная-библиотека-языка-c)
  - [std::string и std::string\_view](#stdstring-и-stdstring_view)
  - [std::vector и std::array](#stdvector-и-stdarray)
  - [std::deque](#stddeque)
  - [std::list и std::forward\_list](#stdlist-и-stdforward_list)
  - [Контейнеры map и multimap](#контейнеры-map-и-multimap)
  - [Контейнеры unordered\_map и unordered\_multimap](#контейнеры-unordered_map-и-unordered_multimap)
  - [Контейнеры set и multiset](#контейнеры-set-и-multiset)
  - [Контейнеры unordered\_set и unordered\_multiset](#контейнеры-unordered_set-и-unordered_multiset)
  - [Стандартные алгоритмы](#стандартные-алгоритмы)
  - [std::optional](#stdoptional)
  - [std::variant](#stdvariant)
  - [Стандартные умные указатели](#стандартные-умные-указатели)
- [Объектно-ориентированное программирование](#объектно-ориентированное-программирование)
  - [Понятие класса](#понятие-класса)
  - [Жизненный цикл объекта](#жизненный-цикл-объекта)
  - [Семантика перемещения](#семантика-перемещения)
  - [Отношения между классами](#отношения-между-классами)
  - [Наследование](#наследование)
  - [Полиморфизм](#полиморфизм)
  - [Множественное наследование](#множественное-наследование)
  - [Перегрузка арифметических операций и операций сравнения](#перегрузка-арифметических-операций-и-операций-сравнения)
  - [Перегрузка прочих операций](#перегрузка-прочих-операций)
  - [Обработка исключений](#обработка-исключений)
  - [Разработка кода, устойчивого к возникновению исключений](#разработка-кода-устойчивого-к-возникновению-исключений)
  - [Шаблоны функций](#шаблоны-функций)
  - [Шаблоны классов](#шаблоны-классов)
  - [Шаблоны с переменным числом аргументов](#шаблоны-с-переменным-числом-аргументов)

# Основы синтаксиса языка C++

## Целочисленные типы данных

1. Каковы основные типы целых чисел в C++?
2. Как объявить переменную целого типа в C++?
3. Каковы диапазоны значений для различных типов целых чисел в C++?
4. Каковы основные операции, которые можно выполнять с целыми числами в C++?
5. Чем отличаются `signed` и `unsigned` типы?
6. Каковы правила преобразования типов при выполнении операций с целыми числами в C++?
7. Какие битовые операции можно использовать для работы с целыми числами в C++? Привести примеры
8. Как проверить, является ли целое число четным или нечетным в C++?
9. Как вычислить остаток от деления двух целых чисел в C++?
10. Чему равно частное и остаток при делении, когда один или оба аргумента — отрицательные?
11. Как проверить, является ли целое число положительным или отрицательным в C++?
12. Как использовать условные операторы и циклы для работы с целыми числами в C++?
13. Как проверить, что при умножении двух целых чисел не будет переполнения?
14. Что означает литерал `12345UL`?
15. Запишите число 123 в двоичной форме в виде C++ литерала.
16. Для чего используется символ `'` внутри числового литерала?
17. Как записываются шестнадцатеричные литералы в C++?
18. Переведите 0321 в десятичную систему.
19. Переведите 0b11101 в десятичную систему.

## Типы данных вещественных чисел

1. Какие типы вещественных чисел существуют в C++?
2. Как объявить переменную вещественного типа в C++?
3. Каковы диапазоны значений для различных типов вещественных чисел в C++?
4. Какие операции можно выполнять с вещественными числами в C++?
5. Как происходит преобразование типов при выполнении операций с вещественными числами в C++?
6. Какие математические функции доступны в C++ для работы с вещественными числами?
7. Как проверить, является ли вещественное число положительным или отрицательным в C++?
8. Как проверить, является ли вещественное число целым в C++?
9. Как округлить вещественное число до целого в C++?
10. Как сравнить два вещественных числа на равенство в C++?
11. Какой тип будет у литерала `2e+10`?
     В чем разница между `1.5`, `1.5f` и `1.5L`?

## Логический тип данных

1. Какой тип данных используется для хранения логических значений в C++?
2. Какие значения считаются `true`, а какие `false` при неявном преобразовании?
3. Какие значения может принимать логический тип в C++?
4. Как объявить переменную логического типа в C++?
5. Какие операторы сравнения могут использоваться с логическим типом в C++?
6. Какие логические операторы доступны в C++?
7. Какой результат выражения true && false в C++?
8. Какой результат выражения true || false в C++?
9. Какой результат выражения !true в C++?
10. Какой результат выражения (5 > 3) && (7 < 10) в C++?
11. Какой результат выражения (4 == 4) || (6 != 6) в C++?

## Символьные литералы

1. Какие символьные литералы поддерживаются в языке С++?
2. Что такое символьный литерал, и как он объявляется в С++?
3. Какие символьные значения можно задать с помощью символьных литералов в С++?
4. Какой символьный литерал используется для обозначения перевода строки в С++?
5. Может ли символьный литерал содержать несколько символов? Если да, то как это делается?
6. Что такое управляющие последовательности символов, и какие из них поддерживаются в С++?
7. Приведите не менее 3 примеров символьных литералов в С++?
8. Какие символьные литералы используются для обозначения специальных символов, таких как пробел или знак табуляции?
9. Как внутри символьного литерала задать символ с заданным кодом?
10. Для чего используют `'\n'` в строках?
11. Как записать символ с шестнадцатеричным кодом 255?
12. Зачем использовать `'\0'` вместо `0`?

## Строковые литералы

1. Как объявляется строковый литерал в языке C++?
2. Что такое управляющие последовательности символов и как они используются в строковых литералах в языке C++?
3. Каким образом можно задать пустую строку в языке C++?
4. Каким образом можно скомбинировать два строковых литерала в одну строку в языке C++?
5. Как строковые литералы представляются в памяти?
6. Строковые литералы и для чего они нужны. Как использовать сырые строковые литералы?
7. Чем отличаются эти строковые литералы: `L"Hello"` от `"Hello"`?
8. Что произойдет, если записать `"abcd" "ef"`?
9. Приведите пример строки с escape-последовательностью.
10. Приведите пример сырого строкового литерала, содержащего обратный слеш.

## Операторы

1. Что произойдёт при выполнении выражения `17 / 5`, если оба операнда имеют тип `int`?
2. Чем отличается поведение оператора `%` при работе с `int` и `float`?
3. Напишите выражение, проверяющее, находится ли переменная `x` в диапазоне от 100 до 200 включительно.
4. Чем логические операторы отличаются от побитовых?
5. Как работают логические операторы `&&` и `||` при коротком замыкании?
6. Какое значение будет у переменной `j` после выполнения `int i = 42; int j = ++i;`?
7. Напишите фрагмент кода, устанавливающий 4 и 7 биты в целочисленной переменной.
8. Напишите фрагмент кода, сбрасывающий все биты кроме 3-го в целочисленной переменной.
9. Напишите код, обменивающий местами 4 и 6 биты в целочисленной переменной.

## Переменные

1. Объявление переменных
2. Автоматическое определение типа переменной
3. Объявление константной переменной.
4. Области видимости переменных.
5. Доступ к переменной, объявленной в другое единице трансляции.

## Синонимы типов

1. Что такое синоним типа в языке C++ и для чего он используется?
2. Каким образом объявляются синонимы типов в языке C++?
3. Объявите синоним типов с помощью `using`.
4. Как объявить синоним типа для стандартных типов данных, таких как int или double, в языке C++?
5. Как объявить синоним типа для пользовательского типа данных в языке C++?
6. Какие преимущества имеет использование синонимов типов в языке C++?
7. Каким образом можно определить новый тип данных с использованием `typedef` в языке C++?=

## Перечислимый тип данных

1. Что такое перечислимый тип данных в языке C++ и для чего он используется?
2. Как объявляется перечислимый тип данных в языке C++?
3. Чем отличается перечислимый тип данных от обычных целочисленных типов данных в языке C++?
4. Какие значения могут принимать элементы перечислимого типа данных в языке C++?
5. Каким образом можно указать базовый тип данных для перечисляющего типа данных в языке C++?
6. Что такое scoped enum в языке C++ и как он отличается от обычного перечислимого типа данных?
7. Как объявляется scoped enum в языке C++?
8. Как можно обратиться к элементу scoped enum в языке C++?
9. Что такое underlying type у scoped enum в языке C++ и как он используется?
10. Какие преимущества имеет использование scoped enum в языке C++ перед обычным перечислимым типом данных?

## Приведение типа

1. Что такое приведение типа (typecasting) в языке C++ и для чего оно нужно?
2. Что такое явное приведение типа (explicit typecasting) и каким оператором оно осуществляется в языке C++?
3. Что такое неявное приведение типа (implicit typecasting) и как оно происходит в языке C++?
4. Приведите пример неявного приведение типа в языке C++?
5. Приведение типа в стиле языка C.
6. Какие операторы приведения типов есть в языке C++ и для чего они нужны?

## Управление ходом выполнения программы

1. Выражения, инструкции, блоки
2. Оператор if. Конструкция else if.
3. `if constexpr`. Для чего используется? Какие ограничения?
4. Оператор цикла `for`. Цикл `for` со счётчиком. Синтаксис.
5. Range-based `for`. Что нужно сделать, чтобы элементы контейнера можно было перебирать, используя range-based `for`?
6. Оператор цикла `while`.
7. Оператор цикла `do-while`.
8. Досрочный выход из цикла и пропуск итерации цикла.
9. Как, находясь во внутреннем цикле, выйти из внешнего?
10. Оператор множественного выбора `switch`.
11. Для чего применяется атрибут `[[fallthrough]]`?

## Функции

1. Объявление функции.
2. Определение функции.
3. Аргументы по умолчанию.
4. Как выйти из функции?
5. Лямбда функции.
6. Захват параметров лямбда функции по значению и по ссылке. Чем отличаются?
7. Можно ли изменить значение переменной, захваченной в лямбде по значению?
8. Какой код компилятор сгенерирует на основе лямбда-функции с пустым списком захвата? А если список параметров будет непустым?

## Структуры

1. Для чего нужны структуры?
2. Как объявить структуру?
3. Что такое член структуры и как им можно управлять?
4. Способы инициализации структур?
5. Как обратиться к полю структуры?
6. Как передать структуру в функцию в C++, и какие способы можно использовать для передачи структуры?
7. Указатель на структуру, как обратиться к полю структуры по указателю?
8. Массивы структур.
9. Размещение полей структур в памяти.

## Массивы

1. Как объявить массив в C++?
2. Что такое индекс массива?
3. Как получить доступ к элементу массива по индексу?
4. Как узнать размер массива?
5. Можно ли изменить размер массива после его создания?
6. Как заполнить массив значениями по умолчанию?
7. Как отсортировать элементы массива в порядке убывания?
8. Как связаны строковые литералы и массивы символов?
9. Что такое `std::array` и как он отличается от обычного массива?
10. Объявление многомерных массивов. Объявление многомерного массива с помощью `std::array`.

## Ссылки

1. Что такое ссылка, как она объявляется?
2. Константные ссылки.
3. Передача параметров в функцию по значению, по ссылке, по константной ссылке.
4. Особенности работы ссылок на временные объекты. Чему равно время жизни временного объекта, на который ссылается ссылка?
5. Чему равно выражение `sizeof(ref)`, где ref — ссылка?
6. Как хранятся ссылки внутри классов и структур?
7. Что на самом деле передаётся в функцию, принимающую аргумент по ссылке?

## Пространства имён

1. Что такое пространство имён?
2. Как объявить пространство имён в C++?
3. Можно ли использовать несколько пространств имён в одном файле?
4. Каким образом происходит разрешение конфликтов имен в разных пространствах имён?
5. Какие стандартные пространства имён существуют в C++?
6. Можно ли создавать свои собственные пространства имён?
7. Каким образом можно использовать элементы из других пространств имён?
8. Что такое алиасы (синонимы) пространства имён и как их объявлять?
9. Какой синтаксис используется при обращении к элементам вложенных пространств имён?
10. Безымянное пространство имён. Как его объявить, для чего отличается?

## Модель памяти C++

1. Что такое объект с точки зрения модели памяти языка? Какими свойствами он обладает?
2. Что такое выравнивание? Для чего оно используется?
3. Чем размер объекта отличается от его выравнивания?
4. Выравнивание структур.
5. Как узнать размер объекта?
6. Как узнать выравнивание объекта?

## Указатели

1. Что такое указатель? Для чего применяются указатели?
2. Как объявить указатель на переменную определенного типа?
3. Как получить адрес переменной в памяти и сохранить его в указатель?
4. Как получить значение переменной по ее адресу, на который указывает указатель?
5. Как изменить значение переменной по ее адресу, на который указывает указатель?
6. Как проверить, равны ли два указателя?
7. Как проверить, является ли указатель нулевым?
8. Какие операции можно выполнять с указателями?
9. Какие ошибки могут возникнуть при работе с указателями?
10. В чем отличие ссылки от указателя?
11. Что такое указатель `void*`? Для чего применяется? Какие с ним возможны операции?
12. Чем отличаются указатели `T*`, `const T*`, `T* const` и `const T* const`?
13. Что такое адресная арифметика?
14. К каким указателям применимы операции адресной арифметики?

## Статическое, автоматическое и динамическое размещение объектов в памяти

1. Как разместить объект в статической области памяти? Когда удаляется объект в статической области памяти?
2. Как разместить объект в автоматической области памяти? Когда удаляется объект в автоматической области памяти?
3. Как разместить объект в динамической области памяти? Когда удаляется объект в динамической области памяти?
4. Операторы new и delete. Для чего применяются?
5. Какие ошибки могут возникнуть при работе с объектами в динамической области памяти?

# Стандартная библиотека языка C++

## std::string и std::string_view

1. Что представляет собой класс std::string в C++?
2. Какие типы данных могут использоваться для хранения символов в std::string?
3. Перечислите основные преимущества использования std::string по сравнению с C-строками.
4. Опишите внутреннее устройство std::string в типичных реализациях?
5. Какова разница между `std::string` и `std::wstring`?
6. Какие операции можно выполнять над std::string?
7. Чем отличается размер от вместимости?
8. Что такое small string optimization?
9. Как изменяются значения size и capacity при использовании метода erase?
10. Какова сложность операций вставки и замены символов строки?
11. Класс `std::string_view`, чем отличается от `std::string`?
12. В каких случаях использовать `std::string_view`, а в каких `std::string`?
13. Чем отличается substr в `std::string` и `std::string_view`?
14. Как найти все вхождения некоторой подстроки в строке?
15. Какой метод позволяет объединить две строки в C++?
16. Как **быстро** найти все вхождения некоторой подстроки в строке?
17. Какие операторы сравнения доступны для объектов `std::string`?
18. Как преобразовать `std::string` в числовой тип данных и обратно?
19. Как можно ускорить работу со строками в C++?
20. Какой результат будет у `string_view` после разрушения оригинальной строки?

## std::vector и std::array

1. Что такое `std::array` и как он отличается от C-массива?
2. Можно ли передавать std::array по значению в функцию?
3. Опишите трехмерный массив при помощи `std::array`.
4. Что такое `std::vector`? Чем отличается от простого массива и `std::array`?
5. Описать внутреннее устройство `std::vector`. Желательно показать на схеме.
6. Что произойдёт с полностью заполненным `vector`, если выполнить операцию `push_back`?
7. Типичные операции над `std::vector`. Какая сложность этих операций?
8. Приёмы оптимизации производительности при работе с `std::vector`.
9. Метод `at` и операция `[]`. В каких случаях какую из этих операций следует использовать?
10. Как обойти все элементы `std::vector` в прямом и обратном направлении?
11. Как `std::vector` хранит элементы в памяти: последовательно или с промежутками?
12. Чем размер вектора отличается от его вместимости?
13. Что такое инвалидация итераторов? Какие операции над `std::vector` приводят к инвалидации его итераторов?
14. Что происходит с вектором при вызове `push_back`, если текущий размер равен ёмкости?
15. Чем отличаются `emplace`-методы от `push`/`insert`?
16. Идиома `erase`/`remove`.
17. Как развернуть содержимое `std::vector` за O(1) памяти и O(N) времени?
18. Как получить  указатель на первый элемент вектора?
19. Какова амортизированная сложность операции `push_back`? Что такое амортизированная сложность?
20. Как вставить в вектор элементы из другого контейнера, например из `deque` (в конец, в начало, в середину).
    Какова сложность этих операций?
21. Для чего служит метод `shrink_to_fit()` и когда его стоит применять?
22. Приведите пример использования обратных итераторов у вектора.
23. Что происходит с данными в векторе при вызове `clear()`?
24. Что происходит с итератором `end()`, если размер вектора изменяется?
25. Может ли `std::vector` содержать объекты, для которых не определен оператор присваивания?
26. Может ли `std::vector` содержать объекты, у которых отсутствует конструктор по умолчанию?
27. Для чего нужен метод `reserve`?
28. В каких случаях предпочтительнее использовать `std::vector`, а в каких — `std::list`?
29. Какие ограничения у `std::vector` по сравнению с `std::deque`?
30. Какой контейнер обеспечивает более быстрое вставку/удаление в середине: `std::vector` или `std::list`?


## std::deque

1. Контейнер `std::deque`. Чем отличается от std::vector, в каких случаях применять vector, а в каких deque?
2. Какой заголовочный файл необходимо подключить для работы с `std::deque`?
3. Как устроен контейнер std::deque внутри? Нарисуйте схему и объясните её работу.
   Какие структуры данных используют типичные реализации этого контейнера?
4. Почему размер блоков и количество блоков в `std::deque` обычно являются степенями двойки?  
5. Какие операции над `std::deque` приводят, а какие не приводят к инвалидации итераторов? Объясните, с чем это связано?
6. Для чего типичные реализации deque используют "закольцованность" блоков? 
7. Основные операции над `std::deque` и их сложность.
8. Чем отличаются emplace-методы от `push`/`insert`
9. Отличия `std::deque` от `std::list`. Когда лучше применять `deque`, а когда `list`?
10. Какие операции над std::deque приводят к инвалидации ссылок?
11. Как развернуть std::deque?
12. За счёт чего в `std::deque` обеспечивается доступ к элементам по индексу за O(1)?
13. Как вставить в deque элементы из другого контейнера (в начало, в конец, в середину)?
14. Какой метод `std::deque` позволяет безопасно получить элемент по индексу с проверкой границ?
15. Почему в `std::deque` нет метода `data`, в отличие от `std::vector`?
16. Какой получить ссылку на последний элемент `std::deque`?
17. Какой из контейнеров более компактно хранит элементы в памяти: `std::deque` или `std::list`? Почему?
18. Последовательная итерация по элементам какого из перечисленных контейнеров будет более быстрой:
    `deque`, `vector`, `list`?
19. Как `std::deque` обрабатывает ситуацию, когда блоки заполнены?
20. Сравните скорость вставки элементов в начало и в конец `std::deque` и `std::vector`.
21. Сравните время доступа к элементу по его индексу в случае с `std::deque` и `std::vector`.
22. В каких случаях `std::deque` предпочтительнее `std::vector`?
23. Какие ограничения у `std::deque` по сравнению с `std::list`? 
24. Какой контейнер обеспечивает более быстрое вставку/удаление в середине: `std::deque` или `std::list`?

## std::list и std::forward_list

1. Контейнер `std::list` и `std::forward_list`, чем отличаются? Когда использовать `list`, а когда `forward_list`?
2. Какие операции поддерживает `std::list`, а какие `std::forward_list`?
3. Какие операции над `list` и `forward_list` приводят к инвалидации ссылок и итераторов, а какие нет? Почему?
4. Как развернуть `std::forward_list`? Какова сложность этой операции по памяти и по времени?
5. Как отсортировать `std::list`? Какова сложность этой операции?
6. Как перенести элементы из одного списка в другой? Какова сложность этих операций?
7. Как удалить элементы std::list, удовлетворяющие заданному критерию?
8. Как удалить из std::list подряд идущие дубликаты? `[1, 3, 2, 2, -8, 5, 1, 1, 1, 2]` -> `[1, 3, 2, -8, 5, 1, 2]`
9. Как перенести элементы из одного `forward_list` в другой. Какова сложность этих операций?
10. Как отсортировать всё содержимое `forward_list`?
11. Как отсортировать диапазон элементов `std::list` и `std::forward_list`?

## Контейнеры map и multimap

1. Контейнер std::map. Для чего используется?
2. Операции над map. Какова сложность этих операций?
3. В каком порядке находятся элементы std::map? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве ключей map использоваться пользовательские типы данных? Что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве значений?
6. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.emplace(key, value)`?
7. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.at(key) = value`?
8. Напишите функцию `optional<string> TryGetValue(const map<int, string>& m, int key)`
9. Как можно ускорить вставку в map?
10. Как быстро перенести элемент из одного контейнера map в другой map того же типа?
11. Как получить все значения multimap с заданным ключом?
12. В каких случаях использовать map, а в каких unordered_map?
13. Чем отличается emplace от try_emplace?
14. В каком порядке возможен обход элементов контейнера map?
15. Как удалить из контейнера map все элементы, удовлетворяющие заданному критерию? Как удалить из контейнера map не более N элементов, удовлетворяющих заданному критерию?

## Контейнеры unordered_map и unordered_multimap

1. Контейнер unordered_map. Для чего используется?
2. Операции над unordered_map. Их сложность.
3. Что означает "амортизированная константа" применительно к сложности операций?
4. В каком порядке хранятся элементы внутри unordered_map? Можно ли изменить порядок этих элементов?
5. Как можно ускорить вставку в unordered_map?
6. Чем отличается вставка элементов c помощью `umap[key] = value` от вставки `umap.emplace(key, value)`?
7. Чем отличается вставка элементов c помощью `umap[key] = value` от вставки `umap.at(key) = value`?
8. Напишите функцию `optional<string> TryGetValue(const unordered_map<int, string>& m, int key)`.
9. Что нужно сделать, чтобы в качестве ключей unordered_map использовать пользовательские типы данных?
10. Что такое хеш-функция? Как она используется в unordered_map?
11. Как быстро перенести элемент из одного unordered_map в другой того же типа
12. Что такое bucket-ы в unordered_map? Как они влияют на производительность?
13. Что такое rehashing? Когда он возникает? Как можно им управлять?
14. Контейнер unordered_multimap. Чем отличается от unordered_map?
15. Как получить все элементы unordered_map с одним и тем же ключом?
16. В каком порядке возможен обход элементов unordered_map?
17. Когда использовать map, а когда unordered_map?
18. Как удалить из unordered_map не более N элементов, удовлетворяющих заданному критерию?

## Контейнеры set и multiset

1. Контейнер std::set. Для чего используется?
2. Операции над set. Какова сложность этих операций?
3. В каком порядке находятся элементы std::set? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве элементов set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов set?
6. Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
7. Как быстро перенести один элемент из одного контейнера set в другой того же типа?
8. Когда использовать set, а когда unordered_set?
9. Как можно ускорить вставку в set?
10. Как скопировать элементы из vector в set? Как скопировать элементы из set в vector?
11. Контейнер multiset. Как получить все значения контейнера multiset с заданным ключом?
12. Чем отличается insert от emplace?
13. Как удалить из set все элементы, удовлетворяющие заданному критерию? Как удалить из set не более N элементов, удовлетворяющих заданному критерию?

## Контейнеры unordered_set и unordered_multiset

1. Контейнер std::unordered_set. Для чего используется?
2. Операции над unordered_set. Какова сложность этих операций?
3. В каком порядке находятся элементы std::unordered_set? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве элементов unordered_set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов unordered_set?
6. Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
7. Как быстро перенести один элемент из одного контейнера unordered_set в другой того же типа?
8. Когда использовать set, а когда unordered_set?
9. Как скопировать элементы из vector в unordered_set? Как скопировать элементы из unordered_set в vector?
10. Контейнер unordered_multiset. Как получить все значения контейнера unordered_multiset с заданным ключом?
11. Как удалить из unordered_set все элементы, удовлетворяющие заданному критерию? Как удалить из unordered_set не более N элементов, удовлетворяющих заданному критерию?
12. Что такое хеш-функция? Как она используется в unordered_set?
13. Что такое bucket-ы в unordered_set? Как они влияют на производительность?
14. Что такое rehashing? Когда он возникает? Как можно им управлять?

## Стандартные алгоритмы

1. Сортировка элементов. Простая и стабильная сортировка. Алгоритмы частичной сортировки.
2. Подсчёт элементов, удовлетворяющих заданному критерию.
3. Поиск минимума и максимума.
4. Нахождение медианы и процентилей.
5. Поиск элементов. Последовательный. Двоичный поиск. Алгоритмы быстрого поиска всех вхождений подстроки в строке.
6. Копирование и преобразование элементов.
7. Алгоритмы над отсортированными множествами элементов: пересечение, объединение, разность множеств.

## std::optional

1. Для чего нужен класс `std::optional`?
2. Как узнать, содержит ли объект `std::optional` значение?
3. Как получить доступ к значению?
4. Какие ошибки могут возникнуть при работе с классом `std::optional`?
5. Напишите функцию, которая складывает два значения типа `optional<int>` и возвращает пустое значение, если хотя бы одно из слагаемых пустое, либо сумму чисел, если оба аргумента непустые.

## std::variant

1. Для чего нужен класс `std::variant`?
2. Как проверить, содержит ли std::variant значение нужного типа или нет?
3. Может ли std::variant не содержать значение?
4. Как с помощью `std::visit` обработать все допустимые значения внутри `std::variant`?
5. Для чего нужен `std::monotype`? Приведите пример.
6. Реализуйте операцию `StringOrInt operator+(const StringOrInt& a, const StringOrInt& b)`, где тип `StringOrInt` — это `std::variant<std::string, int>`. Сложение должно происходить по правилам языка JavaScript:
   1. 10 + 20 => 30
   2. 10 + "20" => "1020"
   3. "10" + 20 = "1020"
   4. "10" + "20" = "1020"

## Стандартные умные указатели

1. Для чего нужны умные указатели?
2. Умный указатель `std::unique_ptr`. Какую семантику владения реализует этот умный указатель?
3. Как ли вернуть `unique_ptr` из функции?
4. Как вызвать функцию, принимающую `unique_ptr` по значению?
5. Как создать в динамической памяти объект, и обернуть его в `unique_ptr`?
6. Как использовать `unique_ptr` и `shared_ptr` для управления ресурсами, отличными от объектов в динамической памяти? Например, файлом, открытым функцией `fopen`?
7. Умный указатель `std::shared_ptr`. Какую семантику владения объектом реализует этот умный указатель?
8. Какие фундаментальные проблемы управления объектом имеет `shared_ptr`?
9. Умный указатель `std::weak_ptr`. Для чего применяется?
10. Как создать в динамической памяти объект и обернуть его в `shared_ptr`?
11. Как преобразовать `std::shared_ptr<Derived>` к `std::shared_ptr<Base>` и обратно?
12. Как внутри метода объекта, которым владеет `shared_ptr`, получить `shared_ptr`, ссылающийся на этот же самый объект? Для чего это может понадобиться?
13. Как на основе `shared_ptr`, который владеет на объектом-агрегатом (например, структурой), получить `shared_ptr` на составную часть агрегата (например, поле структуры)? При этом объект-агрегат должен жить пока жив либо указатель на часть, либо указатель на целое.

# Объектно-ориентированное программирование

## Понятие класса

1. Что такое класс
2. Объявление класса в C++
3. Проблемы прямого доступа к данным класса. Инкапсуляция.
4. Методы класса
5. Указатель `this`
6. Константные методы.
7. Статические данные и методы класса.
8. mutable-данные класса.
9. Свойства
10. Размещение кода класса в .h И .cpp файлах
11. Чем класс отличается от структуры? Когда использовать структуры, а когда классы?
12. Модификаторы уровня доступа к содержимому классов

## Жизненный цикл объекта

1. Конструктор
2. Конструктор по умолчанию
3. Конвертирующий конструктор
4. explicit конструктор
5. Инициализация полей класса в конструкторе. Списки инициализации
6. Деинициализация класса. Деструктор.
7. Копирующий конструктор
8. Копирующий оператор присваивания
9. Запрет копирования и присваивания
10. Делегирующий конструктор

## Семантика перемещения

1. Перемещающий конструктор
2. В чём отличие перемещения от копирования?
3. Какие преимущества даёт перемещение по сравнению с копированием?
4. Какие стандартные классы поддерживают семантику перемещения?
5. В каком состоянии должен остаться объект после перемещения?
6. Перемещающий оператор присваивания
7. Когда нужно создавать пользовательские конструктор/деструктор/операции присваивания?
8. Запрещение присваивания и перемещения объектов
9. Что делает std::move?
10. "Правило пяти"

## Отношения между классами

1. Отношение композиции. Обозначение композиции на диаграмме классов.
2. Как композиция реализуется в C++?
3. Отношение агрегации. Обозначение агрегации на диаграмме классов.
4. Как агрегация реализуется в C++?
5. Чем композиция отличается от агрегации?
6. Зависимость. Обозначение зависимости на диаграмме классов.
7. Транзитивность зависимостей.
8. Чем зависимость отличается от агрегации и композиции?
9. Когда применять зависимость, когда агрегацию, а когда композицию?

## Наследование

1. Смысл отношения наследования.
2. Что такое `базовый`, `родительский` и `производный` классы?
3. Обозначение наследования на диаграммах классов.
4. Вызов конструкторов и деструкторов при наследовании.
5. Каковы особенности публичного, приватного и защищённого наследования? Когда их следует применять?
6. К каким полям и методам класса может иметь доступ класс-наследник?
7. В каком случае возможно приведение типа вверх по иерархии классов. Как влияет тип наследования на приведение типа по иерархии наследования?
8. Что произойдёт, если в классе-наследнике будет объявлен метод с тем же именем, что в одном из его родителей?
9. Как класс-наследник может вызвать одноименный метод своего родителя?
10. Чем отличается  `class X final { /*...*/ };` от `class X { /*...*/ };`. Когда следует объявлять класс или структуру финальной?
11. Как в функцию `void F(Base&)` передать ссылку на объект класса `class Derived : private Base {...};`?

## Полиморфизм

1. Что такое виртуальные методы и для чего они нужны? Чем отличаются виртуальные методы от невиртуальных?
2. Как переопределить виртуальную функцию в производном классе?
3. Для чего в C++ деструктор объявляется виртуальным? В каких случаях деструктор не нужно объявлять виртуальным?
4. Особенности вызова виртуальных функций в конструкторе и деструкторе класса.
5. Как и для чего применяется спецификатор `override` у методов?
6. Как и для чего применяется спецификатор `final` у методов?
7. Может ли конструктор быть виртуальным?
8. Что такое полиморфизм?
9. Что такое абстрактный класс? Для чего он нужен?
10. Что такое интерфейс? Как объявить интерфейс в C++?
11. Чем отличается абстрактный класс от интерфейса?
12. Как наследование позволяет реализовывать полиморфизм времени выполнения?
13. Как в большинстве компиляторов реализованы виртуальные функции?
14. Приведение типа вниз по иерархии классов. Оператор `dynamic_cast`.

## Множественное наследование

1. Для чего применяется множественное наследование?
2. В каком порядке вызываются конструкторы и деструкторы при множественном наследовании?
3. Какие проблемы создаёт наследование от двух и более классов, которые имеют общего предка?
4. Для чего используется виртуальное наследование в C++? Как его применяют?
5. Как в C++ реализовать несколько интерфейсов?
6. Пусть класс `Derived` унаследован от несвязанных друг с другом классов `Base1` и `Base2`, в каждом из которых есть метод виртуальный метод `Foo()`. Как в `Derived` переопределить метод `Foo` класса `Base1`?
7. В чём заключается различие в структуре объекта при виртуальном и невиртуальном наследовании?

## Перегрузка арифметических операций и операций сравнения

1. Перегрузка присваивающих выражений: `+=`, `-=`, `*=`, `/=`.
2. Перегрузка бинарных арифметических операций: `+`, `-`, `*`, `/`.
3. Особенности перегрузки бинарных операций с разным типом аргументов.
4. Перегрузка унарного `+` и `-`.
5. Перегрузка операций сравнения: `<`, `>`, `<=`, `>=`, `==`, `!=`
6. Операция `<=>`. Типы ordering-а. default-реализация операции <=>.

## Перегрузка прочих операций

1. Перегрузка операций `<<` и `>>` для вывода в поток.
2. Перегрузка операции разыменования `*` и обращения к полю класса `->`. Для чего применяется?
3. Перегрузка операции индексации `[]`. Как перегрузить операцию `[]` для `чтения` и для `записи`.
4. Перегрузка операций `++` и `--`.
5. Перегрузка операций приведения типа.
6. Перегрузка операции вызова функции `()`. Для чего применяются?

## Обработка исключений

1. Выбрасывание исключения.
2. Перехват исключений заданного типа.
3. Перехват всех исключений.
4. Перевыброс пойманного исключения.
5. Особенности выбрасывания исключений в конструкторе и деструкторе класса
6. Как указать, что функция или метод не выбрасывают исключений?
7. Почему рекомендуется перемещающий конструктор и оператор присваивания делать не выбрасывающими исключений?
8. Что такое срезка? Как избежать срезки при обработке исключений?
9. Стандартные классы исключений.
10. Иерархия классов исключений.
11. Какие преимущества даёт возможность использовать классы в качестве объектов исключений?
12. Какие средства стандартной библиотеки позволяют узнать, что у класса или структуры конструктор копирования/перемещения не выбрасывает исключений.
13. Для чего служит класс `std::nested_exception`? Приведите пример использования.
14. Как перехватить все исключения стандартной библиотеки?

## Разработка кода, устойчивого к возникновению исключений

1. Какие существуют гарантии безопасности исключений? В чем они заключаются?
2. Принципы написания кода, устойчивого у возникновению исключений.
3. Идиома RAII (Resource acquisition is initialization)
4. Как обеспечить строгую гарантию безопасности исключений при реализации методов?
5. Как определить, какой уровень безопасности исключений предоставляет функция или метод?
6. Привести пример кода, небезопасного к возникновению исключений. Продемонстрировать, как обеспечить для этого кода базовую или строгую гарантию безопасности исключений.

## Шаблоны функций

1. Как объявить шаблон функции?
2. Может ли шаблонная функция не иметь аргументов?
3. Что может использоваться в качестве параметров шаблона? Приведите пример.
4. Для чего используется специализация шаблонов функций? Приведите пример специализации шаблонной функции.
5. Как объявить специализацию шаблонной функции?
6. Может ли специализация шаблонной функции сама быть шаблоном? Если да, приведите пример.
7. Как объявляются шаблонные операторы? Приведите пример.

## Шаблоны классов

1. Как объявить шаблон класса?
2. Как объявляется метод шаблонного класса вне класса?
3. Как объявляется шаблонный метод класса вне класса?
4. Как объявляется шаблонный метод шаблонного класса вне класса?
5. Чем отличается частичная и полная специализация шаблона класса. 
6. Как объявить частичную и полную специализацию шаблона класса?
7. Может ли виртуальный метод класса быть шаблонным?
8. Применение шаблонов при построении иерархий классов.

## Шаблоны с переменным числом аргументов

1. Как объявить функцию-шаблон с переменным количеством аргументов?
2. Как объявить класс-шаблон с переменным количеством аргументов?
3. Напишите шаблонную функцию Second, принимающую произвольное количество аргументов любого типа и возвращающую второй аргумент.
4. Как из шаблонной функции, принимающей произвольное число аргументов вызвать другую функцию с произвольным количеством аргументов и передать туда все аргументы?
5. Свёрточные выражения. Напишите шаблонную функцию `ApplyToMany`, которая принимает функциональный объект f и произвольное количество аргументов,
 а потом последовательно вызывает f с каждым из переданных аргументов.
6. Напишите шаблонную функцию `EqualsToOneOf`, принимающую один или более аргументов. Функция должна вернуть true, если ёё первый аргумент равен одному из остальных аргументов и false в противном случае.
7. Напишите шаблонную функцию Last, принимающую произвольное количество аргументов любого типа и возвращающую свой последний аргумент.
