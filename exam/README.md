- [Основы синтаксиса языка C++](#основы-синтаксиса-языка-c)
  - [Целочисленные типы данных](#целочисленные-типы-данных)
  - [Типы данных вещественных чисел](#типы-данных-вещественных-чисел)
  - [Логический тип данных](#логический-тип-данных)
  - [Символьные литералы](#символьные-литералы)
  - [Строковые литералы](#строковые-литералы)
  - [Переменные](#переменные)
  - [Синонимы типов](#синонимы-типов)
  - [Перечислимый тип данных](#перечислимый-тип-данных)
  - [Приведение типа](#приведение-типа)
  - [Управление ходом выполнения программы](#управление-ходом-выполнения-программы)
  - [Функции](#функции)
  - [Структуры](#структуры)
  - [Массивы](#массивы)
  - [Ссылки](#ссылки)
  - [Пространства имён](#пространства-имён)
  - [Модель памяти C++](#модель-памяти-c)
  - [Указатели](#указатели)
  - [Статическое, автоматическое и динамическое размещение объектов в памяти](#статическое-автоматическое-и-динамическое-размещение-объектов-в-памяти)
- [Стандартная библиотека языка C++](#стандартная-библиотека-языка-c)
  - [std::string и std::string\_view](#stdstring-и-stdstring_view)
  - [std::vector](#stdvector)
  - [std::deque](#stddeque)
  - [std::list и std::forward\_list](#stdlist-и-stdforward_list)
  - [Контейнеры map и multimap](#контейнеры-map-и-multimap)
  - [Контейнеры unordered\_map и unordered\_multimap](#контейнеры-unordered_map-и-unordered_multimap)
  - [Контейнеры set и multiset](#контейнеры-set-и-multiset)
  - [Контейнеры unordered\_set и unordered\_multiset](#контейнеры-unordered_set-и-unordered_multiset)
  - [Стандартные алгоритмы](#стандартные-алгоритмы)
  - [std::optional](#stdoptional)
  - [std::variant](#stdvariant)
  - [Стандартные умные указатели](#стандартные-умные-указатели)
- [Объектно-ориентированное программирование](#объектно-ориентированное-программирование)
  - [Понятие класса](#понятие-класса)
  - [Жизненный цикл объекта](#жизненный-цикл-объекта)
  - [Семантика перемещения](#семантика-перемещения)
  - [Отношения между классами](#отношения-между-классами)
  - [Наследование](#наследование)
  - [Полиморфизм](#полиморфизм)
  - [Множественное наследование](#множественное-наследование)
  - [Перегрузка арифметических операций и операций сравнения](#перегрузка-арифметических-операций-и-операций-сравнения)
  - [Перегрузка прочих операций](#перегрузка-прочих-операций)
  - [Обработка исключений](#обработка-исключений)
  - [Разработка кода, устойчивого в возникновению исключений](#разработка-кода-устойчивого-в-возникновению-исключений)
  - [Шаблоны функций](#шаблоны-функций)
  - [Шаблоны классов](#шаблоны-классов)

# Основы синтаксиса языка C++

## Целочисленные типы данных
1. Каковы основные типы целых чисел в C++?
2. Как объявить переменную целого типа в C++?
3. Каковы диапазоны значений для различных типов целых чисел в C++?
4. Каковы основные операции, которые можно выполнять с целыми числами в C++?
5. Каковы правила преобразования типов при выполнении операций с целыми числами в C++?
6. Какие битовые операции можно использовать для работы с целыми числами в C++? Привести примеры
7. Как проверить, является ли целое число четным или нечетным в C++?
8. Как вычислить остаток от деления двух целых чисел в C++? Чему
9. Как проверить, является ли целое число положительным или отрицательным в C++?
10. Как использовать условные операторы и циклы для работы с целыми числами в C++?

## Типы данных вещественных чисел
1. Какие типы вещественных чисел существуют в C++?
2. Как объявить переменную вещественного типа в C++?
3. Каковы диапазоны значений для различных типов вещественных чисел в C++?
4. Какие операции можно выполнять с вещественными числами в C++?
5. Как происходит преобразование типов при выполнении операций с вещественными числами в C++?
6. Какие математические функции доступны в C++ для работы с вещественными числами?
7. Как проверить, является ли вещественное число положительным или отрицательным в C++?
8. Как проверить, является ли вещественное число целым в C++?
9. Как округлить вещественное число до целого в C++?
10. Как сравнить два вещественных числа на равенство в C++?

## Логический тип данных
1. Какой тип данных используется для хранения логических значений в C++?
2. Какие значения может принимать логический тип в C++?
3. Как объявить переменную логического типа в C++?
4. Какие операторы сравнения могут использоваться с логическим типом в C++?
5. Какие логические операторы доступны в C++?
6. Какой результат выражения true && false в C++?
7. Какой результат выражения true || false в C++?
8. Какой результат выражения !true в C++?
9. Какой результат выражения (5 > 3) && (7 < 10) в C++?
10. Какой результат выражения (4 == 4) || (6 != 6) в C++?

## Символьные литералы
1. Какие символьные литералы поддерживаются в языке С++?
2. Что такое символьный литерал, и как он объявляется в С++?
3. Какие символьные значения можно задать с помощью символьных литералов в С++?
4. Какой символьный литерал используется для обозначения перевода строки в С++?
5. Может ли символьный литерал содержать несколько символов? Если да, то как это делается?
6. Что такое управляющие последовательности символов, и какие из них поддерживаются в С++?
7. Приведите не менее 3 примеров символьных литералов в С++?
8. Какие символьные литералы используются для обозначения специальных символов, таких как пробел или знак табуляции?

## Строковые литералы
1. Как объявляется строковый литерал в языке C++?
2. Что такое управляющие последовательности символов и как они используются в строковых литералах в языке C++?
3. Каким образом можно задать пустую строку в языке C++?
4. Каким образом можно скомбинировать два строковых литерала в одну строку в языке C++?
5. Как строковые литералы представляются в памяти?
6. Строковые литералы и для чего они нужны. Как использовать сырые строковые литералы
7. Чем отличаются эти строковые литералы: `L"Hello"` от `"Hello"`?

## Переменные
1. Объявление переменных
2. Автоматическое определение типа переменной
3. Объявление константной переменной.
4. Области видимости переменных.
5. Доступ к переменной, объявленной в другое единице трансляции.

## Синонимы типов
1. Что такое синоним типа в языке C++ и для чего он используется?
2. Каким образом объявляются синонимы типов в языке C++?
3. Объявите синоним типов с помощью `using`.
4. Как объявить синоним типа для стандартных типов данных, таких как int или double, в языке C++?
5. Как объявить синоним типа для пользовательского типа данных в языке C++?
6. Какие преимущества имеет использование синонимов типов в языке C++?
7. Каким образом можно определить новый тип данных с использованием `typedef` в языке C++?=

## Перечислимый тип данных
1. Что такое перечислимый тип данных в языке C++ и для чего он используется?
2. Как объявляется перечислимый тип данных в языке C++?
3. Чем отличается перечислимый тип данных от обычных целочисленных типов данных в языке C++?
4. Какие значения могут принимать элементы перечислимого типа данных в языке C++?
5. Каким образом можно указать базовый тип данных для перечисляющего типа данных в языке C++?
6. Что такое scoped enum в языке C++ и как он отличается от обычного перечислимого типа данных?
7. Как объявляется scoped enum в языке C++?
8. Как можно обратиться к элементу scoped enum в языке C++?
9. Что такое underlying type у scoped enum в языке C++ и как он используется?
10. Какие преимущества имеет использование scoped enum в языке C++ перед обычным перечислимым типом данных?


## Приведение типа
1. Что такое приведение типа (typecasting) в языке C++ и для чего оно нужно?
2. Что такое явное приведение типа (explicit typecasting) и каким оператором оно осуществляется в языке C++?
3. Что такое неявное приведение типа (implicit typecasting) и как оно происходит в языке C++?
4. Приведите пример неявного приведение типа в языке C++?
5. Приведение типа в стиле языка C.
6. Какие операторы приведения типов есть в языке C++ и для чего они нужны?


## Управление ходом выполнения программы
1. Выражения, инструкции, блоки
2. Оператор if. Конструкция else if.
3. `if constexpr`. Для чего используется? Какие ограничения?
4. Оператор цикла `for`. Цикл `for` со счётчиком. Синтаксис.
5. Range-based `for`. Что нужно сделать, чтобы элементы контейнера можно было перебирать, используя range-based `for`? 
6. Оператор цикла `while`.
7. Оператор цикла `do-while`.
8. Досрочный выход из цикла и пропуск итерации цикла.
9.  Как, находясь во внутреннем цикле, выйти из внешнего?
10. Оператор множественного выбора `switch`.
11. Для чего применяется атрибут `[[fallthrough]]`?

## Функции
1. Объявление функции.
2. Определение функции.
3. Аргументы по умолчанию.
4. Лямбда функции.
5. Захват параметров лямбда функции по значению и по ссылке. Чем отличаются
6. Можно ли изменить значение захваченной по значению переменной

## Структуры
1. Для чего нужны структуры?
2. Как объявить структуру?
3. Что такое член структуры и как им можно управлять?
4. Способы инициализации структур?
5. Как обратиться к полю структуры?
6. Как передать структуру в функцию в C++, и какие способы можно использовать для передачи структуры?
7. Указатель на структуру, как обратиться к полю структуры по указателю?
8. Массивы структур.
9. Размещение полей структур в памяти.

## Массивы
1. Как объявить массив в C++?
2. Что такое индекс массива?
3. Как получить доступ к элементу массива по индексу?
4. Как узнать размер массива?
5. Можно ли изменить размер массива после его создания?
6. Как заполнить массив значениями по умолчанию?
7. Как отсортировать элементы массива в порядке возрастания?
8. Что общего у строковых литералов и массивов символов?
9. Что такое std::array и как оно отличается от обычного массива?
10. Объявление многомерных массивов. Объявление многомерного массива с помощью `std::array`

## Ссылки
1. Что такое ссылка, как она объявляется?
2. Константные ссылки.
3. Передача параметров в функцию по значению, по ссылке, по константной ссылке.
4. Особенности ссылкой на временные объекты.

## Пространства имён
1. Что такое пространство имён?
2. Как объявить пространство имён в C++?
3. Можно ли использовать несколько пространств имён в одном файле?
4. Каким образом происходит разрешение конфликтов имен в разных пространствах имён?
5. Какие стандартные пространства имён существуют в C++?
6. Можно ли создавать свои собственные пространства имён?
7. Каким образом можно использовать элементы из других пространств имён?
8. Что такое алиасы (синонимы) пространства имён и как их объявлять?
9. Какой синтаксис используется при обращении к элементам вложенных пространств имён?
10. Безымянное пространство имён. Как его объявить, для чего отличается?

## Модель памяти C++
1. Что такое объект с точки зрения модели памяти языка? Какими свойствами он обладает?
2. Что такое выравнивание? Для чего оно используется?
3. Чем размер объекта отличается от его выравнивания?
4. Выравнивание структур.
5. Как узнать размер объекта?
6. Как узнать выравнивание объекта?

## Указатели
1. Что такое указатель? Для чего применяются указатели?
2. Как объявить указатель на переменную определенного типа?
3. Как получить адрес переменной в памяти и сохранить его в указатель?
4. Как получить значение переменной по ее адресу, на который указывает указатель?
5. Как изменить значение переменной по ее адресу, на который указывает указатель?
6. Как проверить, равны ли два указателя?
7. Как проверить, является ли указатель нулевым?
8. Какие операции можно выполнять с указателями?
9.  Какие ошибки могут возникнуть при работе с указателями?
10. В чем отличие ссылки от указателя?
11. Что такое указатель `void*`? Для чего применяется? Какие с ним возможны операции?
12. Чем отличаются указатели `T*`, `const T*`, `T* const` и `const T* const`?
13. Что такое адресная арифметика?
14. К каким указателям применимы операции адресной арифметики?

## Статическое, автоматическое и динамическое размещение объектов в памяти
1. Как разместить объект в статической области памяти? Когда удаляется объект в статической области памяти?
2. Как разместить объект в автоматической области памяти? Когда удаляется объект в автоматической области памяти?
3. Как разместить объект в динамической области памяти? Когда удаляется объект в динамической области памяти?
4. Операторы new и delete. Для чего применяются?
5. Какие ошибки могут возникнуть при работе с объектами в динамической области памяти?

# Стандартная библиотека языка C++

## std::string и std::string_view
1. Класс std::string.
2. Какого внутреннее устройство std::string в типичных реализациях?
3. Какие операции можно выполнять над std::string?
4. Что такое small string optimization?
5. Какова сложность операций вставки и замены символов строки?
6. Класс std::string_view, чем отличается от std::string?
7. В каких случаях использовать std::string_view, а в каких std::string?
9. Чем отличается substr в std::string и std::string_view?
10. Как найти все вхождения некоторой подстроки в строке?
11. Как быстро найти все вхождения некоторой подстроки в строке?
12. Как преобразовать std::string в числовой тип данных и обратно?
13. Как можно ускорить работу со строками в C++?

## std::vector
1. Что такое `std::vector`? Чем отличается от простого массива и `std::array`?
2. Описать внутреннее устройство `std::vector`. Желательно показать на схеме.
3. Что произойдёт с полностью заполненным `vector`, если выполнить операцию `push_back`?
4. Типичные операции над `std::vector`. Какая сложность этих операций?
5. Приёмы оптимизации производительности при работе с `std::vector`.
6. Метод `at` и операция `[]`. В каких случаях какую из этих операций следует использовать?
7. Как обойти все элементы `std::vector` в прямом и обратном направлении?
8. Чем размер вектора отличается от его вместимости?
9. Что такое инвалидация итераторов? Какие операции над `std::vector` приводят к инвалидации его итераторов?
10. Чем отличаются `emplace`-методы от `push`/`insert`?
11. Идиома `erase`/`remove`.
12. Как развернуть содержимое `std::vector` за O(1) памяти и O(N) времени?
13. Как вставить в вектор элементы из другого контейнера, например из `deque` (в конец, в начало, в середину). Какова сложность этих операций?

## std::deque
1. Контейнер std::deque. Чем отличается от std::vector, в каких случаях применять vector, а в каких deque?
2. Какие операции над std::deque приводят к инвалидации итераторов 
3. Основные операции над std::deque и их сложность.
4. Чем отличаются emplace-методы от push/insert
5. Отличия std::deque от std::list. Когда лучше применять deque, а когда list?
6. Какие операции над std::deque приводят к инвалидации ссылок?
7. Как развернуть std::deque?
8. Как вставить в deque элементы из другого контейнера (в начало, в конец, в середину) 

## std::list и std::forward_list
1. Контейнер `std::list` и `std::forward_list`, чем отличаются? Когда использовать `list`, а когда `forward_list`?
2. Какие операции поддерживает `std::list`, а какие `std::forward_list`?
3. Какие операции над `list` и `forward_list` приводят к инвалидации ссылок и итераторов, а какие нет? Почему?
4. Как развернуть `std::forward_list`? Какова сложность этой операции по памяти и по времени?
5. Как отсортировать `std::list`? Какова сложность этой операции?
6. Как перенести элементы из одного списка в другой? Какова сложность этих операций?
7. Как удалить элементы std::list, удовлетворяющие заданному критерию?
8. Как удалить из std::list подряд идущие дубликаты? `[1, 3, 2, 2, -8, 5, 1, 1, 1, 2]` -> `[1, 3, 2, -8, 5, 1, 2]`
9. Как перенести элементы из одного `forward_list` в другой. Какова сложность этих операций?
10. Как отсортировать всё содержимое `forward_list`?
11. Как отсортировать диапазон элементов `std::list` и `std::forward_list`?


## Контейнеры map и multimap
1. Контейнер std::map. Для чего используется?
2. Операции над map. Какова сложность этих операций?
3. В каком порядке находятся элементы std::map? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве ключей map использоваться пользовательские типы данных? Что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве значений?
6. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.emplace(key, value)`?
7. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.at(key) = value`?
8. Напишите функцию `optional<string> TryGetValue(const map<int, string>& m, int key)`
9. Как можно ускорить вставку в map?
10. Как быстро перенести элемент из одного контейнера map в другой map того же типа?
11. Как получить все значения multimap с заданным ключом?
12. В каких случаях использовать map, а в каких unordered_map?
13. Чем отличается emplace от try_emplace?
14. В каком порядке возможен обход элементов контейнера map?
15. Как удалить из контейнера map все элементы, удовлетворяющие заданному критерию? Как удалить из контейнера map не более N элементов, удовлетворяющих заданному критерию?

## Контейнеры unordered_map и unordered_multimap
1. Контейнер unordered_map. Для чего используется?
2. Операции над unordered_map. Их сложность.
3. Что означает "амортизированная константа" применительно к сложности операций?
4. В каком порядке хранятся элементы внутри unordered_map? Можно ли изменить порядок этих элементов?
5. Как можно ускорить вставку в unordered_map?
6. Чем отличается вставка элементов c помощью `umap[key] = value` от вставки `umap.emplace(key, value)`?
7. Чем отличается вставка элементов c помощью `umap[key] = value` от вставки `umap.at(key) = value`?
8. Напишите функцию `optional<string> TryGetValue(const unordered_map<int, string>& m, int key)`.
9. Что нужно сделать, чтобы в качестве ключей unordered_map использовать пользовательские типы данных?
10. Что такое хеш-функция? Как она используется в unordered_map?
11. Как быстро перенести элемент из одного unordered_map в другой того же типа
12. Что такое bucket-ы в unordered_map? Как они влияют на производительность?
13. Что такое rehashing? Когда он возникает? Как можно им управлять?
14. Контейнер unordered_multimap. Чем отличается от unordered_map?
15. Как получить все элементы unordered_map с одним и тем же ключом?
16. В каком порядке возможен обход элементов unordered_map?
17. Когда использовать map, а когда unordered_map?
18. Как удалить из unordered_map не более N элементов, удовлетворяющих заданному критерию?


## Контейнеры set и multiset
1. Контейнер std::set. Для чего используется?
2. Операции над set. Какова сложность этих операций?
3. В каком порядке находятся элементы std::set? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве элементов set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов set?
6. Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
7. Как быстро перенести один элемент из одного контейнера set в другой того же типа?
8. Когда использовать set, а когда unordered_set?
9. Как можно ускорить вставку в set?
10. Как скопировать элементы из vector в set? Как скопировать элементы из set в vector?
11. Контейнер multiset. Как получить все значения контейнера multiset с заданным ключом?
12. Чем отличается insert от emplace?
13. Как удалить из set все элементы, удовлетворяющие заданному критерию? Как удалить из set не более N элементов, удовлетворяющих заданному критерию?


## Контейнеры unordered_set и unordered_multiset
1. Контейнер std::unordered_set. Для чего используется?
2. Операции над unordered_set. Какова сложность этих операций?
3. В каком порядке находятся элементы std::unordered_set? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве элементов unordered_set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов unordered_set?
6. Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
7. Как быстро перенести один элемент из одного контейнера unordered_set в другой того же типа?
8. Когда использовать set, а когда unordered_set?
9.  Как скопировать элементы из vector в unordered_set? Как скопировать элементы из unordered_set в vector?
10. Контейнер unordered_multiset. Как получить все значения контейнера unordered_multiset с заданным ключом?
11. Как удалить из unordered_set все элементы, удовлетворяющие заданному критерию? Как удалить из unordered_set не более N элементов, удовлетворяющих заданному критерию?
10. Что такое хеш-функция? Как она используется в unordered_set?
12. Что такое bucket-ы в unordered_set? Как они влияют на производительность?
13. Что такое rehashing? Когда он возникает? Как можно им управлять?

## Стандартные алгоритмы
1. Сортировка элементов. Простая и стабильная сортировка. Алгоритмы частичной сортировки.
2. Подсчёт элементов, удовлетворяющих заданному критерию.
3. Поиск минимума и максимума.
4. Нахождение медианы и процентилей.
5. Поиск элементов. Последовательный. Двоичный поиск. Алгоритмы быстрого поиска всех вхождений подстроки в строке.
6. Копирование и преобразование элементов.
7. Алгоритмы над отсортированными множествами элементов: пересечение, объединение, разность множеств.

## std::optional
1. Для чего нужен класс std::optional?
2. Как узнать, содержит ли объект std::optional значение?
3. Как получить доступ к значению?
4. Какие ошибки могут возникнуть при работе с классом std::optional?

## std::variant
1. Для чего нужен класс `std::variant`?
2. Как проверить, содержит ли std::variant значение нужного типа или нет?
3. Может ли std::variant не содержать значение?
4. Как с помощью `std::visit` обработать все допустимые значения внутри `std::variant`?
5. Для чего нужен `std::monotype`? Приведите пример.
6. Реализуйте операцию `StringOrInt operator+(const StringOrInt& a, const StringOrInt& b)`, где тип `StringOrInt` — это `std::variant<std::string, int>`. Сложение должно происходить по правилам языка JavaScript:
   1. 10 + 20 => 30
   2. 10 + "20" => "1020"
   3. "10" + 20 = "1020"
   4. "10" + "20" = "1020"

## Стандартные умные указатели
1. Для чего нужны умные указатели?
2. Умный указатель `std::unique_ptr`. Какую семантику владения реализует этот умный указатель?
3. Как ли вернуть `unique_ptr` из функции?
4. Как вызвать функцию, принимающую `unique_ptr` по значению?
5. Как создать в динамической памяти объект, и обернуть его в `unique_ptr`?
6. Как использовать `unique_ptr` и `shared_ptr` для управления ресурсами, отличными от объектов в динамической памяти? Например, файлом, открытым функцией `fopen`?
7. Умный указатель `std::shared_ptr`. Какую семантику владения объектом реализует этот умный указатель?
8. Какие фундаментальные проблемы управления объектом имеет `shared_ptr`?
9. Умный указатель `std::weak_ptr`. Для чего применяется?
10. Как создать в динамической памяти объект и обернуть его в `shared_ptr`?
11. Как преобразовать `std::shared_ptr<Derived>` к `std::shared_ptr<Base>` и обратно?
12. Как внутри метода объекта, которым владеет `shared_ptr`, получить `shared_ptr`, ссылающийся на этот же самый объект? Для чего это может понадобиться?
13. Как на основе `shared_ptr`, который владеет на объектом-агрегатом (например, структурой), получить `shared_ptr` на составную часть агрегата (например, поле структуры)? При этом объект-агрегат должен жить пока жив либо указатель на часть, либо указатель на целое.

# Объектно-ориентированное программирование

## Понятие класса
1. Что такое класс
2. Объявление класса в C++
3. Проблемы прямого доступа к данным класса. Инкапсуляция.
4. Методы класса
5. Указатель `this`
6. Константные методы.
7. Статические данные и методы класса.
8. mutable-данные класса.
8. Свойства
9. Размещение кода класса в .h И .cpp файлах
10. Чем класс отличается от структуры? Когда использовать структуры, а когда классы?
11. Модификаторы уровня доступа к содержимому классов

## Жизненный цикл объекта
1. Конструктор
2. Конструктор по умолчанию
3. Конвертирующий конструктор
4. explicit конструктор
5. Инициализация полей класса в конструкторе. Списки инициализации
6. Деинициализация класса. Деструктор.
8. Копирующий конструктор
9. Копирующий оператор присваивания
10. Запрет копирования и присваивания

## Семантика перемещения
1. Перемещающий конструктор
2. В чём отличие перемещения от копирования?
3. Какие преимущества даёт перемещение по сравнению с копированием?
4. Какие стандартные классы поддерживают семантику перемещения?
5. В каком состоянии должен остаться объект после перемещения?
6. Перемещающий оператор присваивания
7. Когда нужно создавать пользовательские конструктор/деструктор/операции присваивания?
8. Запрещение присваивания и перемещения объектов
9.  Что делает std::move?
10. "Правило пяти"

## Отношения между классами
1. Отношение композиции. Обозначение композиции на диаграмме классов.
2. Как композиция реализуется в C++?
3. Отношение агрегации. Обозначение агрегации на диаграмме классов.
4. Как агрегация реализуется в C++?
5. Чем композиция отличается от агрегации?
6. Зависимость. Обозначение зависимости на диаграмме классов.
7. Транзитивность зависимостей.
8. Чем зависимость отличается от агрегации и композиции?
9. Когда применять зависимость, когда агрегацию, а когда композицию?

## Наследование
1. Смысл отношения наследования.
2. Что такое базовый и производный класс?
3. Вызов конструкторов и деструкторов при наследовании.
4. Обозначение наследования на диаграммах классов.
5. Каковы особенности публичного, приватного и защищённого наследования? Когда их следует применять?
6. К каким полям и методам класса может иметь доступ класс-наследник?
7. Приведение типа вверх по иерархии классов.
8. Что произойдёт, если в классе-наследнике будет объявлен метод с тем же именем, что в одном из его родителей?
9. Чем отличается  `class X final { /*...*/ };` от `class X { /*...*/ };`. Когда следует объявлять класс или структуру финальной?

## Полиморфизм
1. Что такое виртуальные методы и для чего они нужны? Чем отличаются виртуальные методы от невиртуальных? 
2. Как переопределить виртуальную функцию в производном классе?
3. Для чего в C++ деструктор объявляется виртуальным? В каких случаях деструктор не нужно объявлять виртуальным?
4. Особенности вызова виртуальных функций в конструкторе и деструкторе класса.
5. Как и для чего применяется спецификатор `override` у методов?
6. Как и для чего применяется спецификатор `final` у методов?
7. Может ли конструктор быть виртуальным?
8. Что такое полиморфизм?
9. Что такое абстрактный класс? Для чего он нужен?
10. Что такое интерфейс? Как объявить интерфейс в C++?
11. Чем отличается абстрактный класс от интерфейса?
12. Как наследование позволяет реализовывать полиморфизм времени выполнения?
13. Как в большинстве компиляторов реализованы виртуальные функции?
14. Приведение типа вниз по иерархии классов. Оператор `dynamic_cast`.

## Множественное наследование
1. Для чего применяется множественное наследование?
2. Какие проблемы создаёт наследование от двух и более классов, которые имеют общего предка?
3. Для чего используется виртуальное наследование в C++? Как его применяют?
4. Как в C++ реализовать несколько интерфейсов?
5. Пусть класс `Derived` унаследован от несвязанных друг с другом классов `Base1` и `Base2`, в каждом из которых есть метод виртуальный метод `Foo()`. Как в `Derived` переопределить метод `Foo` класса `Base1`?
6. В чём заключается различие в структуре объекта при виртуальном и невиртуальном наследовании?

## Перегрузка арифметических операций и операций сравнения
1. Перегрузка присваивающих выражений: `+=`, `-=`, `*=`, `/=`.
2. Перегрузка бинарных арифметических операций: `+`, `-`, `*`, `/`.
3. Особенности перегрузки бинарных операций с разным типом аргументов.
4. Перегрузка унарного `+` и `-`.
5. Перегрузка операций сравнения: `<`, `>`, `<=`, `>=`, `==`, `!=`
6. Операция `<=>`. Типы ordering-а. default-реализация операции <=>.

## Перегрузка прочих операций
1. Перегрузка операций `<<` и `>>` для вывода в поток.
2. Перегрузка операции разыменования `*` и обращения к полю класса `->`. Для чего применяется?
3. Перегрузка операции индексации `[]`. Как перегрузить операцию `[]` для `чтения` и для `записи`.
4. Перегрузка операций `++` и `--`.
5. Перегрузка операций приведения типа.
6. Перегрузка операции вызова функции `()`. Для чего применяются?

## Обработка исключений
1. Выбрасывание исключения.
2. Перехват исключений заданного типа.
3. Перехват всех исключений.
4. Перевыброс пойманного исключения.
5. Особенности выбрасывания исключений в конструкторе и деструкторе класса
6. Как указать, что функция или метод не выбрасывают исключений?
7. Почему рекомендуется перемещающий конструктор и оператор присваивания делать не выбрасывающими исключений?
8. Что такое срезка? Как избежать срезки при обработке исключений?
9. Стандартные классы исключений.
10. Иерархия классов исключений.
11. Какие преимущества даёт возможность использовать классы в качестве объектов исключений?
12. Какие средства стандартной библиотеки позволяют узнать, что у класса или структуры конструктор копирования/перемещения не выбрасывает исключений.
13. Для чего служит класс `std::nested_exception`? Приведите пример использования.

## Разработка кода, устойчивого в возникновению исключений
1. Какие существуют гарантии безопасности исключений? В чем они заключаются?
2. Принципы написания кода, устойчивого у возникновению исключений.
3. Идиома RAII (Resource acquisition is initialization)
4. Как обеспечить строгую гарантию безопасности исключений при реализации методов?
5. Как определить, какой уровень безопасности исключений предоставляет функция или метод?

## Шаблоны функций
1. Как объявить шаблон функции?
2. Может ли шаблонная функция не иметь аргументов?
3. Что может использоваться в качестве параметров шаблона?
4. Для чего используется специализация шаблонов функций?
5. Как объявить специализацию шаблонной функции?
6. Как объявляются шаблонные операторы?

## Шаблоны классов
1. Как объявить шаблон класса?
2. Как объявляется метод шаблонного класса вне класса?
3. Как объявляется шаблонный метод класса вне класса?
4. Как объявляется шаблонный метод шаблонного класса вне класса?
5. Чем отличается частичная и полная специализация шаблона класса. 
6. Как объявить частичную и полную специализацию шаблона класса?
7. Может ли виртуальный метод класса быть шаблонным?
8. Применение шаблонов при построении иерархий классов.


