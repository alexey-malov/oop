- [Основы синтаксиса языка C++](#основы-синтаксиса-языка-c)
  - [Целочисленные типы данных](#целочисленные-типы-данных)
  - [Типы данных вещественных чисел](#типы-данных-вещественных-чисел)
  - [Логический тип данных](#логический-тип-данных)
  - [Символьные литералы](#символьные-литералы)
  - [Строковые литералы](#строковые-литералы)
  - [Операторы](#операторы)
  - [Переменные](#переменные)
  - [Синонимы типов](#синонимы-типов)
  - [Перечислимый тип данных](#перечислимый-тип-данных)
  - [Приведение типа](#приведение-типа)
  - [Управление ходом выполнения программы](#управление-ходом-выполнения-программы)
  - [Функции](#функции)
  - [Структуры](#структуры)
  - [Массивы](#массивы)
  - [Ссылки](#ссылки)
  - [Пространства имён](#пространства-имён)
  - [Модель памяти C++](#модель-памяти-c)
  - [Указатели](#указатели)
  - [Статическое, автоматическое и динамическое размещение объектов в памяти](#статическое-автоматическое-и-динамическое-размещение-объектов-в-памяти)
- [Стандартная библиотека языка C++](#стандартная-библиотека-языка-c)
  - [std::string и std::string\_view](#stdstring-и-stdstring_view)
  - [std::vector и std::array](#stdvector-и-stdarray)
  - [std::deque](#stddeque)
  - [std::list и std::forward\_list](#stdlist-и-stdforward_list)
  - [Контейнеры map и multimap](#контейнеры-map-и-multimap)
  - [Контейнеры unordered\_map и unordered\_multimap](#контейнеры-unordered_map-и-unordered_multimap)
  - [Контейнеры set и multiset](#контейнеры-set-и-multiset)
  - [Контейнеры unordered\_set и unordered\_multiset](#контейнеры-unordered_set-и-unordered_multiset)
  - [std::function и лямбда-функции](#stdfunction-и-лямбда-функции)
  - [Ввод-вывод](#ввод-вывод)
  - [Итераторы](#итераторы)
  - [Стандартные алгоритмы](#стандартные-алгоритмы)
  - [std::optional](#stdoptional)
  - [Стандартные умные указатели](#стандартные-умные-указатели)
  - [std::filesystem](#stdfilesystem)
  - [std::variant](#stdvariant)
- [Объектно-ориентированное программирование](#объектно-ориентированное-программирование)
  - [Общие сведения об объектно-ориентированном программировании](#общие-сведения-об-объектно-ориентированном-программировании)
  - [Классы, данные и методы - 1](#классы-данные-и-методы---1)
  - [Классы, данные и методы - 2](#классы-данные-и-методы---2)
  - [Жизненный цикл объекта](#жизненный-цикл-объекта)
  - [Копирование, присваивание и перемещение объектов](#копирование-присваивание-и-перемещение-объектов)
  - [Отношения между классами](#отношения-между-классами)
  - [Наследование - 1](#наследование---1)
  - [Наследование - 2](#наследование---2)
  - [Наследование и жизненный цикл объектов](#наследование-и-жизненный-цикл-объектов)
  - [Виды наследования](#виды-наследования)
  - [Интерфейсы и абстрактные классы](#интерфейсы-и-абстрактные-классы)
  - [Приведение типов по иерархии наследования](#приведение-типов-по-иерархии-наследования)
  - [Множественное наследование](#множественное-наследование)
  - [Runtime-полиморфизм с std-variant](#runtime-полиморфизм-с-std-variant)
  - [Перегрузка операций - 1](#перегрузка-операций---1)
  - [Перегрузка операций - 2](#перегрузка-операций---2)
  - [Перегрузка операций - 3](#перегрузка-операций---3)
  - [Перегрузка операций - 4](#перегрузка-операций---4)
  - [Обработка исключений](#обработка-исключений)
  - [Разработка кода, устойчивого к возникновению исключений](#разработка-кода-устойчивого-к-возникновению-исключений)
  - [Шаблоны функций](#шаблоны-функций)
  - [Шаблоны классов](#шаблоны-классов)
  - [Шаблоны с переменным числом аргументов](#шаблоны-с-переменным-числом-аргументов)

# Основы синтаксиса языка C++

## Целочисленные типы данных

1. Каковы основные типы целых чисел в C++?
2. Как объявить переменную целого типа в C++?
3. Каковы диапазоны значений для различных типов целых чисел в C++?
4. Каковы основные операции, которые можно выполнять с целыми числами в C++?
5. Чем отличаются `signed` и `unsigned` типы?
6. Каковы правила преобразования типов при выполнении операций с целыми числами в C++?
7. Какие битовые операции можно использовать для работы с целыми числами в C++? Привести примеры
8. Как проверить, является ли целое число четным или нечетным в C++?
9. Как вычислить остаток от деления двух целых чисел в C++?
10. Чему равно частное и остаток при делении, когда один или оба аргумента — отрицательные?
11. Как проверить, является ли целое число положительным или отрицательным в C++?
12. Как использовать условные операторы и циклы для работы с целыми числами в C++?
13. Как проверить, что при умножении двух целых чисел не будет переполнения?
14. Что означает литерал `12345UL`?
15. Запишите число 123 в двоичной форме в виде C++ литерала.
16. Для чего используется символ `'` внутри числового литерала?
17. Как записываются шестнадцатеричные литералы в C++?
18. Переведите 0321 в десятичную систему.
19. Переведите 0b11101 в десятичную систему.

## Типы данных вещественных чисел

1. Какие типы вещественных чисел существуют в C++?
2. Как объявить переменную вещественного типа в C++?
3. Каковы диапазоны значений для различных типов вещественных чисел в C++?
4. Какие операции можно выполнять с вещественными числами в C++?
5. Как происходит преобразование типов при выполнении операций с вещественными числами в C++?
6. Какие математические функции доступны в C++ для работы с вещественными числами?
7. Как проверить, является ли вещественное число положительным или отрицательным в C++?
8. Как проверить, является ли вещественное число целым в C++?
9. Как округлить вещественное число до целого в C++?
10. Как сравнить два вещественных числа на равенство в C++?
11. Какой тип будет у литерала `2e+10`?
     В чем разница между `1.5`, `1.5f` и `1.5L`?

## Логический тип данных

1. Какой тип данных используется для хранения логических значений в C++?
2. Какие значения считаются `true`, а какие `false` при неявном преобразовании?
3. Какие значения может принимать логический тип в C++?
4. Как объявить переменную логического типа в C++?
5. Какие операторы сравнения могут использоваться с логическим типом в C++?
6. Какие логические операторы доступны в C++?
7. Какой результат выражения true && false в C++?
8. Какой результат выражения true || false в C++?
9. Какой результат выражения !true в C++?
10. Какой результат выражения (5 > 3) && (7 < 10) в C++?
11. Какой результат выражения (4 == 4) || (6 != 6) в C++?

## Символьные литералы

1. Какие символьные литералы поддерживаются в языке С++?
2. Что такое символьный литерал, и как он объявляется в С++?
3. Какие символьные значения можно задать с помощью символьных литералов в С++?
4. Какой символьный литерал используется для обозначения перевода строки в С++?
5. Может ли символьный литерал содержать несколько символов? Если да, то как это делается?
6. Что такое управляющие последовательности символов, и какие из них поддерживаются в С++?
7. Приведите не менее 3 примеров символьных литералов в С++?
8. Какие символьные литералы используются для обозначения специальных символов, таких как пробел или знак табуляции?
9. Как внутри символьного литерала задать символ с заданным кодом?
10. Для чего используют `'\n'` в строках?
11. Как записать символ с шестнадцатеричным кодом 255?
12. Зачем использовать `'\0'` вместо `0`?

## Строковые литералы

1. Как объявляется строковый литерал в языке C++?
2. Что такое управляющие последовательности символов и как они используются в строковых литералах в языке C++?
3. Каким образом можно задать пустую строку в языке C++?
4. Каким образом можно скомбинировать два строковых литерала в одну строку в языке C++?
5. Как строковые литералы представляются в памяти?
6. Строковые литералы и для чего они нужны. Как использовать сырые строковые литералы?
7. Чем отличаются эти строковые литералы: `L"Hello"` от `"Hello"`?
8. Что произойдет, если записать `"abcd" "ef"`?
9. Приведите пример строки с escape-последовательностью.
10. Приведите пример сырого строкового литерала, содержащего обратный слеш.

## Операторы

1. Что произойдёт при выполнении выражения `17 / 5`, если оба операнда имеют тип `int`?
2. Чем отличается поведение оператора `%` при работе с `int` и `float`?
3. Напишите выражение, проверяющее, находится ли переменная `x` в диапазоне от 100 до 200 включительно.
4. Чем логические операторы отличаются от побитовых?
5. Как работают логические операторы `&&` и `||` при коротком замыкании?
6. Какое значение будет у переменной `j` после выполнения `int i = 42; int j = ++i;`?
7. Напишите фрагмент кода, устанавливающий 4 и 7 биты в целочисленной переменной.
8. Напишите фрагмент кода, сбрасывающий все биты кроме 3-го в целочисленной переменной.
9. Напишите код, обменивающий местами 4 и 6 биты в целочисленной переменной.
10. Какой результат даст выражение `0b101101 ^ 0b110110`?

## Переменные

1. Объявление переменных
2. Автоматическое определение типа переменной
3. Объявление константной переменной.
4. Области видимости переменных.
5. Доступ к переменной, объявленной в другое единице трансляции.
6. В чём разница между объявлением и инициализацией переменной?  
7. Приведите пример статической переменной и объясните её поведение.
8. Почему использование `const` при объявлении переменной улучшает безопасность кода?
9. Как объявить константную ссылку на переменную?
10. Почему переменные, объявленные в `switch-case`, должны быть в отдельном блоке `{}`?
11. Что означает ключевое слово `static` перед глобальной переменной?

## Синонимы типов

1. Что такое синоним типа в языке C++ и для чего он используется?
2. Каким образом объявляются синонимы типов в языке C++?
3. Объявите синоним типов с помощью `using`.
4. Как объявить синоним типа для стандартных типов данных, таких как int или double, в языке C++?
5. Как объявить синоним типа для пользовательского типа данных в языке C++?
6. Какие преимущества имеет использование синонимов типов в языке C++?
7. Каким образом можно определить новый тип данных с использованием `typedef` в языке C++?=

## Перечислимый тип данных

1. Что такое перечислимый тип данных в языке C++ и для чего он используется?
2. Как объявляется перечислимый тип данных в языке C++?
3. Чем отличается перечислимый тип данных от обычных целочисленных типов данных в языке C++?
4. Какие значения могут принимать элементы перечислимого типа данных в языке C++?
5. Каким образом можно указать базовый тип данных для перечисляющего типа данных в языке C++?
6. Что такое scoped enum в языке C++ и как он отличается от обычного перечислимого типа данных?
7. Как объявляется scoped enum в языке C++?
8. Как можно обратиться к элементу scoped enum в языке C++?
9. Что такое underlying type у scoped enum в языке C++ и как он используется?
10. Какие преимущества имеет использование scoped enum в языке C++ перед обычным перечислимым типом данных?

## Приведение типа

1. Что такое приведение типа (typecasting) в языке C++ и для чего оно нужно?
2. Что такое явное приведение типа (explicit typecasting) и каким оператором оно осуществляется в языке C++?
3. Что такое неявное приведение типа (implicit typecasting) и как оно происходит в языке C++?
4. Приведите пример неявного приведение типа в языке C++?
5. Приведение типа в стиле языка C.
6. Почему использование явного преобразования в стиле C может быть опасным?
7. Для чего предназначен `static_cast` и какие типы преобразований он поддерживает?
8. Какой тип будет у результата выражения `1U - 1L` при разных размерах типов?
9. Для чего используется `const_cast` и какие риски связаны с его применением?
10. В каких сценариях используется `reinterpret_cast`?
11. Почему `reinterpret_cast` считается менее безопасным по сравнению с другими операторами?
12. Приведите пример корректного использования `reinterpret_cast` для работы с памятью.
13. Какой оператор преобразования можно использовать для преобразования указателя `void*` в указатель на конкретный тип?
14. Какие гарантии безопасности исключений предоставляют операторы `static_cast`, `const_cast` и `reinterpret_cast`?
15. Какие типы преобразований поддерживает `dynamic_cast` и в каких сценариях он используется?

## Управление ходом выполнения программы

1. Что делает точка с запятой в конце выражения в C++?  
2. Как объединить несколько инструкций в одну составную инструкцию?  
3. Что происходит с переменными, объявленными внутри блока при его завершении? 
4. Оператор if. Конструкция else if.
5. Почему рекомендуется использовать фигурные скобки даже для однолинейных `if`/`else`? 
6. `if constexpr`. Для чего используется? Какие ограничения?
7. Как исправить ошибку в коде:

    ```cpp
    if (n > 0)
        if (a > b)
            z = a;
    else
        z = b;
    ```  

8. Оператор цикла `for`. Цикл `for` со счётчиком. Синтаксис.
9. Range-based `for`. Что нужно сделать, чтобы элементы контейнера можно было перебирать, используя range-based `for`?
10. Что происходит, если условие в `for` отсутствует?
11. Оператор цикла `while`.
12. Оператор цикла `do-while`.
13. В чём разница между `while` и `do-while`? Приведите пример.
14. Досрочный выход из цикла и пропуск итерации цикла.
15. Какой оператор лучше использовать для цикла, который должен выполниться как минимум один раз?  
16. Как, находясь во внутреннем цикле, выйти из внешнего?
17. Что делает оператор `break` внутри цикла?
18. Что делает оператор `continue` внутри цикла?
19. Для каких типов данных используется `switch`?  
20. Что делает `default` в операторе `switch`?
21. Что такое "сквозное" выполнение ветвей `case`?
22. Для чего применяется атрибут `[[fallthrough]]`?
23. Какие типы данных поддерживаются `range-based for`?
24. Почему использование `goto` считается плохой практикой?
25. Приведите пример ошибки, связанной с отсутствием фигурных скобок в `if

## Функции

1. Для чего используются функции?
2. Какой оператор используется для возврата значения из функции?
3. Может ли функция не возвращать значение? Если да, как это указывается? 
4. Какой синтаксис используется для объявления функции? 
5. В чём разница между объявлением и определением функции?
6. Почему объявление функции должно быть выполнено до её вызова?
7. Какой способ передачи параметров используется по умолчанию в C++?
8. Что происходит с параметром, переданным по значению, внутри функции?
9. В чём разница между передачей по значению и по ссылке?
10. Как указать значения по умолчанию для аргументов функции?
11. Когда рекомендуется использовать константную ссылку в качестве параметра?
12. Может ли функция возвращать несколько значений? Если да, как это реализуется?
13. Какой тип параметра следует использовать для простых типов (например, `int`): по значению или по ссылке?
14. Какой тип параметра следует использовать, если функция не изменяет объект, но он тяжёлый (например, `std::vector`)?
15. Что такое "выходной аргумент" и как он используется? 
16. В каких случаях передача по ссылке предпочтительнее?
17. Лямбда функции.
18. Захват параметров лямбда функции по значению и по ссылке. Чем отличаются?
19. Можно ли изменить значение переменной, захваченной в лямбде по значению?
20. Какой код компилятор сгенерирует на основе лямбда-функции с пустым списком захвата? А если список параметров будет непустым?

## Структуры

1. Что такое структура в C++ и в чём её преимущества по сравнению с отдельными переменными?
2. Как объявить структуру?
3. Какие типы данных могут использоваться в полях структуры?
4. Что такое член структуры и как им можно управлять?
5. Как инициализировать структуру при её объявлении?
6. Какой синтаксис используется для доступа к полям структуры?
7. Как инициализировать структуру с вложенными структурами?
8. Как передать структуру в функцию в C++, и какие способы можно использовать для передачи структуры?
9. В чём разница между передачей структуры по значению и по ссылке?
10. Что происходит с полями глобальных структур при их объявлении?
11. Что выведет программа, если поле `std::string` структуры не инициализировано?
12. Как можно сравнить две структуры на равенство?
13. Когда предпочтительнее использовать структуры вместо классов?
14. Как порядок полей в стуктуре влияет на её размер? С чем это связано?
15. Указатель на структуру, как обратиться к полю структуры по указателю?
16. Массивы структур.
17. Размещение полей структур в памяти.

## Массивы

1. Что такое массив в C++ и каковы его основные характеристики?
2. Как объявить массив в C++?
3. Что такое индекс массива? Каковы требования к типу индекса для массива?
4. Как получить доступ к элементу массива по индексу?
5. Как инициализировать массив при его объявлении? Приведите пример.
6. Что происходит с элементами массива, не указанными при инициализации?
7. Какой синтаксис используется для автоматического определения размера массива?
8. Как узнать размер массива?
9. Можно ли изменить размер массива после его создания?
10. Что происходит с массивом, переданным как параметр, в функции?
11. В чём разница между передачей массива в функцию напрямую и как элементом структуры?
12. Как заполнить массив значениями по умолчанию?
13. Как отсортировать элементы массива в порядке убывания?
14. Как связаны строковые литералы и массивы символов?
15. Что такое `std::array` и как он отличается от обычного массива?
16. Объявление многомерных массивов. Объявление многомерного массива с помощью `std::array`.
17. Как получить доступ к элементу многомерного массива? Приведите пример.

## Ссылки

1. Что такое ссылка в C++ и как она отличается от указателя?
2. Почему при объявлении ссылки необходимо сразу инициализировать её?
3. Что происходит при присваивании значения через ссылку?
4. Может ли ссылка быть неинициализированной? Почему?
5. Как ссылки могут использоваться для работы с элементами массива? Приведите пример.
6. В чём разница между обычной ссылкой и константной ссылкой?
7. Есть ли преимущество передачи параметров в функцию по ссылке вместо передачи по значению?
8. Передача параметров в функцию по значению, по ссылке, по константной ссылке.
9. Когда рекомендуется использовать константные ссылки в качестве параметров функций?
10. Что будет, если функция вернёт ссылку на переменную, объявленную внутри функции?
11. Особенности работы ссылок на временные объекты. Чему равно время жизни временного объекта, на который ссылается ссылка?
12. Как изменение исходной переменной влияет на константную ссылку на эту переменную?
13. Чему равно выражение `sizeof(ref)`, где ref — ссылка?
14. Как хранятся ссылки внутри классов и структур? Чему равен размер структуры, содержащей ссылку?
15. Что на самом деле передаётся в функцию, принимающую аргумент по ссылке?

## Пространства имён

1. Что такое пространство имён в C++ и каковы его основные цели?
2. Как объявить пространство имён в C++?
3. Почему рекомендуется избегать `using namespace` в заголовочных файлах?
4. Можно ли использовать несколько пространств имён в одном файле?
5. Каким образом происходит разрешение конфликтов имен в разных пространствах имён?
6. Какие стандартные пространства имён существуют в C++?
7. Можно ли создавать свои собственные пространства имён?
8. Каким образом можно использовать элементы из других пространств имён?
9. Что такое алиасы (синонимы) пространства имён и как их объявлять?
10. Какой синтаксис используется при обращении к элементам вложенных пространств имён?
11. Что такое безымянное пространство имён и как оно используется?
12. В чём отличие видимости идентификаторов в безымянном пространстве от обычного?
13. Как получить доступ к функции `Print`, объявленной в пространстве имён `graphics::shapes`?
14. Объясните, как работает ADL (Argument-Dependent Lookup). Приведите пример использования.
15. Как импортировать конкретный идентификатор из пространства имён без импорта всего пространства?
16. Как решить конфликт имен, если два пространства имён содержат функции с одинаковыми именами?
17. Какие проблемы могут возникнуть при использовании `using namespace` в крупных проектах?

## Модель памяти C++

1. Что такое объект с точки зрения модели памяти языка? Какими свойствами он обладает?
2. Что такое выравнивание? Для чего оно используется?
3. Чем размер объекта отличается от его выравнивания?
4. Выравнивание структур.
5. Как узнать размер объекта?
6. Как узнать выравнивание объекта?

## Указатели

1. Что такое указатель? Для чего применяются указатели?
2. Как объявить указатель на переменную определенного типа?
3. Как получить адрес переменной в памяти и сохранить его в указатель?
4. Как получить значение переменной по ее адресу, на который указывает указатель?
5. Как изменить значение переменной по ее адресу, на который указывает указатель?
6. Как проверить, равны ли два указателя?
7. Как проверить, является ли указатель нулевым?
8. Какие операции можно выполнять с указателями?
9. Какие ошибки могут возникнуть при работе с указателями?
10. В чем отличие ссылки от указателя?
11. Что такое указатель `void*`? Для чего применяется? Какие с ним возможны операции?
12. Чем отличаются указатели `T*`, `const T*`, `T* const` и `const T* const`?
13. Что такое адресная арифметика?
14. К каким указателям применимы операции адресной арифметики?
15. Как определить, сколько элементов находится между указателями `p` и `q`? 
16. Что такое выравнивание памяти? Как получить выравнивание некоторого типа?
17. Как объявить и использовать указатель на указатель? 
18. Как выравнивание влияет на расположение полей структуры в памяти?
19. Как выравнивание влияет на производительность?
20. Как константная ссылка отличается от указателя на константу?

## Статическое, автоматическое и динамическое размещение объектов в памяти

1. В чём различие между статическим, автоматическим и динамическим выделением памяти?  
2. Приведите пример статического выделения памяти.  
3. Как работает автоматическое выделение памяти в C++?  
4. В чём преимущество динамического выделения памяти?  
5. Какой срок жизни объекта при статическом выделении памяти?  
6. Каковы основные недостатки динамического выделения памяти?  
7. Почему динамическое выделение памяти требует больше накладных расходов?
8. Что такое стек вызовов и как он связан с автоматическим выделением памяти?  
9. Что такое куча (heap) и как она используется в C++? 
10. Как сконструировать одиночный объект в динамической памяти? Как его разрушить и освободить память?
11. Как сконструировать массив объектов в динамической памяти? Как его разрушить и освободить память?
12. Что произойдёт при использовании непарных версий `new`/`delete`?
13. Что такое размещающий `new` и как он используется? 
14. Как правильно выровнять память для размещающего `new`?  
15. Как правильно разрушить объект, ранее созданный размещающим оператором `new`?
16. Какие функции стандартной библиотеки позволяют создавать объекты в сыровой памяти? 
17. В чём разница между `std::uninitialized_copy` и `std::uninitialized_move`? 
18. Как работает `std::destroy_at` и зачем он нужен? 
19. Приведите пример использования `std::construct_at`.
20. Что такое утечка памяти и как её избежать? 

# Стандартная библиотека языка C++

## std::string и std::string_view

1. Что представляет собой класс std::string в C++?
2. Какие типы данных могут использоваться для хранения символов в std::string?
3. Перечислите основные преимущества использования std::string по сравнению с C-строками.
4. Опишите внутреннее устройство std::string в типичных реализациях?
5. Какова разница между `std::string` и `std::wstring`?
6. Какие операции можно выполнять над std::string?
7. Чем отличается размер от вместимости?
8. Что такое small string optimization?
9. Как изменяются значения size и capacity при использовании метода erase?
10. Какова сложность операций вставки и замены символов строки?
11. Класс `std::string_view`, чем отличается от `std::string`?
12. В каких случаях использовать `std::string_view`, а в каких `std::string`?
13. Чем отличается substr в `std::string` и `std::string_view`?
14. Как найти все вхождения некоторой подстроки в строке?
15. Какой метод позволяет объединить две строки в C++?
16. Как **быстро** найти все вхождения некоторой подстроки в строке?
17. Какие операторы сравнения доступны для объектов `std::string`?
18. Как преобразовать `std::string` в числовой тип данных и обратно?
19. Как можно ускорить работу со строками в C++?
20. Какой результат будет у `string_view` после разрушения оригинальной строки?

## std::vector и std::array

1. Что такое `std::array` и как он отличается от C-массива?
2. Можно ли передавать std::array по значению в функцию?
3. Опишите трехмерный массив при помощи `std::array`.
4. Что такое `std::vector`? Чем отличается от простого массива и `std::array`?
5. Описать внутреннее устройство `std::vector`. Желательно показать на схеме.
6. Что произойдёт с полностью заполненным `vector`, если выполнить операцию `push_back`?
7. Типичные операции над `std::vector`. Какая сложность этих операций?
8. Приёмы оптимизации производительности при работе с `std::vector`.
9. Метод `at` и операция `[]`. В каких случаях какую из этих операций следует использовать?
10. Как обойти все элементы `std::vector` в прямом и обратном направлении?
11. Как `std::vector` хранит элементы в памяти: последовательно или с промежутками?
12. Чем размер вектора отличается от его вместимости?
13. Что такое инвалидация итераторов? Какие операции над `std::vector` приводят к инвалидации его итераторов?
14. Что происходит с вектором при вызове `push_back`, если текущий размер равен ёмкости?
15. Чем отличаются `emplace`-методы от `push`/`insert`?
16. Идиома `erase`/`remove`.
17. Как развернуть содержимое `std::vector` за O(1) памяти и O(N) времени?
18. Как получить  указатель на первый элемент вектора?
19. Какова амортизированная сложность операции `push_back`? Что такое амортизированная сложность?
20. Как вставить в вектор элементы из другого контейнера, например из `deque` (в конец, в начало, в середину).
    Какова сложность этих операций?
21. Для чего служит метод `shrink_to_fit()` и когда его стоит применять?
22. Приведите пример использования обратных итераторов у вектора.
23. Что происходит с данными в векторе при вызове `clear()`?
24. Что происходит с итератором `end()`, если размер вектора изменяется?
25. Может ли `std::vector` содержать объекты, для которых не определен оператор присваивания?
26. Может ли `std::vector` содержать объекты, у которых отсутствует конструктор по умолчанию?
27. Для чего нужен метод `reserve`?
28. В каких случаях предпочтительнее использовать `std::vector`, а в каких — `std::list`?
29. Какие ограничения у `std::vector` по сравнению с `std::deque`?
30. Какой контейнер обеспечивает более быстрое вставку/удаление в середине: `std::vector` или `std::list`?

## std::deque

1. Контейнер `std::deque`. Чем отличается от std::vector, в каких случаях применять vector, а в каких deque?
2. Какой заголовочный файл необходимо подключить для работы с `std::deque`?
3. Как устроен контейнер std::deque внутри? Нарисуйте схему и объясните её работу.
   Какие структуры данных используют типичные реализации этого контейнера?
4. Почему размер блоков и количество блоков в `std::deque` обычно являются степенями двойки?  
5. Какие операции над `std::deque` приводят, а какие не приводят к инвалидации итераторов? Объясните, с чем это связано?
6. Для чего типичные реализации deque используют "закольцованность" блоков? 
7. Основные операции над `std::deque` и их сложность.
8. Чем отличаются emplace-методы от `push`/`insert`
9. Отличия `std::deque` от `std::list`. Когда лучше применять `deque`, а когда `list`?
10. Какие операции над std::deque приводят к инвалидации ссылок?
11. Как развернуть std::deque?
12. За счёт чего в `std::deque` обеспечивается доступ к элементам по индексу за O(1)?
13. Как вставить в deque элементы из другого контейнера (в начало, в конец, в середину)?
14. Какой метод `std::deque` позволяет безопасно получить элемент по индексу с проверкой границ?
15. Почему в `std::deque` нет метода `data`, в отличие от `std::vector`?
16. Какой получить ссылку на последний элемент `std::deque`?
17. Какой из контейнеров более компактно хранит элементы в памяти: `std::deque` или `std::list`? Почему?
18. Последовательная итерация по элементам какого из перечисленных контейнеров будет более быстрой:
    `deque`, `vector`, `list`?
19. Как `std::deque` обрабатывает ситуацию, когда блоки заполнены?
20. Сравните скорость вставки элементов в начало и в конец `std::deque` и `std::vector`.
21. Сравните время доступа к элементу по его индексу в случае с `std::deque` и `std::vector`.
22. В каких случаях `std::deque` предпочтительнее `std::vector`?
23. Какие ограничения у `std::deque` по сравнению с `std::list`? 
24. Какой контейнер обеспечивает более быстрое вставку/удаление в середине: `std::deque` или `std::list`?

## std::list и std::forward_list

1. Контейнер `std::list` и `std::forward_list`, чем отличаются? Когда использовать `list`, а когда `forward_list`?
2. Какие операции поддерживает `std::list`, а какие `std::forward_list`?
3. Какие операции над `list` и `forward_list` приводят к инвалидации ссылок и итераторов, а какие нет? Почему?
4. Как развернуть `std::forward_list`? Какова сложность этой операции по памяти и по времени?
5. Как отсортировать `std::list`? Какова сложность этой операции?
6. Какова временная сложность вставки элемента в произвольную позицию `std::list`?
7. Как перенести элементы из одного списка в другой? Какова сложность этих операций?
8. Как удалить элементы std::list, удовлетворяющие заданному критерию?
9. Как удалить из std::list подряд идущие дубликаты? `[1, 3, 2, 2, -8, 5, 1, 1, 1, 2]` -> `[1, 3, 2, -8, 5, 1, 2]`
10. Как перенести элементы из одного `forward_list` в другой. Какова сложность этих операций?
11. Как отсортировать всё содержимое `forward_list`?
12. Как отсортировать диапазон элементов `std::list` и `std::forward_list`?
13. Как вставить в `std::list` диапазон элементов из другого контейнера?
14. Какие операции можно выполнять над итераторами двусвязного списка?
15. В каких случаях предпочтительнее использовать `std::list` вместо `std::vector`?
16. Какой контейнер обеспечивает более быстрый доступ к элементу по индексу: `std::list` или `std::vector`?
17. Каким образом можно вставить элементы двусвязного списка в другой контейнер в обратном порядке?
18. Почему `std::forward_list` не имеет метода `push_back`?
19. Как удалить из `std::forward_list` элемент, следующий за некоторым элементом?
20. Как узнать количество элементов в `std::forward_list`?
21. В каких случаях `std::forward_list` предпочтительнее `std::list`?

## Контейнеры map и multimap

1. Контейнер std::map. Для чего используется?
2. Операции над `map`. Какова сложность этих операций?
3. В каком порядке находятся элементы `std::map`? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве ключей `map` использоваться пользовательские типы данных? Что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве значений?
6. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.emplace(key, value)`?
7. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.at(key) = value`?
8. Напишите функцию `optional<string> TryGetValue(const map<int, string>& m, int key)`
9. Как можно ускорить вставку в `map`?
10. Что происходит при использовании оператора `[]` для элемента, который ещё не существует в `std::map`?
11. Как быстро перенести элемент из одного контейнера `map` в другой `map` того же типа?
12. Как получить все значения `multimap` с заданным ключом?
13. Что возвращает метод `insert` для `std::map` и как он отличается от `std::multimap`?
14. В чём разница между `lower_bound` и `upper_bound`?
15. Как реализовать пользовательскую функцию сравнения для `std::map`? 
16. Какова временная сложность вставки, поиска и удаления в `std::map`?
17. В каких случаях использовать `map`, а в каких `unordered_map`?
18. Что происходит с итераторами при вставке нового элемента?
19. Когда стоит использовать `std::multimap` вместо `std::map`?
20. В чем различие между доступом к элементам с помощью метода `at` и операцией `[]`?
21. Чем отличается `emplace` от `try_emplace`?
22. Что происходит, если использовать `std::map` с ключами, не поддерживающими оператор `<`?
23. В каком порядке возможен обход элементов контейнера map?
24. Как удалить из контейнера map все элементы, удовлетворяющие заданному критерию?
25. Как удалить из контейнера map не более N элементов, удовлетворяющих заданному критерию?

## Контейнеры unordered_map и unordered_multimap

1. Контейнер `unordered_map`. Для чего используется?
2. Операции над `unordered_map`. Их сложность.
3. Что означает "амортизированная константа" применительно к сложности операций?
4. В каком порядке хранятся элементы внутри `unordered_map`? Можно ли изменить порядок этих элементов?
5. Как можно ускорить вставку в `unordered_map`?
6. Чем отличается вставка элементов c помощью `umap[key] = value` от вставки `umap.emplace(key, value)`?
7. Чем отличается вставка элементов c помощью `umap[key] = value` от вставки `umap.at(key) = value`?
8. Напишите функцию `optional<string> TryGetValue(const unordered_map<int, string>& m, int key)`.
9. Какие требования предъявляются к ключам для `std::unordered_map`?
10. Что нужно сделать, чтобы в качестве ключей `unordered_map` использовать пользовательские типы данных?
11. Что возвращает метод `insert` для `std::unordered_map` и как он отличается от `std::unordered_multimap`?
12. В чём преимущество `std::unordered_map` перед `std::map`?
13. Что такое хеш-функция? Как она используется в `unordered_map`?
14. Как быстро перенести элемент из одного `unordered_map` в другой того же типа
15. Что такое bucket-ы в `unordered_map`? Как они влияют на производительность?
16. Что такое rehashing? Когда он возникает? Как можно им управлять?
17. Приведите пример хешера для структуры с несколькими полями.
18. Контейнер `unordered_multimap`. Чем отличается от `unordered_map`?
19. Как реализовать пользовательский компаратор для `std::unordered_map`?
20. Как получить все элементы `unordered_map` с одним и тем же ключом?
21. Что произойдёт, если пользовательский хешер не обеспечивает равномерное распределение?
22. В каком порядке возможен обход элементов `unordered_map`?
23. Когда использовать map, а когда `unordered_map`?
24. Как удалить из `unordered_map` не более N элементов, удовлетворяющих заданному критерию?

## Контейнеры set и multiset

1. Контейнер std::set. Для чего используется?
2. Операции над set. Какова сложность этих операций?
3. В каком порядке находятся элементы std::set? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве элементов set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов set?
6. Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
7. Как быстро перенести один элемент из одного контейнера set в другой того же типа?
8. Когда использовать set, а когда unordered_set?
9. Как можно ускорить вставку в set?
10. Как скопировать элементы из vector в set? Как скопировать элементы из set в vector?
11. Контейнер multiset. Как получить все значения контейнера multiset с заданным ключом?
12. Чем отличается insert от emplace?
13. Как удалить из set все элементы, удовлетворяющие заданному критерию?
    Как удалить из set не более N элементов, удовлетворяющих заданному критерию?

## Контейнеры unordered_set и unordered_multiset

1. Контейнер std::unordered_set. Для чего используется?
2. Операции над unordered_set. Какова сложность этих операций?
3. В каком порядке находятся элементы std::unordered_set? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве элементов unordered_set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов unordered_set?
6. Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
7. Как быстро перенести один элемент из одного контейнера unordered_set в другой того же типа?
8. Когда использовать set, а когда unordered_set?
9. Как скопировать элементы из vector в unordered_set? Как скопировать элементы из unordered_set в vector?
10. Контейнер unordered_multiset. Как получить все значения контейнера unordered_multiset с заданным ключом?
11. Как удалить из unordered_set все элементы, удовлетворяющие заданному критерию?
    Как удалить из unordered_set не более N элементов, удовлетворяющих заданному критерию?
12. Что такое хеш-функция? Как она используется в unordered_set?
13. Что такое bucket-ы в unordered_set? Как они влияют на производительность?
14. Что такое rehashing? Когда он возникает? Как можно им управлять?

## std::function и лямбда-функции

1. Что такое `std::function` и каковы его основные цели?
2. Какие типы объектов может оборачивать `std::function`?
3. В чём разница между `std::function` и указателем на функцию?
4. Объявите указатель на функцию, которая принимает аргументы типа float и double и возвращает целое число.
5. Что такое лямбда-функция и каков её синтаксис?
6. Как захватить переменные из окружающего контекста в лямбда-функции?
7. В чём разница между захватом по значению и по ссылке? Приведите примеры.  
8. Можно ли изменить захваченные по значению переменные внутри лямбды?
9. Что произойдёт, если захватить переменную по ссылке, которая вышла из области видимости? Приведите пример.
10. Как захватить все переменные по значению, кроме одной по ссылке?
11. Можно ли использовать `this` в лямбда-функции внутри класса?
12. Приведите пример использования `std::function` для передачи функции-обработчика в другую функцию.
13. Как использовать `std::bind` для создания функционального объекта с параметрами?
14. Как избежать утечки памяти при использовании `std::function` с динамически выделенными объектами?
15. Можно ли использовать `std::function` для привязки к методам класса?

## Ввод-вывод

1. Как перенаправить вывод `std::cout` в файл при запуске программы?  
2. Назовите три основных стандартных потока ввода-вывода в C++.
3. Как проверить, успешно ли завершилась операция ввода?
4. Какие флаги существуют у потоков ввода-вывода?
5. Как вернуть поток в нормальное состояние после обнаружения ошибки?
6. Как настроить потоки ввода-вывода, чтобы в случае ошибки выбрасывалось исключение?
7. Как можно настроить поток ввода-вывода для ввода-вывода значений в другой системе счисления?
8. Что происходит с `std::cin`, если ввести строку вместо числа?
9. Как выровнять текст по правому краю с помощью манипуляторов?
10. Как установить точность вывода чисел с плавающей точкой?
11. В чём разница между режимами `std::ios_base::out` и `std::ios_base::app`?
12. Как проверить, успешно ли открыт файл?
13. Что происходит с содержимым файла при открытии в режиме `std::ios_base::trunc`?
14. В чём разница между текстовым и двоичным режимами работы с файлами?
15. Для чего используется `std::istringstream`?
16. Как извлечь строку из `std::istringstream`?
17. Как получить содержимое `std::ostringstream` в виде строки?
18. Как убедиться, что данные, выведенные в поток были успешно сброшены на устройство?

## Итераторы

1. Что такое итератор и для чего он используется?
2. Какие основные категории итераторов вы знаете? Охарактеризуйте каждую.
3. В чём разница между `LegacyInputIterator` и `LegacyOutputIterator`? 
4. Что означает категория `LegacyContiguousIterator`? Чем отличается от `LegacyRandomAccessIterator`?
5. Какой итератор позволяет многократный проход по контейнеру?
6. Как получить итераторы для обратного прохода по C-массиву?
7. Как получить итератор на начало и конец контейнера?  
8. В чём преимущество `LegacyForwardIterator` перед `LegacyInputIterator`?
9. Как компилятор разворачивает синтаксис `for (auto x : container)`?
10. Как использовать `init-statement` в `range-based for` (начиная с C++20)?
11. Чем отличаются категории итераторов, используемых в
    `std::map`, `std::unordered_map`, `std::forward_list`, `std::deque`, `std::vector`?
12. Что такое инвалидация итераторов и в каких случаях она происходит?
13. Как реализовать пользовательский итератор для собственного контейнера?
14. В чём разница между итератором и указателем?

## Стандартные алгоритмы

1. Как алгоритмы стандартной библиотеки взаимодействуют с контейнерами? 
2. Сортировка элементов. Простая и стабильная сортировка. Алгоритмы частичной сортировки.
3. Подсчёт элементов, удовлетворяющих заданному критерию.
4. Поиск минимума и максимума.
5. Нахождение медианы и процентилей.
6. Поиск элементов. Последовательный. Двоичный поиск. Алгоритмы быстрого поиска всех вхождений подстроки в строке.
7. Копирование и преобразование элементов.
8. Алгоритмы над отсортированными множествами элементов: пересечение, объединение, разность множеств.
9. Какой тип итераторов требуется для алгоритма `std::copy`?
10. Для чего применяются проекции в `std::ranges::sort`?
11. В чём разница между `std::any_of` и `std::all_of`?
12. В чём заключается идиома erase-remove?
13. Что происходит с элементами, которые "удаляются" при использовании `std::remove`?  
14. Как при помощи алгоритма `std::copy` вывести элементы контейнера в обратном порядке?
15. Как использовать `std::transform` для преобразования списка id пользователей в список пользователей?
16. Что означают возвращаемые значения `std::lower_bound` и `std::upper_bound`?
17. Как определить, сколько раз встречается элемент в отсортированном контейнере?
18. Как реализовать копирование только нечётных чисел в новый контейнер?
19. Как проверить, является ли массив отсортированным?
20. Как найти медианное значение в контейнере?

## std::optional

1. Для чего нужен класс `std::optional`?
2. Как узнать, содержит ли объект `std::optional` значение?
3. Как получить доступ к значению?
4. Каковы основные преимущества `std::optional` по сравнению с указателями или возвратом кодов ошибок?
5. Какие ошибки могут возникнуть при работе с классом `std::optional`?
6. Напишите функцию, которая складывает два значения типа `optional<int>` и возвращает пустое значение,
   если хотя бы одно из слагаемых пустое, либо сумму чисел, если оба аргумента непустые.
7. Как проверить, содержит ли `std::optional` значение?
8. Что происходит при вызове `value()` для пустого `std::optional`?
9. Что делает метод `emplace`? Приведите пример его использования.
10. Что делает метод `value_or()`?
11. Как использовать `std::optional` для возврата результата поиска в контейнере?
12. Как реализовать отложенную инициализацию поля класса с помощью `std::optional`?
13. Что происходит с `std::optional` при его присваивании другому значению?

## Стандартные умные указатели

1. Что такое "use-after-free" и как умные указатели помогают избежать этой проблемы?
2. Что такое `std::unique_ptr` и когда его следует использовать?  
3. В чём разница между `std::unique_ptr` и `std::shared_ptr`? 
4. Что такое RAII и как он связан с умными указателями?  
5. Какой заголовочный файл содержит объявления `std::unique_ptr`, `std::shared_ptr` и `std::weak_ptr`? 
6. В каких случаях предпочтительнее использовать `std::make_unique` и `std::make_shared`
   по сравнению с вызовом `std::shared_ptr<Type>(new Type())`?
7. Как передать владение ресурсом из одного `std::unique_ptr` в другой?
8. Как использовать `std::unique_ptr` для управления массивом объектов?
9. Как создать в куче неинициализированный массив объектов и управлять им при помощи `std::unique_ptr`?
10. По какому принципу `std::shared_ptr` управляет временем жизни объекта?
11. Что такое "сильная" и "слабая" ссылка в контексте `std::shared_ptr`?
12. Как создать `std::shared_ptr` с пользовательским deleter-ом?
13. Какой узнать, содержит ли `std::shared_ptr` значение?
14. В чём назначение `std::weak_ptr` и какую проблему он решает?
15. Как получить `std::shared_ptr` из `std::weak_ptr`?
16. Что происходит с `std::weak_ptr`, если объект, на который он ссылается, был удалён?
17. Как проверить, существует ли объект, на который указывает `std::weak_ptr`? 
18. Приведите пример использования `std::weak_ptr`.
19. Зачем нужен класс `std::enable_shared_from_this`? Приведите пример его использования.
20. Что произойдёт, если вызвать `shared_from_this()` в конструкторе объекта?
21. В чём разница между `shared_from_this()` и `weak_from_this()`?
22. Как реализовать идиому Pimpl с использованием `std::unique_ptr`?
23. Приведите пример использования `std::unique_ptr` с пользовательским deleter-ом.
24. Какой оверхед несёт `std::shared_ptr` по сравнению с `std::unique_ptr`?
25. Какой подход выбрать для передачи умного указателя в функцию: по значению или по ссылке?
26. Как преобразовать `std::shared_ptr<Derived>` к `std::shared_ptr<Base>` и обратно?
27. Как внутри метода объекта, которым владеет `shared_ptr`, получить `shared_ptr`, ссылающийся на этот же самый объект?
    Для чего это может понадобиться?
28. Как на основе `shared_ptr`, который владеет на объектом-агрегатом (например, структурой),
    получить `shared_ptr` на составную часть агрегата (например, поле структуры)?
    При этом объект-агрегат должен жить, пока жив либо указатель на часть, либо указатель на целое.

## std::filesystem

1. Что такое `std::filesystem` и в каком заголовочном файле она определена?
2. В чём разница между `std::filesystem::path` и обычной строкой для работы с путями?
3. Как получить текущий рабочий каталог с помощью `std::filesystem`?
4. Как объединить два пути в одном объекте `std::filesystem::path`?
5. Как получить родительский каталог пути?  
6. Как извлечь имя файла из полного пути?  
7. Как получить расширение файла из пути?
8. В чём разница между методами `string()` и `generic_string()`?
9. Как проверить, существует ли файл или каталог?
10. Как получить размер файла с помощью `std::filesystem`?
11. Как создать новую директорию с помощью `std::filesystem`?
12. Как скопировать файл из одного пути в другой?
13. Как удалить файл или пустую директорию? 
14. Как удалить директорию с содержимым? 
15. Как обойти все файлы в директории?
16. Как обойти рекурсивно все файлы в директории,
17. Как нормализовать путь для разных ОС?
18. Как проверить, является ли путь корневым?
19. Как получить из абсолютного пути получить путь относительно некоторой директории?
20. Как узнать, пусть указывает на файл или на директорию?

## std::variant

1. Для чего нужен класс `std::variant`?
2. Как проверить, содержит ли std::variant значение нужного типа или нет?
3. Может ли std::variant не содержать значение?
4. Как с помощью `std::visit` обработать все допустимые значения внутри `std::variant`?
5. Для чего нужен `std::monotype`? Приведите пример.
6. Реализуйте операцию `StringOrInt operator+(const StringOrInt& a, const StringOrInt& b)`,
   где тип `StringOrInt` — это `std::variant<std::string, int>`.
   Сложение должно происходить по правилам языка JavaScript:
   1. 10 + 20 => 30
   2. 10 + "20" => "1020"
   3. "10" + 20 = "1020"
   4. "10" + "20" = "1020"

# Объектно-ориентированное программирование

## Общие сведения об объектно-ориентированном программировании

1. Что такое объектно-ориентированное программирование (ООП) и какие основные принципы его составляют?  
2. В чём разница между процедурным и объектно-ориентированным программированием? 
3. Что такое абстракция данных и как она помогает в проектировании программ?
4. Что такое инкапсуляция и как она реализуется в C++?
5. Как инкапсуляция упрощает разработку программ?
6. Что такое инварианты классы и как инкапсуляция способствует их сохранению?
7. Что такое наследование и для чего оно используется?
8. Что такое иерархия классов?
9. Что такое полиморфизм и как он реализуется в C++?
10. В чём разница между статическим и динамическим полиморфизмом?
11. Что такое абстрактный класс и как он используется в C++?
12. В чём разница между абстрактным классом и интерфейсом?
13. Как абстракция помогает в проектировании сложных систем?
14. В чём разница между композицией и наследованием? Приведите пример, где композиция предпочтительнее.

## Классы, данные и методы - 1

1. Что такое класс в C++ и как он отличается от структуры?  
2. Из чего формируется состояние экземпляра класса?
3. Что такое инкапсуляция и как она реализуется?
4. Почему прямой доступ к полям класса через `public` считается плохой практикой? 
5. Что такое методы? Чем он отличается от обычной функции?
6. Как объявить метод класса внутри и вне тела класса?
7. Какие методы не могут быть вызваны у `const`-объекта?
8. Что такое константный методы и для чего они используются? 
9. В чём разница между физической и логической константностью?
10. Что нужно сделать, если требуется изменить значение поля класса внутри константных методов?
    Для чего этj можно использовать?
11. Как разделяется реализация класса между заголовочным и cpp-файлом?
12. Каким образом код внутри метода класса знает, у какого экземпляра класса он вызван?
13. В каких случаях в C++ обязательно использовать `this->`?

## Классы, данные и методы - 2

1. Что такое свойства и как они реализуются в C++?
2. Какой недостаток может быть у свойства, которое возвращает значение с побочными эффектами?
3. Какие спецификаторы уровня доступа есть в C++, в чем разница между ними?
4. Что такое статический метод класса и как он объявляется?  
5. В чём разница между статическим и нестатическим методом? 
6. Приведите пример вызова статического метода извне класса.
7. Что такое статическое поле и как оно отличается от обычного поля? 
8. Приведите примеры использования статических полей и методов.
9. Почему статические поля часто объявляются как `const`?
10. Объясните назначение ключевого слова `friend` в C++. Какие формы дружественности поддерживает язык и чем они различаются?
11. Чем дружественная функция внутри класса отличается от обычного публичного метода этого класса?
12. В каких случаях использование дружественной функции вместо метода-члена улучшает архитектуру?
    Приведите пример, где метод-член был бы менее уместен.
13. Раскройте, как `friend` взаимодействует с понятием ADL (Argument-Dependent Lookup)
  при перегрузке операторов, например, `operator==`.
  Почему дружественная функция-оператор часто объявляется внутри класса?

## Жизненный цикл объекта

1. Что такое конструктор и для чего он используется?
2. В чём разница между конструктором и обычным методом класса? 
3. Что такое деструктор и когда он вызывается?
4. Какой синтаксис используется для объявления деструктора?
5. Что такое конструктор по умолчанию?
6. Как явно объявить конструктор по умолчанию в C++? 
7. В каких случаях компилятор автоматически генерирует конструктор по умолчанию?
8. В чём заключается проблема инициализации полей класса без конструктора по умолчанию?
9. Как вызвать конструктор с параметрами при создании объекта?
10. В чём разница между присвоением значений в теле конструктора и инициализацией в списке инициализации?
11. В каких случаях использование списка инициализации является обязательным?
12. Что такое конвертирующий конструктор?
13. В чём опасность неявного преобразования с помощью конвертирующего конструктора?
14. Для чего применяется explicit-конструктор? Когда следует делать конструктор explicit?
15. В каком порядке вызываются конструкторы базового и производного класса?
16. В каком порядке вызываются деструкторы полей класса?
17. Как порядок объявления полей влияет на их инициализацию и разрушение?
18. Что такое делегирующий конструктор и в чём его назначение?
19. В чём разница между обычным конструктором и делегирующим?
20. Почему нельзя указывать поля в списке инициализации делегирующего конструктора?
21. Какой конструктор выполняется первым — делегирующий или целевой?

## Копирование, присваивание и перемещение объектов

1. Что такое копирующий конструктор и как он объявляется?  
2. В чём разница между копирующим конструктором и обычным конструктором?  
3. Какой синтаксис используется для объявления копирующего конструктора?  
4. Что такое оператор присваивания и когда он вызывается?  
5. Какой тип ссылок используется для параметра копирующего конструктора?
6. В каких случаях компилятор автоматически генерирует копирующий конструктор?  
7. Что происходит, если класс содержит поле, не имеющее копирующего конструктора?
8. Когда автоматически сгенерированный копирующий конструктор не подходит?
9. Какая семантика у оператора присваивания?
10. Как запретить копирование и присваивание экземпляров класса?
11. Для чего применяется идиома copy and swap?
12. В чём заключается проблема "самоприсвоения" и как её избежать?
13. Чем копирование отличается от перемещения?
14. В каком случае перемещение может быть более оптимальным, чем копирование?
15. Что такое rvalue-ссылка и как она объявляется?
16. В чём разница между копирующим и перемещающим конструктором?
17. Как объявляется перемещающий конструктор?
18. Что делает функция std::exchange? Чем std::exchange отличается от std::swap?
19. В каком состоянии должен остаться объект после перемещения значения?
20. Приведите пример класса, где копирование невозможно, но перемещение полезно.

## Отношения между классами

1. Объясните разницу между **ассоциацией**, **агрегацией**, **композицией** и **зависимостью**;
   приведите по одному примеру каждого отношения.
2. Как композиция, агрегация, зависимость и ассоциация обозначаются на диаграммах классов.
3. В каких случаях ассоциация бывает двусторонней, а в каких — односторонней? Как это отражается в коде и на диаграмме?
4. Сравните ответственность Целого в композиции и агрегации: что происходит с Частью при уничтожении Целого в каждом случае?
5. Какие преимущества даёт предварительная визуализация архитектуры программы на диаграмме классов?
   Опишите минимум три сценария, когда это особенно полезно.
6. Почему принцип «информация скрыта» особенно важен при композиции?
   Опишите потенциальные ошибки проектирования, если Целое отдаёт наружу ссылки на свои Части.
7. Опишите процесс эволюции связей: как можно безопасно заменить агрегацию компози­цией,
   если Целое решило единолично владеть Частью? Какие изменения потребуются в коде?
8. Почему композиция считается более "сильной" связью, чем агрегация?
9. Предложите критерии, по которым вы определяете, какой вид отношения использовать при проектировании новой пары классов.
10. Почему зависимость считается «самой слабой» связью? Как эта слабость отражается на гибкости и расширяемости системы?
11. Что такое «делегирование» в контексте отношений между классами?
    Чем оно отличается от простого вызова метода ассоциированного объекта клиентом?
12. Опишите потенциальные проблемы, когда одна из сторон ассоциации хранит
    «сырые» указатели на другую сторону вместо умных указателей.
13. Приведите пример, когда агрегация логически превращается в зависимость во время рефакто­ринга.
    Какие изменения в коде это отражают?

## Наследование - 1

1. Дайте определение отношения «является» («is-a») и приведите пример его реализации на C++.
2. Объясните различие между отношениями «is-a» и «has-a». Приведите по одному примеру кода.
3. Что такое класс-родитель, класс-потомок и базовый класс?
4. В чём смысл понятия *иерархия наследования* и как она обычно изображается на UML-диаграммах?
5. Перечислите преимущества кода, достигаемые с помощью наследования. Назовите минимум два недостатка.
6. Что хранит таблица виртуальных функций (v-table) и как она используется при динамическом полиморфизме?
7. Приведите пример, когда метод базового класса **не** должен быть виртуальным, и обоснуйте решение.
8. Почему компилятор вызывает конструктор базового класса **перед** конструктором производного?
9. Как вызвать параметризованный конструктор базового класса из конструктора наследника?
10. Что нужно сделать в конструкторе класса-наследника, если в классе-родителе нет конструктора по умолчанию?
11. Чем отличается *переопределение* (override) виртуального метода от *скрытия* (method hiding)?
12. В каких случаях композиция предпочтительнее наследования?
13. Как спецификатор `override` помогает выявить несоответствие сигнатур?
14. Что произойдёт, если пометить метод как `virtual`, но забыть `override` в наследнике?
15. Вызов конструкторов и деструкторов при наследовании.

## Наследование - 2

1. Каковы особенности публичного, приватного и защищённого наследования? Когда их следует применять?
2. К каким полям и методам класса может иметь доступ класс-наследник?
3. В каком случае возможно приведение типа вверх по иерархии классов.
    Как влияет тип наследования на приведение типа по иерархии наследования?
4. Что произойдёт, если в классе-наследнике будет объявлен метод с тем же именем, что в одном из его родителей?
5. Как класс-наследник может вызвать одноименный метод своего родителя?
6. Чем отличается  `class X final { /*...*/ };` от `class X { /*...*/ };`. Когда следует объявлять класс или структуру финальной?
7. Как в функцию `void F(Base&)` передать ссылку на объект класса `class Derived : private Base {...};`?
8. Что произойдёт, если класс-наследник попытается получить доступ к `protected`-члену через объект **другого** наследника?
9. Может ли интерфейс (класс с чисто виртуальными методами) содержать `protected`-методы? Приведите аргументы «за» и «против».
10. Когда оправдано использование `protected`-деструктора?
11. Как сделать так, чтобы `protected`-члены базового класса в итоге стали **приватными** в производном?
12. Приведите два преимущества и два недостатка размещения полей в `protected` вместо `private`.
13. Как класс может запретить своим наследникам переопределя некоторые из его виртуальных методов?
14. Изобразите на UML диаграмме класс с одним `public`, одним `protected` и одним `private` методом.
15. Существует мнение, что «раннее закрытие» иерархии `final`-классами снижает тестируемость и расширяемость кода.
    Приведите аргументы «за» и «против» с точки зрения (а) модульного тестирования, (б) библиотечного API.

## Наследование и жизненный цикл объектов

1. В каких случаях деструктор вызывается автоматически, а в каких – явно программистом?
2. Объясните, почему деструктор базового класса, от которого наследуются полиморфные типы, чаще всего объявляется виртуальным.
3. Что такое тривиальный деструктор? Перечислите условия, при которых компилятор сгенерирует именно такой деструктор.
4. Напишите пример кода, в котором отсутствие виртуального деструктора в базовом классе приводит к проблемам.
5. Приведите пример архитектуры, где **публичный невиртуальный** деструктор базового класса является корректным решением
   и не вызывает рисков.
6. Расскажите, как использование `std::unique_ptr<Base>` влияет на требования к деструктору `Base`.
7. Чем различаются `delete` и «уничтожение» объекта при выходе из области видимости?
   Прокомментируйте в контексте деструкторов и наследования.
8. Опишите правила наследования виртуальности деструктора:
   как объявление виртуального деструктора в базе отражается на всех производных классах?
9. Объясните назначение **защищённого невиртуального** деструктора.
    Как он препятствует неправильному использованию базового класса?
10. В чём отличие вызова `delete this;` внутри метода класса с виртуальным деструктором и без него? Распишите возможные ошибки.
11. Сформулируйте «правило пяти» и объясните,
    как виртуальные деструкторы влияют на необходимость явно объявлять другие специальные функции.
12. Приведите пример класса, для которого **конструктор** сделан `protected`, а деструктор — `public virtual`.
    Объясните дизайн-решение.
13. Какие проблемы могут возникнуть при наследовании от сторонней библиотеки,
    если базовый класс не имеет виртуального деструктора? Предложите стратегию обхода.
14. Напишите юнит-тест (на любом тестовом фреймворке C++) для проверки корректного разрушения коллекции
    `std::vector<std::unique_ptr<Shape>>`, содержащей разные фигуры.
15. Опишите влияние виртуального деструктора на размер объекта и layout памяти. Какие поля добавляются компилятором?
16. Предложите способ запретить удаление объекта через указатель на базовый класс без отказа от полиморфного интерфейса.
17. Каковы особенности работы виртуальных методов во время работы конструктора и деструктора?
18. Предположим, что библиотека распространяет базовый класс `Widget`, методы которого не помечены `final`.
    Опишите процесс миграции на новую версию библиотеки, в которой те же методы объявлены `final`.
    Какие потенциальные проблемы ожидают разработчика пользовательского кода и как их минимизировать?
19. Укажите четыре сценария, при которых необходимо явно определять деструктор производного класса даже тогда,
    когда базовый имеет виртуальный деструктор по умолчанию.

## Виды наследования

1. Сформулируйте различия между публичным, защищённым и приватным наследованием
   с точки зрения доступа к членам базового класса.
2. Объясните, почему публичное наследование называют «наследованием интерфейса»,
   и приведите пример корректного применения этого принципа.
3. Назовите признаки, по которым можно определить, что выбранное публичное наследование применено некорректно.
4. Охарактеризуйте основное семантическое отличие композиции от приватного наследования при повторном использовании кода.
5. Почему класс-наследник, полученный через приватное наследование, не является подтипом своего базового класса?
6. Почему почти все пользовательские классы-исключения наследуются от `std::exception` именно публично?
   Объясните, какие проблемы возникнут, если заменить это наследование на защищённое или приватное,
   и как это отразится на механизме перехвата исключений.
7. Проанализируйте следующие фрагменты кода и объясните результат компиляции и/или выполнения:

    ```cpp
    class MyLibError : private std::exception {
    public:
        const char* what() const noexcept override { return "lib error"; }
    };

    void Foo() { throw MyLibError(); }

    int main() {
        try {
            Foo();
        } catch (const std::exception& e) {          // 1
            std::cout << e.what();
        } catch (const MyLibError& e) {              // 2
            std::cout << e.what();
        }
    }
    ```

8. Объясните, как закрытое наследование влияет на дружественные функции и классы.
9. Может ли класс, унаследованный защищённо, стать базовым публичным классом для своего наследника?
  Что это означает для внешнего кода?
10. Как динамическое приведение типа (`dynamic_cast`) ведёт себя при публичном и при непубличном наследовании.
11. Почему принято считать, что композиция часто предпочтительнее наследования?
12. Объясните, как ключевое слово `using` помогает «поднимать» скрытые члены базового класса при приватном наследовании.
13. Как protected-наследование влияет на возможность повторного использования защищённых методов базового класса
    в более глубоких иерархиях?

## Интерфейсы и абстрактные классы

1. Что такое **абстрактный класс** в C++ и какие условия заставляют компилятор считать класс абстрактным?
2. Объясните, почему экземпляры абстрактного класса нельзя создать напрямую, и опишите способы,
   которыми абстрактный класс всё-таки может участвовать в создании объектов.
3. Что такое **чисто виртуальная функция**? Сравните её с обычной виртуальной функцией и приведите пример,
   демонстрирующий различия в использовании.
4. Опишите назначение виртуального деструктора в абстрактном классе. Какие риски возникают, если деструктор объявлен невиртуальным?
5. Когда абстрактному классу имеет смысл предоставлять реализованные (нечистые) методы?
   Укажите, какие преимущества и какие потенциальные проблемы это создаёт.
6. В чём состоит принцип «программируй на уровне интерфейса, а не реализации»? Как абстрактные классы помогают его соблюдать?
7. Сравните **абстрактный класс** и **интерфейс** как крайний случай абстрактного класса.
8. Когда в C++ имеет смысл реализовывать интерфейс приватным или защищённым образом? Приведите примеры.
9. Приведите пример, когда имеет смысл в одном классе реализовывать несколько интерфейсов?
10. Опишите механизм, с помощью которого класс-реализация документирует своё соответствие интерфейсу.
    Какие инструменты языка служат для контроля этого соответствия.
11. Объясните, как интерфейсы помогают снизить связанность модулей и упростить написание модульных тестов.
12. Что произойдёт, если класс-наследник **не реализует** один из чисто виртуальных методов интерфейса?
13. Можно ли в интерфейсе объявить статические методы?
    Приведите пример и обсудите, насколько это соответствует идее интерфейса.
14. Поясните, как «интерфейс» в C++ отличается от такового в Java или C#.
    Какие возможности и ограничения добавляет отсутствие отдельного ключевого слова `interface`?

## Приведение типов по иерархии наследования

1. Объясните понятия **up-casting** и **down-casting** в контексте иерархии классов.
   В чём заключается принципиальная разница в их безопасности?
2. Почему приведение типа **вверх** по иерархии (от `Derived*` к `Base*`) компилятор выполняет неявно,
   тогда как приведение **вниз** требует явного указания?
3. Что такое "Срезка" и при каких формах приведения типов она проявляется?
4. В каких ситуациях использование `static_cast` для down-cast а безопасно, а в каких приводит к неопределённому поведению?
5. Почему базовый класс должен иметь хотя бы один виртуальный метод для корректной работы `dynamic_cast`?
6. Как ведёт себя `dynamic_cast` при приведении указателя?
7. Чем отличается поведение `dynamic_cast` при приведении ссылки?
8. Объясните, почему частое использование `dynamic_cast` может указывать на плохое проектирование системы классов.
9. Как можно уменьшить потребность в down-cast ах, сохранив расширяемость и открытость кода?
10. Что произойдёт, если выполнить `reinterpret_cast<Derived*>(&base)` вместо `dynamic_cast`? Разберите потенциальные риски.
11. Как изменение доступа (`public`, `protected`, `private`) при наследовании влияет на возможность неявного up-cast а?
12. Как выполнить безопасное приведение типа `std::shared_ptr<Base>` к `std::shared_ptr<Derived>`?
13. Почему в production-коде часто предпочитают проверку `if (auto d = dynamic_cast<Derived*>(ptr))`
    вместо безусловного приведения ссылки?
14. Вы разрабатываете плагин-систему, где функции принимают базовый интерфейс `IPlugin&`.
    Предложите архитектурное решение, позволяющее модулю определить, 
    поддерживает ли плагин дополнительный интерфейс `IRenderable`, минимизируя использование `dynamic_cast`.

## Множественное наследование

1. Что такое множественное наследование и какие практические задачи оно решает в отличие от одиночного наследования?
2. Чем различаются множественная реализация интерфейсов и множественное наследование реализаций? Приведите примеры.
3. В каком порядке вызываются конструкторы и деструкторы при создании объекта,
   наследующегося от двух базовых классов без виртуального наследования?
4. Почему при множественном наследовании часто рекомендуется явно переопределять методы,
   даже если классы-родители уже предоставляют собственные версии?
5. Приведите пример использования множественного наследования для одновременной реализации нескольких интерфейсов.
6. Как ключевое слово `override` помогает выявлять ошибки при множественном наследовании?
7. Объясните, почему множественное наследование усиливает *контракт* между базовыми и производными классами
   и как это может усложнить поддержку кода.
8. В чём разница между следующими объявлениями?

    ```cpp
    class D : public A, public B {};
    class D : public virtual A, public virtual B {};
    ```

9. Почему при виртуальном наследовании требуется явный вызов конструктора виртуальной базы на самом нижнем уровне иерархии?
10. Рассмотрите дочерний класс, который наследует `public A`, `private B`.
    Какие части интерфейса каждой базы становятся доступны извне?
11. Какие проблемы возможны при множественном наследовании? Какие у них существуют способы решения?

## Runtime-полиморфизм с std-variant

1. Что представляет собой шаблонный класс `std::variant`, и чем он принципиально отличается от традиционного C-style `union`?
2. Какие требования предъявляет `std::variant` к наборам типов-альтернатив, и как компилятор гарантирует типобезопасность?
3. Объясните, что происходит внутри объекта `std::variant`: как он хранит данные разных размеров и как определяет,
   какой тип активен в данный момент.
4. Что делает структура‐маркер `std::monostate` и почему её часто располагают первой в списке типов?
5. Какие плюсы и минусы даёт `std::variant` по сравнению с классической иерархией с виртуальными методами,
   когда речь идёт о производительности и размере объекта?
6. Как работает механизм visitor в контексте `std::variant`? Охарактеризуйте роль функции `std::visit`.
7. Сравните три способа доступа к данным внутри `variant`:
   `std::visit`, `std::holds_alternative` + `std::get`, `std::get_if`. Когда и какой метод предпочтителен?
8. Почему функция `std::visit` требует, чтобы посетитель обрабатывал все возможные альтернативы?
   Что произойдёт при нарушении этого требования?
9. Объясните, как *generic lambda* может заменить класс-посетитель. Приведите краткий пример.
10. Что такое паттерн **`overloaded`** и как он упрощает создание посетителей с помощью композиции лямбда-функций?
11. В каких случаях `std::variant` может уступать виртуальным методам по скорости? Опишите факторы, влияющие на это.
12. Разберите пример: `using Token = std::variant<int, double, std::string>;`.
    Сколько байт займёт `Token` на 64-битной платформе и почему?
13. Как добавить новую операцию над всеми вариантами без изменения существующего кода альтернатив?
14. Как можно обработать два (или более) `std::variant` одновременно? Приведите пример.
15. Представьте систему плагинов, где типы добавляются динамически.
    Оцените, насколько хорошо `std::variant` подходит для такой архитектуры.
16. Какие меры нужно предпринять, чтобы уменьшить потенциальное «раздувание» размера `variant`,
    если один из типов альтернаты значительно крупнее других?

## Перегрузка операций - 1

1. В каких случаях перегрузку бинарного оператора стоит объявлять внутри класса, а в каких — вне класса?
2. Почему симметричные бинарные операции (`a + b`, `a == b`) часто реализуют как свободные функции?
3. Опишите различия между объявлением бинарного оператора как дружественной функции и как обычной свободной функции.
   Когда дружба оправдана с точки зрения инкапсуляции?
4. Какие ограничения накладывает стандарт C++ на перегрузку операторов?
5. Чем перегрузка оператора `+=` внутри класса упрощает реализацию оператора `+`?
   Покажите паттерн «определи `+=`, а `+` реализуй через копию и `+=`.»
6. Что такое неявно-генерируемый оператор присваивания,
   и в каких случаях вам потребуется ручная перегрузка `operator=` после добавления арифметических операторов?
7. Объясните назначение и преимущества оператора `<=>` (spaceship) в C++20.
   Какие виды порядка существуют и когда каждый следует использовать?
8. В чём разница между `std::strong_ordering` и `std::weak_ordering`?
   Приведите пример типа данных, для которого подходит только слабый порядок.
9. Рассмотрите ситуацию с «поглощением» исключений внутри перегруженных операторов. Какие альтернативы вместо silent‐fail?
10. Приведите пример перегрузки операций сложения и умножения для комплексных чисел.
11. Как перегрузить `operator*` для класса `Complex`, чтобы поддержать и скалярное, и комплексное умножение?

## Перегрузка операций - 2

1. В чём семантическое различие между операторами `*` и `->` у «умного» указателя? 
   Что должен возвращать каждый из них, чтобы объект вёл себя как обычный указатель?
2. Почему для пользовательских типов перегрузку `operator<<` и `operator>>` всегда объявляют как свободные функции,
   а не методами класса потока?
3. В каком порядке (левый → правый операнд) вызываются перегрузки `operator<<` при цепочке `std::cout << a << b;`?
   Как это влияет на сигнатуру оператора?
4. Покажите сигнатуру перегруженного оператора вывода `<<` для класса `Rational`.
   Объясните, зачем он должен возвращать `std::ostream&`.
5. Какие ограничения накладывает стандарт на возвращаемое значение `operator->()`?
   Что произойдёт, если вернуть объект по значению вместо указателя?
6. Почему `operator<<` часто объявляется `friend`-функцией пользовательского класса?
   Какие преимущества и какие проблемы с инкапсуляцией это создаёт?
7. Напишите минимальный код нестандартного «умного» указателя `UniquePtr<T>`,
   показывающий реализацию `operator*` и `operator->` с проверкой на `nullptr`.
8. Что такое ADL (argument-dependent lookup) и как оно срабатывает при вызове `std::cout << myObj;`?

## Перегрузка операций - 3

1. Что такое пользовательский литерал и какие задачи он решает?
2. Каковы правила написания суффикса пользовательского литерала? Почему стандарт требует начинать его с символа подчёркивания?
3. Почему перегрузка литерала для строк должна принимать два аргумента (`const char*`, `std::size_t`)
4. Продемонстрируйте как с помощью пользовательских литералов и шаблонов можно отличить значения разных единиц измерения
   (метры, сантиметры) и тем самым предотвратить логические ошибки при арифметике.
5. Какие ограничения накладывает стандарт C++ на место объявления оператора `[]`?
6. Объясните различие между «читающей» и «записывающей» версиями `operator[]`.
7. Начиная с C++23 `operator[]` может принимать несколько индексов. 
   Опишите синтаксис и потенциальные области применения этой возможности.
8. До C++23 для имитации `matrix[i][j]` использовали «прокси-объект» (row proxy).
   Объясните, как он работает и какие недостатки устраняет новый стандарт.
9. В чём семантическая разница между префиксным `++it` и постфиксным `it++` для итератора?
    Как это отражается в сигнатурах перегруженных операторов?
10. Опишите, как можно реализовать «циклический» контейнер,
    в котором `operator[]` автоматически оборачивает индекс по модулю размера.
11. Как должны вести себя перегруженные `--` у итератора двунаправленного списка,
    чтобы удовлетворять требованиям категории BidirectionalIterator?

## Перегрузка операций - 4

1. Каков общий синтаксис объявления оператора неявного приведения типа в классе?
2. Какие риски создаёт наличие неявного оператора приведения типа? Опишите типичный сценарий ошибки.
3. Допустимо ли объявить оператор приведения с модификатором `explicit`? 
   Чем он отличается от неявного и в каких ситуациях это оправдано?
4. Почему для оператора приведения типов не указывают возвращаемое значение в списке параметров функции?
5. Объясните опасность перегрузки оператора приведения к ссылочному типу (например, `operator int&()`)?
6. Чем отличается оператор приведения к пользовательскому типу от конвертирующего конструктора?
7. В чём преимущества функционального объекта (перегрузка `operator()`) перед обычной свободной функцией?
8. Объясните, почему «объект функции» традиционно быстрее указателя на функцию при использовании в алгоритмах STL.
9. Какие ограничения накладываются на количество аргументов и спецификаторы доступа при перегрузке `operator()`?
10. Можно ли перегрузить `operator()` в классе-шаблоне с разным набором параметров (overload set)?
11. Опишите процесс передачи функции-объекта в `std::for_each`. Какие требования к типу (concepts) должен удовлетворять функтор?
12. В чём различие между лямбда-выражением и объектом класса с перегруженным `operator()`?
    Приведите пример, когда объект класса предпочтительнее.
13. Какие проблемы могут возникнуть, если функтор хранит внутренние указатели на внешние ресурсы? Как их избежать?
14. Возможно ли создать константный и неконстантный вариант `operator()` в одном классе? Зачем это бывает нужно?

## Обработка исключений

1. Выбрасывание исключения.
2. Перехват исключений заданного типа.
3. Перехват всех исключений.
4. Перевыброс пойманного исключения.
5. Особенности выбрасывания исключений в конструкторе и деструкторе класса
6. Как указать, что функция или метод не выбрасывают исключений?
7. Почему рекомендуется перемещающий конструктор и оператор присваивания делать не выбрасывающими исключений?
8. Что такое срезка? Как избежать срезки при обработке исключений?
9. Стандартные классы исключений.
10. Иерархия классов исключений.
11. Какие преимущества даёт возможность использовать классы в качестве объектов исключений?
12. Какие средства стандартной библиотеки позволяют узнать,
    что у класса или структуры конструктор копирования/перемещения не выбрасывает исключений.
13. Для чего служит класс `std::nested_exception`? Приведите пример использования.
14. Как перехватить все исключения стандартной библиотеки?

## Разработка кода, устойчивого к возникновению исключений

1. Какие существуют гарантии безопасности исключений? В чем они заключаются?
2. Принципы написания кода, устойчивого к возникновению исключений.
3. Идиома RAII (Resource acquisition is initialization)
4. Как обеспечить строгую гарантию безопасности исключений при реализации методов?
5. Как определить, какой уровень безопасности исключений предоставляет функция или метод?
6. Привести пример кода, небезопасного к возникновению исключений.
   Продемонстрировать, как обеспечить для этого кода базовую или строгую гарантию безопасности исключений.

## Шаблоны функций

1. Как объявить шаблон функции?
2. Может ли шаблонная функция не иметь аргументов?
3. Что может использоваться в качестве параметров шаблона? Приведите пример.
4. Для чего используется специализация шаблонов функций? Приведите пример специализации шаблонной функции.
5. Как объявить специализацию шаблонной функции?
6. Может ли специализация шаблонной функции сама быть шаблоном? Если да, приведите пример.
7. Как объявляются шаблонные операторы? Приведите пример.

## Шаблоны классов

1. Как объявить шаблон класса?
2. Как объявляется метод шаблонного класса вне класса?
3. Как объявляется шаблонный метод класса вне класса?
4. Как объявляется шаблонный метод шаблонного класса вне класса?
5. Чем отличается частичная и полная специализация шаблона класса. 
6. Как объявить частичную и полную специализацию шаблона класса?
7. Может ли виртуальный метод класса быть шаблонным?
8. Применение шаблонов при построении иерархий классов.

## Шаблоны с переменным числом аргументов

1. Как объявить функцию-шаблон с переменным количеством аргументов?
2. Как объявить класс-шаблон с переменным количеством аргументов?
3. Напишите шаблонную функцию Second, принимающую произвольное количество аргументов любого типа и возвращающую второй аргумент.
4. Как из шаблонной функции, принимающей произвольное число аргументов вызвать другую функцию с произвольным количеством аргументов и передать туда все аргументы?
5. Свёрточные выражения. Напишите шаблонную функцию `ApplyToMany`, которая принимает функциональный объект f и произвольное количество аргументов,
 а потом последовательно вызывает f с каждым из переданных аргументов.
6. Напишите шаблонную функцию `EqualsToOneOf`, принимающую один или более аргументов. Функция должна вернуть true, если ёё первый аргумент равен одному из остальных аргументов и false в противном случае.
7. Напишите шаблонную функцию Last, принимающую произвольное количество аргументов любого типа и возвращающую свой последний аргумент.
