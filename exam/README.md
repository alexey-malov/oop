- [Основы синтаксиса языка C++](#основы-синтаксиса-языка-c)
  - [Целочисленные типы данных](#целочисленные-типы-данных)
  - [Типы данных вещественных чисел](#типы-данных-вещественных-чисел)
  - [Логический тип данных](#логический-тип-данных)
  - [Символьные литералы](#символьные-литералы)
  - [Строковые литералы](#строковые-литералы)
  - [Операторы](#операторы)
  - [Переменные](#переменные)
  - [Синонимы типов](#синонимы-типов)
  - [Перечислимый тип данных](#перечислимый-тип-данных)
  - [Приведение типа](#приведение-типа)
  - [Управление ходом выполнения программы](#управление-ходом-выполнения-программы)
  - [Функции](#функции)
  - [Структуры](#структуры)
  - [Массивы](#массивы)
  - [Ссылки](#ссылки)
  - [Пространства имён](#пространства-имён)
  - [Модель памяти C++](#модель-памяти-c)
  - [Указатели](#указатели)
  - [Статическое, автоматическое и динамическое размещение объектов в памяти](#статическое-автоматическое-и-динамическое-размещение-объектов-в-памяти)
- [Стандартная библиотека языка C++](#стандартная-библиотека-языка-c)
  - [std::string и std::string\_view](#stdstring-и-stdstring_view)
  - [std::vector и std::array](#stdvector-и-stdarray)
  - [std::deque](#stddeque)
  - [std::list и std::forward\_list](#stdlist-и-stdforward_list)
  - [Контейнеры map и multimap](#контейнеры-map-и-multimap)
  - [Контейнеры unordered\_map и unordered\_multimap](#контейнеры-unordered_map-и-unordered_multimap)
  - [Контейнеры set и multiset](#контейнеры-set-и-multiset)
  - [Контейнеры unordered\_set и unordered\_multiset](#контейнеры-unordered_set-и-unordered_multiset)
  - [std::function и лямбда-функции](#stdfunction-и-лямбда-функции)
  - [Ввод-вывод](#ввод-вывод)
  - [Итераторы](#итераторы)
  - [Стандартные алгоритмы](#стандартные-алгоритмы)
  - [std::optional](#stdoptional)
  - [Стандартные умные указатели](#стандартные-умные-указатели)
  - [std::filesystem](#stdfilesystem)
  - [std::variant](#stdvariant)
- [Объектно-ориентированное программирование](#объектно-ориентированное-программирование)
  - [Общие сведения об объектно-ориентированном программировании](#общие-сведения-об-объектно-ориентированном-программировании)
  - [Классы, данные и методы](#классы-данные-и-методы)
  - [Жизненный цикл объекта](#жизненный-цикл-объекта)
  - [Копирование, присваивание и перемещение объектов](#копирование-присваивание-и-перемещение-объектов)
  - [Отношения между классами](#отношения-между-классами)
  - [Наследование](#наследование)
  - [Полиморфизм](#полиморфизм)
  - [Множественное наследование](#множественное-наследование)
  - [Перегрузка арифметических операций и операций сравнения](#перегрузка-арифметических-операций-и-операций-сравнения)
  - [Перегрузка прочих операций](#перегрузка-прочих-операций)
  - [Обработка исключений](#обработка-исключений)
  - [Разработка кода, устойчивого к возникновению исключений](#разработка-кода-устойчивого-к-возникновению-исключений)
  - [Шаблоны функций](#шаблоны-функций)
  - [Шаблоны классов](#шаблоны-классов)
  - [Шаблоны с переменным числом аргументов](#шаблоны-с-переменным-числом-аргументов)

# Основы синтаксиса языка C++

## Целочисленные типы данных

1. Каковы основные типы целых чисел в C++?
2. Как объявить переменную целого типа в C++?
3. Каковы диапазоны значений для различных типов целых чисел в C++?
4. Каковы основные операции, которые можно выполнять с целыми числами в C++?
5. Чем отличаются `signed` и `unsigned` типы?
6. Каковы правила преобразования типов при выполнении операций с целыми числами в C++?
7. Какие битовые операции можно использовать для работы с целыми числами в C++? Привести примеры
8. Как проверить, является ли целое число четным или нечетным в C++?
9. Как вычислить остаток от деления двух целых чисел в C++?
10. Чему равно частное и остаток при делении, когда один или оба аргумента — отрицательные?
11. Как проверить, является ли целое число положительным или отрицательным в C++?
12. Как использовать условные операторы и циклы для работы с целыми числами в C++?
13. Как проверить, что при умножении двух целых чисел не будет переполнения?
14. Что означает литерал `12345UL`?
15. Запишите число 123 в двоичной форме в виде C++ литерала.
16. Для чего используется символ `'` внутри числового литерала?
17. Как записываются шестнадцатеричные литералы в C++?
18. Переведите 0321 в десятичную систему.
19. Переведите 0b11101 в десятичную систему.

## Типы данных вещественных чисел

1. Какие типы вещественных чисел существуют в C++?
2. Как объявить переменную вещественного типа в C++?
3. Каковы диапазоны значений для различных типов вещественных чисел в C++?
4. Какие операции можно выполнять с вещественными числами в C++?
5. Как происходит преобразование типов при выполнении операций с вещественными числами в C++?
6. Какие математические функции доступны в C++ для работы с вещественными числами?
7. Как проверить, является ли вещественное число положительным или отрицательным в C++?
8. Как проверить, является ли вещественное число целым в C++?
9. Как округлить вещественное число до целого в C++?
10. Как сравнить два вещественных числа на равенство в C++?
11. Какой тип будет у литерала `2e+10`?
     В чем разница между `1.5`, `1.5f` и `1.5L`?

## Логический тип данных

1. Какой тип данных используется для хранения логических значений в C++?
2. Какие значения считаются `true`, а какие `false` при неявном преобразовании?
3. Какие значения может принимать логический тип в C++?
4. Как объявить переменную логического типа в C++?
5. Какие операторы сравнения могут использоваться с логическим типом в C++?
6. Какие логические операторы доступны в C++?
7. Какой результат выражения true && false в C++?
8. Какой результат выражения true || false в C++?
9. Какой результат выражения !true в C++?
10. Какой результат выражения (5 > 3) && (7 < 10) в C++?
11. Какой результат выражения (4 == 4) || (6 != 6) в C++?

## Символьные литералы

1. Какие символьные литералы поддерживаются в языке С++?
2. Что такое символьный литерал, и как он объявляется в С++?
3. Какие символьные значения можно задать с помощью символьных литералов в С++?
4. Какой символьный литерал используется для обозначения перевода строки в С++?
5. Может ли символьный литерал содержать несколько символов? Если да, то как это делается?
6. Что такое управляющие последовательности символов, и какие из них поддерживаются в С++?
7. Приведите не менее 3 примеров символьных литералов в С++?
8. Какие символьные литералы используются для обозначения специальных символов, таких как пробел или знак табуляции?
9. Как внутри символьного литерала задать символ с заданным кодом?
10. Для чего используют `'\n'` в строках?
11. Как записать символ с шестнадцатеричным кодом 255?
12. Зачем использовать `'\0'` вместо `0`?

## Строковые литералы

1. Как объявляется строковый литерал в языке C++?
2. Что такое управляющие последовательности символов и как они используются в строковых литералах в языке C++?
3. Каким образом можно задать пустую строку в языке C++?
4. Каким образом можно скомбинировать два строковых литерала в одну строку в языке C++?
5. Как строковые литералы представляются в памяти?
6. Строковые литералы и для чего они нужны. Как использовать сырые строковые литералы?
7. Чем отличаются эти строковые литералы: `L"Hello"` от `"Hello"`?
8. Что произойдет, если записать `"abcd" "ef"`?
9. Приведите пример строки с escape-последовательностью.
10. Приведите пример сырого строкового литерала, содержащего обратный слеш.

## Операторы

1. Что произойдёт при выполнении выражения `17 / 5`, если оба операнда имеют тип `int`?
2. Чем отличается поведение оператора `%` при работе с `int` и `float`?
3. Напишите выражение, проверяющее, находится ли переменная `x` в диапазоне от 100 до 200 включительно.
4. Чем логические операторы отличаются от побитовых?
5. Как работают логические операторы `&&` и `||` при коротком замыкании?
6. Какое значение будет у переменной `j` после выполнения `int i = 42; int j = ++i;`?
7. Напишите фрагмент кода, устанавливающий 4 и 7 биты в целочисленной переменной.
8. Напишите фрагмент кода, сбрасывающий все биты кроме 3-го в целочисленной переменной.
9. Напишите код, обменивающий местами 4 и 6 биты в целочисленной переменной.
10. Какой результат даст выражение `0b101101 ^ 0b110110`?

## Переменные

1. Объявление переменных
2. Автоматическое определение типа переменной
3. Объявление константной переменной.
4. Области видимости переменных.
5. Доступ к переменной, объявленной в другое единице трансляции.

## Синонимы типов

1. Что такое синоним типа в языке C++ и для чего он используется?
2. Каким образом объявляются синонимы типов в языке C++?
3. Объявите синоним типов с помощью `using`.
4. Как объявить синоним типа для стандартных типов данных, таких как int или double, в языке C++?
5. Как объявить синоним типа для пользовательского типа данных в языке C++?
6. Какие преимущества имеет использование синонимов типов в языке C++?
7. Каким образом можно определить новый тип данных с использованием `typedef` в языке C++?=

## Перечислимый тип данных

1. Что такое перечислимый тип данных в языке C++ и для чего он используется?
2. Как объявляется перечислимый тип данных в языке C++?
3. Чем отличается перечислимый тип данных от обычных целочисленных типов данных в языке C++?
4. Какие значения могут принимать элементы перечислимого типа данных в языке C++?
5. Каким образом можно указать базовый тип данных для перечисляющего типа данных в языке C++?
6. Что такое scoped enum в языке C++ и как он отличается от обычного перечислимого типа данных?
7. Как объявляется scoped enum в языке C++?
8. Как можно обратиться к элементу scoped enum в языке C++?
9. Что такое underlying type у scoped enum в языке C++ и как он используется?
10. Какие преимущества имеет использование scoped enum в языке C++ перед обычным перечислимым типом данных?

## Приведение типа

1. Что такое приведение типа (typecasting) в языке C++ и для чего оно нужно?
2. Что такое явное приведение типа (explicit typecasting) и каким оператором оно осуществляется в языке C++?
3. Что такое неявное приведение типа (implicit typecasting) и как оно происходит в языке C++?
4. Приведите пример неявного приведение типа в языке C++?
5. Приведение типа в стиле языка C.
6. Почему использование явного преобразования в стиле C может быть опасным?
7. Для чего предназначен `static_cast` и какие типы преобразований он поддерживает?
8. Какой тип будет у результата выражения `1U - 1L` при разных размерах типов?
9. Для чего используется `const_cast` и какие риски связаны с его применением?
10. В каких сценариях используется `reinterpret_cast`?
11. Почему `reinterpret_cast` считается менее безопасным по сравнению с другими операторами?
12. Приведите пример корректного использования `reinterpret_cast` для работы с памятью.
13. Какой оператор преобразования можно использовать для преобразования указателя `void*` в указатель на конкретный тип?
14. Какие гарантии безопасности исключений предоставляют операторы `static_cast`, `const_cast` и `reinterpret_cast`?
15. Какие типы преобразований поддерживает `dynamic_cast` и в каких сценариях он используется?

## Управление ходом выполнения программы

1. Что делает точка с запятой в конце выражения в C++?  
2. Как объединить несколько инструкций в одну составную инструкцию?  
3. Что происходит с переменными, объявленными внутри блока при его завершении? 
4. Оператор if. Конструкция else if.
5. Почему рекомендуется использовать фигурные скобки даже для однолинейных `if`/`else`? 
6. `if constexpr`. Для чего используется? Какие ограничения?
7. Как исправить ошибку в коде:

    ```cpp
    if (n > 0)
        if (a > b)
            z = a;
    else
        z = b;
    ```  

8. Оператор цикла `for`. Цикл `for` со счётчиком. Синтаксис.
9. Range-based `for`. Что нужно сделать, чтобы элементы контейнера можно было перебирать, используя range-based `for`?
10. Что происходит, если условие в `for` отсутствует?
11. Оператор цикла `while`.
12. Оператор цикла `do-while`.
13. В чём разница между `while` и `do-while`? Приведите пример.
14. Досрочный выход из цикла и пропуск итерации цикла.
15. Какой оператор лучше использовать для цикла, который должен выполниться как минимум один раз?  
16. Как, находясь во внутреннем цикле, выйти из внешнего?
17. Что делает оператор `break` внутри цикла?
18. Что делает оператор `continue` внутри цикла?
19. Для каких типов данных используется `switch`?  
20. Что делает `default` в операторе `switch`?
21. Что такое "сквозное" выполнение ветвей `case`?
22. Для чего применяется атрибут `[[fallthrough]]`?
23. Какие типы данных поддерживаются `range-based for`?
24. Почему использование `goto` считается плохой практикой?
25. Приведите пример ошибки, связанной с отсутствием фигурных скобок в `if

## Функции

1. Для чего используются функции?
2. Какой оператор используется для возврата значения из функции?
3. Может ли функция не возвращать значение? Если да, как это указывается? 
4. Какой синтаксис используется для объявления функции? 
5. В чём разница между объявлением и определением функции?
6. Почему объявление функции должно быть выполнено до её вызова?
7. Какой способ передачи параметров используется по умолчанию в C++?
8. Что происходит с параметром, переданным по значению, внутри функции?
9. В чём разница между передачей по значению и по ссылке?
10. Как указать значения по умолчанию для аргументов функции?
11. Когда рекомендуется использовать константную ссылку в качестве параметра?
12. Может ли функция возвращать несколько значений? Если да, как это реализуется?
13. Какой тип параметра следует использовать для простых типов (например, `int`): по значению или по ссылке?
14. Какой тип параметра следует использовать, если функция не изменяет объект, но он тяжёлый (например, `std::vector`)?
15. Что такое "выходной аргумент" и как он используется? 
16. В каких случаях передача по ссылке предпочтительнее?
17. Лямбда функции.
18. Захват параметров лямбда функции по значению и по ссылке. Чем отличаются?
19. Можно ли изменить значение переменной, захваченной в лямбде по значению?
20. Какой код компилятор сгенерирует на основе лямбда-функции с пустым списком захвата? А если список параметров будет непустым?

## Структуры

1. Что такое структура в C++ и в чём её преимущества по сравнению с отдельными переменными?
2. Как объявить структуру?
3. Какие типы данных могут использоваться в полях структуры?
4. Что такое член структуры и как им можно управлять?
5. Как инициализировать структуру при её объявлении?
6. Какой синтаксис используется для доступа к полям структуры?
7. Как инициализировать структуру с вложенными структурами?
8. Как передать структуру в функцию в C++, и какие способы можно использовать для передачи структуры?
9. В чём разница между передачей структуры по значению и по ссылке?
10. Что происходит с полями глобальных структур при их объявлении?
11. Что выведет программа, если поле `std::string` структуры не инициализировано?
12. Как можно сравнить две структуры на равенство?
13. Когда предпочтительнее использовать структуры вместо классов?
14. Как порядок полей в стуктуре влияет на её размер? С чем это связано?
15. Указатель на структуру, как обратиться к полю структуры по указателю?
16. Массивы структур.
17. Размещение полей структур в памяти.

## Массивы

1. Что такое массив в C++ и каковы его основные характеристики?
2. Как объявить массив в C++?
3. Что такое индекс массива? Каковы требования к типу индекса для массива?
4. Как получить доступ к элементу массива по индексу?
5. Как инициализировать массив при его объявлении? Приведите пример.
6. Что происходит с элементами массива, не указанными при инициализации?
7. Какой синтаксис используется для автоматического определения размера массива?
8. Как узнать размер массива?
9. Можно ли изменить размер массива после его создания?
10. Что происходит с массивом, переданным как параметр, в функции?
11. В чём разница между передачей массива в функцию напрямую и как элементом структуры?
12. Как заполнить массив значениями по умолчанию?
13. Как отсортировать элементы массива в порядке убывания?
14. Как связаны строковые литералы и массивы символов?
15. Что такое `std::array` и как он отличается от обычного массива?
16. Объявление многомерных массивов. Объявление многомерного массива с помощью `std::array`.
17. Как получить доступ к элементу многомерного массива? Приведите пример.

## Ссылки

1. Что такое ссылка в C++ и как она отличается от указателя?
2. Почему при объявлении ссылки необходимо сразу инициализировать её?
3. Что происходит при присваивании значения через ссылку?
4. Может ли ссылка быть неинициализированной? Почему?
5. Как ссылки могут использоваться для работы с элементами массива? Приведите пример.
6. В чём разница между обычной ссылкой и константной ссылкой?
7. Есть ли преимущество передачи параметров в функцию по ссылке вместо передачи по значению?
8. Передача параметров в функцию по значению, по ссылке, по константной ссылке.
9. Когда рекомендуется использовать константные ссылки в качестве параметров функций?
10. Что будет, если функция вернёт ссылку на переменную, объявленную внутри функции?
11. Особенности работы ссылок на временные объекты. Чему равно время жизни временного объекта, на который ссылается ссылка?
12. Как изменение исходной переменной влияет на константную ссылку на эту переменную?
13. Чему равно выражение `sizeof(ref)`, где ref — ссылка?
14. Как хранятся ссылки внутри классов и структур? Чему равен размер структуры, содержащей ссылку?
15. Что на самом деле передаётся в функцию, принимающую аргумент по ссылке?

## Пространства имён

1. Что такое пространство имён в C++ и каковы его основные цели?
2. Как объявить пространство имён в C++?
3. Почему рекомендуется избегать `using namespace` в заголовочных файлах?
4. Можно ли использовать несколько пространств имён в одном файле?
5. Каким образом происходит разрешение конфликтов имен в разных пространствах имён?
6. Какие стандартные пространства имён существуют в C++?
7. Можно ли создавать свои собственные пространства имён?
8. Каким образом можно использовать элементы из других пространств имён?
9. Что такое алиасы (синонимы) пространства имён и как их объявлять?
10. Какой синтаксис используется при обращении к элементам вложенных пространств имён?
11. Что такое безымянное пространство имён и как оно используется?
12. В чём отличие видимости идентификаторов в безымянном пространстве от обычного?
13. Как получить доступ к функции `Print`, объявленной в пространстве имён `graphics::shapes`?
14. Объясните, как работает ADL (Argument-Dependent Lookup). Приведите пример использования.
15. Как импортировать конкретный идентификатор из пространства имён без импорта всего пространства?
16. Как решить конфликт имен, если два пространства имён содержат функции с одинаковыми именами?
17. Какие проблемы могут возникнуть при использовании `using namespace` в крупных проектах?

## Модель памяти C++

1. Что такое объект с точки зрения модели памяти языка? Какими свойствами он обладает?
2. Что такое выравнивание? Для чего оно используется?
3. Чем размер объекта отличается от его выравнивания?
4. Выравнивание структур.
5. Как узнать размер объекта?
6. Как узнать выравнивание объекта?

## Указатели

1. Что такое указатель? Для чего применяются указатели?
2. Как объявить указатель на переменную определенного типа?
3. Как получить адрес переменной в памяти и сохранить его в указатель?
4. Как получить значение переменной по ее адресу, на который указывает указатель?
5. Как изменить значение переменной по ее адресу, на который указывает указатель?
6. Как проверить, равны ли два указателя?
7. Как проверить, является ли указатель нулевым?
8. Какие операции можно выполнять с указателями?
9. Какие ошибки могут возникнуть при работе с указателями?
10. В чем отличие ссылки от указателя?
11. Что такое указатель `void*`? Для чего применяется? Какие с ним возможны операции?
12. Чем отличаются указатели `T*`, `const T*`, `T* const` и `const T* const`?
13. Что такое адресная арифметика?
14. К каким указателям применимы операции адресной арифметики?
15. Как определить, сколько элементов находится между указателями `p` и `q`? 
16. Что такое выравнивание памяти? Как получить выравнивание некоторого типа?
17. Как объявить и использовать указатель на указатель? 
18. Как выравнивание влияет на расположение полей структуры в памяти?
19. Как выравнивание влияет на производительность?
20. Как константная ссылка отличается от указателя на константу?

## Статическое, автоматическое и динамическое размещение объектов в памяти

1. В чём различие между статическим, автоматическим и динамическим выделением памяти?  
2. Приведите пример статического выделения памяти.  
3. Как работает автоматическое выделение памяти в C++?  
4. В чём преимущество динамического выделения памяти?  
5. Какой срок жизни объекта при статическом выделении памяти?  
6. Каковы основные недостатки динамического выделения памяти?  
7. Почему динамическое выделение памяти требует больше накладных расходов?
8. Что такое стек вызовов и как он связан с автоматическим выделением памяти?  
9. Что такое куча (heap) и как она используется в C++? 
10. Как сконструировать одиночный объект в динамической памяти? Как его разрушить и освободить память?
11. Как сконструировать массив объектов в динамической памяти? Как его разрушить и освободить память?
12. Что произойдёт при использовании непарных версий `new`/`delete`?
13. Что такое размещающий `new` и как он используется? 
14. Как правильно выровнять память для размещающего `new`?  
15. Как правильно разрушить объект, ранее созданный размещающим оператором `new`?
16. Какие функции стандартной библиотеки позволяют создавать объекты в сыровой памяти? 
17. В чём разница между `std::uninitialized_copy` и `std::uninitialized_move`? 
18. Как работает `std::destroy_at` и зачем он нужен? 
19. Приведите пример использования `std::construct_at`.
20. Что такое утечка памяти и как её избежать? 

# Стандартная библиотека языка C++

## std::string и std::string_view

1. Что представляет собой класс std::string в C++?
2. Какие типы данных могут использоваться для хранения символов в std::string?
3. Перечислите основные преимущества использования std::string по сравнению с C-строками.
4. Опишите внутреннее устройство std::string в типичных реализациях?
5. Какова разница между `std::string` и `std::wstring`?
6. Какие операции можно выполнять над std::string?
7. Чем отличается размер от вместимости?
8. Что такое small string optimization?
9. Как изменяются значения size и capacity при использовании метода erase?
10. Какова сложность операций вставки и замены символов строки?
11. Класс `std::string_view`, чем отличается от `std::string`?
12. В каких случаях использовать `std::string_view`, а в каких `std::string`?
13. Чем отличается substr в `std::string` и `std::string_view`?
14. Как найти все вхождения некоторой подстроки в строке?
15. Какой метод позволяет объединить две строки в C++?
16. Как **быстро** найти все вхождения некоторой подстроки в строке?
17. Какие операторы сравнения доступны для объектов `std::string`?
18. Как преобразовать `std::string` в числовой тип данных и обратно?
19. Как можно ускорить работу со строками в C++?
20. Какой результат будет у `string_view` после разрушения оригинальной строки?

## std::vector и std::array

1. Что такое `std::array` и как он отличается от C-массива?
2. Можно ли передавать std::array по значению в функцию?
3. Опишите трехмерный массив при помощи `std::array`.
4. Что такое `std::vector`? Чем отличается от простого массива и `std::array`?
5. Описать внутреннее устройство `std::vector`. Желательно показать на схеме.
6. Что произойдёт с полностью заполненным `vector`, если выполнить операцию `push_back`?
7. Типичные операции над `std::vector`. Какая сложность этих операций?
8. Приёмы оптимизации производительности при работе с `std::vector`.
9. Метод `at` и операция `[]`. В каких случаях какую из этих операций следует использовать?
10. Как обойти все элементы `std::vector` в прямом и обратном направлении?
11. Как `std::vector` хранит элементы в памяти: последовательно или с промежутками?
12. Чем размер вектора отличается от его вместимости?
13. Что такое инвалидация итераторов? Какие операции над `std::vector` приводят к инвалидации его итераторов?
14. Что происходит с вектором при вызове `push_back`, если текущий размер равен ёмкости?
15. Чем отличаются `emplace`-методы от `push`/`insert`?
16. Идиома `erase`/`remove`.
17. Как развернуть содержимое `std::vector` за O(1) памяти и O(N) времени?
18. Как получить  указатель на первый элемент вектора?
19. Какова амортизированная сложность операции `push_back`? Что такое амортизированная сложность?
20. Как вставить в вектор элементы из другого контейнера, например из `deque` (в конец, в начало, в середину).
    Какова сложность этих операций?
21. Для чего служит метод `shrink_to_fit()` и когда его стоит применять?
22. Приведите пример использования обратных итераторов у вектора.
23. Что происходит с данными в векторе при вызове `clear()`?
24. Что происходит с итератором `end()`, если размер вектора изменяется?
25. Может ли `std::vector` содержать объекты, для которых не определен оператор присваивания?
26. Может ли `std::vector` содержать объекты, у которых отсутствует конструктор по умолчанию?
27. Для чего нужен метод `reserve`?
28. В каких случаях предпочтительнее использовать `std::vector`, а в каких — `std::list`?
29. Какие ограничения у `std::vector` по сравнению с `std::deque`?
30. Какой контейнер обеспечивает более быстрое вставку/удаление в середине: `std::vector` или `std::list`?

## std::deque

1. Контейнер `std::deque`. Чем отличается от std::vector, в каких случаях применять vector, а в каких deque?
2. Какой заголовочный файл необходимо подключить для работы с `std::deque`?
3. Как устроен контейнер std::deque внутри? Нарисуйте схему и объясните её работу.
   Какие структуры данных используют типичные реализации этого контейнера?
4. Почему размер блоков и количество блоков в `std::deque` обычно являются степенями двойки?  
5. Какие операции над `std::deque` приводят, а какие не приводят к инвалидации итераторов? Объясните, с чем это связано?
6. Для чего типичные реализации deque используют "закольцованность" блоков? 
7. Основные операции над `std::deque` и их сложность.
8. Чем отличаются emplace-методы от `push`/`insert`
9. Отличия `std::deque` от `std::list`. Когда лучше применять `deque`, а когда `list`?
10. Какие операции над std::deque приводят к инвалидации ссылок?
11. Как развернуть std::deque?
12. За счёт чего в `std::deque` обеспечивается доступ к элементам по индексу за O(1)?
13. Как вставить в deque элементы из другого контейнера (в начало, в конец, в середину)?
14. Какой метод `std::deque` позволяет безопасно получить элемент по индексу с проверкой границ?
15. Почему в `std::deque` нет метода `data`, в отличие от `std::vector`?
16. Какой получить ссылку на последний элемент `std::deque`?
17. Какой из контейнеров более компактно хранит элементы в памяти: `std::deque` или `std::list`? Почему?
18. Последовательная итерация по элементам какого из перечисленных контейнеров будет более быстрой:
    `deque`, `vector`, `list`?
19. Как `std::deque` обрабатывает ситуацию, когда блоки заполнены?
20. Сравните скорость вставки элементов в начало и в конец `std::deque` и `std::vector`.
21. Сравните время доступа к элементу по его индексу в случае с `std::deque` и `std::vector`.
22. В каких случаях `std::deque` предпочтительнее `std::vector`?
23. Какие ограничения у `std::deque` по сравнению с `std::list`? 
24. Какой контейнер обеспечивает более быстрое вставку/удаление в середине: `std::deque` или `std::list`?

## std::list и std::forward_list

1. Контейнер `std::list` и `std::forward_list`, чем отличаются? Когда использовать `list`, а когда `forward_list`?
2. Какие операции поддерживает `std::list`, а какие `std::forward_list`?
3. Какие операции над `list` и `forward_list` приводят к инвалидации ссылок и итераторов, а какие нет? Почему?
4. Как развернуть `std::forward_list`? Какова сложность этой операции по памяти и по времени?
5. Как отсортировать `std::list`? Какова сложность этой операции?
6. Какова временная сложность вставки элемента в произвольную позицию `std::list`?
7. Как перенести элементы из одного списка в другой? Какова сложность этих операций?
8. Как удалить элементы std::list, удовлетворяющие заданному критерию?
9. Как удалить из std::list подряд идущие дубликаты? `[1, 3, 2, 2, -8, 5, 1, 1, 1, 2]` -> `[1, 3, 2, -8, 5, 1, 2]`
10. Как перенести элементы из одного `forward_list` в другой. Какова сложность этих операций?
11. Как отсортировать всё содержимое `forward_list`?
12. Как отсортировать диапазон элементов `std::list` и `std::forward_list`?
13. Как вставить в `std::list` диапазон элементов из другого контейнера?
14. Какие операции можно выполнять над итераторами двусвязного списка?
15. В каких случаях предпочтительнее использовать `std::list` вместо `std::vector`?
16. Какой контейнер обеспечивает более быстрый доступ к элементу по индексу: `std::list` или `std::vector`?
17. Каким образом можно вставить элементы двусвязного списка в другой контейнер в обратном порядке?
18. Почему `std::forward_list` не имеет метода `push_back`?
19. Как удалить из `std::forward_list` элемент, следующий за некоторым элементом?
20. Как узнать количество элементов в `std::forward_list`?
21. В каких случаях `std::forward_list` предпочтительнее `std::list`?

## Контейнеры map и multimap

1. Контейнер std::map. Для чего используется?
2. Операции над `map`. Какова сложность этих операций?
3. В каком порядке находятся элементы `std::map`? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве ключей `map` использоваться пользовательские типы данных? Что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве значений?
6. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.emplace(key, value)`?
7. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.at(key) = value`?
8. Напишите функцию `optional<string> TryGetValue(const map<int, string>& m, int key)`
9. Как можно ускорить вставку в `map`?
10. Что происходит при использовании оператора `[]` для элемента, который ещё не существует в `std::map`?
11. Как быстро перенести элемент из одного контейнера `map` в другой `map` того же типа?
12. Как получить все значения `multimap` с заданным ключом?
13. Что возвращает метод `insert` для `std::map` и как он отличается от `std::multimap`?
14. В чём разница между `lower_bound` и `upper_bound`?
15. Как реализовать пользовательскую функцию сравнения для `std::map`? 
16. Какова временная сложность вставки, поиска и удаления в `std::map`?
17. В каких случаях использовать `map`, а в каких `unordered_map`?
18. Что происходит с итераторами при вставке нового элемента?
19. Когда стоит использовать `std::multimap` вместо `std::map`?
20. В чем различие между доступом к элементам с помощью метода `at` и операцией `[]`?
21. Чем отличается `emplace` от `try_emplace`?
22. Что происходит, если использовать `std::map` с ключами, не поддерживающими оператор `<`?
23. В каком порядке возможен обход элементов контейнера map?
24. Как удалить из контейнера map все элементы, удовлетворяющие заданному критерию?
25. Как удалить из контейнера map не более N элементов, удовлетворяющих заданному критерию?

## Контейнеры unordered_map и unordered_multimap

1. Контейнер `unordered_map`. Для чего используется?
2. Операции над `unordered_map`. Их сложность.
3. Что означает "амортизированная константа" применительно к сложности операций?
4. В каком порядке хранятся элементы внутри `unordered_map`? Можно ли изменить порядок этих элементов?
5. Как можно ускорить вставку в `unordered_map`?
6. Чем отличается вставка элементов c помощью `umap[key] = value` от вставки `umap.emplace(key, value)`?
7. Чем отличается вставка элементов c помощью `umap[key] = value` от вставки `umap.at(key) = value`?
8. Напишите функцию `optional<string> TryGetValue(const unordered_map<int, string>& m, int key)`.
9. Какие требования предъявляются к ключам для `std::unordered_map`?
10. Что нужно сделать, чтобы в качестве ключей `unordered_map` использовать пользовательские типы данных?
11. Что возвращает метод `insert` для `std::unordered_map` и как он отличается от `std::unordered_multimap`?
12. В чём преимущество `std::unordered_map` перед `std::map`?
13. Что такое хеш-функция? Как она используется в `unordered_map`?
14. Как быстро перенести элемент из одного `unordered_map` в другой того же типа
15. Что такое bucket-ы в `unordered_map`? Как они влияют на производительность?
16. Что такое rehashing? Когда он возникает? Как можно им управлять?
17. Приведите пример хешера для структуры с несколькими полями.
18. Контейнер `unordered_multimap`. Чем отличается от `unordered_map`?
19. Как реализовать пользовательский компаратор для `std::unordered_map`?
20. Как получить все элементы `unordered_map` с одним и тем же ключом?
21. Что произойдёт, если пользовательский хешер не обеспечивает равномерное распределение?
22. В каком порядке возможен обход элементов `unordered_map`?
23. Когда использовать map, а когда `unordered_map`?
24. Как удалить из `unordered_map` не более N элементов, удовлетворяющих заданному критерию?

## Контейнеры set и multiset

1. Контейнер std::set. Для чего используется?
2. Операции над set. Какова сложность этих операций?
3. В каком порядке находятся элементы std::set? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве элементов set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов set?
6. Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
7. Как быстро перенести один элемент из одного контейнера set в другой того же типа?
8. Когда использовать set, а когда unordered_set?
9. Как можно ускорить вставку в set?
10. Как скопировать элементы из vector в set? Как скопировать элементы из set в vector?
11. Контейнер multiset. Как получить все значения контейнера multiset с заданным ключом?
12. Чем отличается insert от emplace?
13. Как удалить из set все элементы, удовлетворяющие заданному критерию?
    Как удалить из set не более N элементов, удовлетворяющих заданному критерию?

## Контейнеры unordered_set и unordered_multiset

1. Контейнер std::unordered_set. Для чего используется?
2. Операции над unordered_set. Какова сложность этих операций?
3. В каком порядке находятся элементы std::unordered_set? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве элементов unordered_set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов unordered_set?
6. Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
7. Как быстро перенести один элемент из одного контейнера unordered_set в другой того же типа?
8. Когда использовать set, а когда unordered_set?
9. Как скопировать элементы из vector в unordered_set? Как скопировать элементы из unordered_set в vector?
10. Контейнер unordered_multiset. Как получить все значения контейнера unordered_multiset с заданным ключом?
11. Как удалить из unordered_set все элементы, удовлетворяющие заданному критерию?
    Как удалить из unordered_set не более N элементов, удовлетворяющих заданному критерию?
12. Что такое хеш-функция? Как она используется в unordered_set?
13. Что такое bucket-ы в unordered_set? Как они влияют на производительность?
14. Что такое rehashing? Когда он возникает? Как можно им управлять?

## std::function и лямбда-функции

1. Что такое `std::function` и каковы его основные цели?
2. Какие типы объектов может оборачивать `std::function`?
3. В чём разница между `std::function` и указателем на функцию?
4. Объявите указатель на функцию, которая принимает аргументы типа float и double и возвращает целое число.
5. Что такое лямбда-функция и каков её синтаксис?
6. Как захватить переменные из окружающего контекста в лямбда-функции?
7. В чём разница между захватом по значению и по ссылке? Приведите примеры.  
8. Можно ли изменить захваченные по значению переменные внутри лямбды?
9. Что произойдёт, если захватить переменную по ссылке, которая вышла из области видимости? Приведите пример.
10. Как захватить все переменные по значению, кроме одной по ссылке?
11. Можно ли использовать `this` в лямбда-функции внутри класса?
12. Приведите пример использования `std::function` для передачи функции-обработчика в другую функцию.
13. Как использовать `std::bind` для создания функционального объекта с параметрами?
14. Как избежать утечки памяти при использовании `std::function` с динамически выделенными объектами?
15. Можно ли использовать `std::function` для привязки к методам класса?

## Ввод-вывод

1. Как перенаправить вывод `std::cout` в файл при запуске программы?  
2. Назовите три основных стандартных потока ввода-вывода в C++.
3. Как проверить, успешно ли завершилась операция ввода?
4. Какие флаги существуют у потоков ввода-вывода?
5. Как вернуть поток в нормальное состояние после обнаружения ошибки?
6. Как настроить потоки ввода-вывода, чтобы в случае ошибки выбрасывалось исключение?
7. Как можно настроить поток ввода-вывода для ввода-вывода значений в другой системе счисления?
8. Что происходит с `std::cin`, если ввести строку вместо числа?
9. Как выровнять текст по правому краю с помощью манипуляторов?
10. Как установить точность вывода чисел с плавающей точкой?
11. В чём разница между режимами `std::ios_base::out` и `std::ios_base::app`?
12. Как проверить, успешно ли открыт файл?
13. Что происходит с содержимым файла при открытии в режиме `std::ios_base::trunc`?
14. В чём разница между текстовым и двоичным режимами работы с файлами?
15. Для чего используется `std::istringstream`?
16. Как извлечь строку из `std::istringstream`?
17. Как получить содержимое `std::ostringstream` в виде строки?
18. Как убедиться, что данные, выведенные в поток были успешно сброшены на устройство?

## Итераторы

1. Что такое итератор и для чего он используется?
2. Какие основные категории итераторов вы знаете? Охарактеризуйте каждую.
3. В чём разница между `LegacyInputIterator` и `LegacyOutputIterator`? 
4. Что означает категория `LegacyContiguousIterator`? Чем отличается от `LegacyRandomAccessIterator`?
5. Какой итератор позволяет многократный проход по контейнеру?
6. Как получить итераторы для обратного прохода по C-массиву?
7. Как получить итератор на начало и конец контейнера?  
8. В чём преимущество `LegacyForwardIterator` перед `LegacyInputIterator`?
9. Как компилятор разворачивает синтаксис `for (auto x : container)`?
10. Как использовать `init-statement` в `range-based for` (начиная с C++20)?
11. Чем отличаются категории итераторов, используемых в
    `std::map`, `std::unordered_map`, `std::forward_list`, `std::deque`, `std::vector`?
12. Что такое инвалидация итераторов и в каких случаях она происходит?
13. Как реализовать пользовательский итератор для собственного контейнера?
14. В чём разница между итератором и указателем?

## Стандартные алгоритмы

1. Как алгоритмы стандартной библиотеки взаимодействуют с контейнерами? 
2. Сортировка элементов. Простая и стабильная сортировка. Алгоритмы частичной сортировки.
3. Подсчёт элементов, удовлетворяющих заданному критерию.
4. Поиск минимума и максимума.
5. Нахождение медианы и процентилей.
6. Поиск элементов. Последовательный. Двоичный поиск. Алгоритмы быстрого поиска всех вхождений подстроки в строке.
7. Копирование и преобразование элементов.
8. Алгоритмы над отсортированными множествами элементов: пересечение, объединение, разность множеств.
9. Какой тип итераторов требуется для алгоритма `std::copy`?
10. Для чего применяются проекции в `std::ranges::sort`?
11. В чём разница между `std::any_of` и `std::all_of`?
12. В чём заключается идиома erase-remove?
13. Что происходит с элементами, которые "удаляются" при использовании `std::remove`?  
14. Как при помощи алгоритма `std::copy` вывести элементы контейнера в обратном порядке?
15. Как использовать `std::transform` для преобразования списка id пользователей в список пользователей?
16. Что означают возвращаемые значения `std::lower_bound` и `std::upper_bound`?
17. Как определить, сколько раз встречается элемент в отсортированном контейнере?
18. Как реализовать копирование только нечётных чисел в новый контейнер?
19. Как проверить, является ли массив отсортированным?
20. Как найти медианное значение в контейнере?

## std::optional

1. Для чего нужен класс `std::optional`?
2. Как узнать, содержит ли объект `std::optional` значение?
3. Как получить доступ к значению?
4. Каковы основные преимущества `std::optional` по сравнению с указателями или возвратом кодов ошибок?
5. Какие ошибки могут возникнуть при работе с классом `std::optional`?
6. Напишите функцию, которая складывает два значения типа `optional<int>` и возвращает пустое значение,
   если хотя бы одно из слагаемых пустое, либо сумму чисел, если оба аргумента непустые.
7. Как проверить, содержит ли `std::optional` значение?
8. Что происходит при вызове `value()` для пустого `std::optional`?
9. Что делает метод `emplace`? Приведите пример его использования.
10. Что делает метод `value_or()`?
11. Как использовать `std::optional` для возврата результата поиска в контейнере?
12. Как реализовать отложенную инициализацию поля класса с помощью `std::optional`?
13. Что происходит с `std::optional` при его присваивании другому значению?

## Стандартные умные указатели

1. Что такое "use-after-free" и как умные указатели помогают избежать этой проблемы?
2. Что такое `std::unique_ptr` и когда его следует использовать?  
3. В чём разница между `std::unique_ptr` и `std::shared_ptr`? 
4. Что такое RAII и как он связан с умными указателями?  
5. Какой заголовочный файл содержит объявления `std::unique_ptr`, `std::shared_ptr` и `std::weak_ptr`? 
6. В каких случаях предпочтительнее использовать `std::make_unique` и `std::make_shared`
   по сравнению с вызовом `std::shared_ptr<Type>(new Type())`?
7. Как передать владение ресурсом из одного `std::unique_ptr` в другой?
8. Как использовать `std::unique_ptr` для управления массивом объектов?
9. Как создать в куче неинициализированный массив объектов и управлять им при помощи `std::unique_ptr`?
10. По какому принципу `std::shared_ptr` управляет временем жизни объекта?
11. Что такое "сильная" и "слабая" ссылка в контексте `std::shared_ptr`?
12. Как создать `std::shared_ptr` с пользовательским deleter-ом?
13. Какой узнать, содержит ли `std::shared_ptr` значение?
14. В чём назначение `std::weak_ptr` и какую проблему он решает?
15. Как получить `std::shared_ptr` из `std::weak_ptr`?
16. Что происходит с `std::weak_ptr`, если объект, на который он ссылается, был удалён?
17. Как проверить, существует ли объект, на который указывает `std::weak_ptr`? 
18. Приведите пример использования `std::weak_ptr`.
19. Зачем нужен класс `std::enable_shared_from_this`? Приведите пример его использования.
20. Что произойдёт, если вызвать `shared_from_this()` в конструкторе объекта?
21. В чём разница между `shared_from_this()` и `weak_from_this()`?
22. Как реализовать идиому Pimpl с использованием `std::unique_ptr`?
23. Приведите пример использования `std::unique_ptr` с пользовательским deleter-ом.
24. Какой оверхед несёт `std::shared_ptr` по сравнению с `std::unique_ptr`?
25. Какой подход выбрать для передачи умного указателя в функцию: по значению или по ссылке?
26. Как преобразовать `std::shared_ptr<Derived>` к `std::shared_ptr<Base>` и обратно?
27. Как внутри метода объекта, которым владеет `shared_ptr`, получить `shared_ptr`, ссылающийся на этот же самый объект?
    Для чего это может понадобиться?
28. Как на основе `shared_ptr`, который владеет на объектом-агрегатом (например, структурой),
    получить `shared_ptr` на составную часть агрегата (например, поле структуры)?
    При этом объект-агрегат должен жить, пока жив либо указатель на часть, либо указатель на целое.

## std::filesystem

1. Что такое `std::filesystem` и в каком заголовочном файле она определена?
2. В чём разница между `std::filesystem::path` и обычной строкой для работы с путями?
3. Как получить текущий рабочий каталог с помощью `std::filesystem`?
4. Как объединить два пути в одном объекте `std::filesystem::path`?
5. Как получить родительский каталог пути?  
6. Как извлечь имя файла из полного пути?  
7. Как получить расширение файла из пути?
8. В чём разница между методами `string()` и `generic_string()`?
9. Как проверить, существует ли файл или каталог?
10. Как получить размер файла с помощью `std::filesystem`?
11. Как создать новую директорию с помощью `std::filesystem`?
12. Как скопировать файл из одного пути в другой?
13. Как удалить файл или пустую директорию? 
14. Как удалить директорию с содержимым? 
15. Как обойти все файлы в директории?
16. Как обойти рекурсивно все файлы в директории,
17. Как нормализовать путь для разных ОС?
18. Как проверить, является ли путь корневым?
19. Как получить из абсолютного пути получить путь относительно некоторой директории?
20. Как узнать, пусть указывает на файл или на директорию?

## std::variant

1. Для чего нужен класс `std::variant`?
2. Как проверить, содержит ли std::variant значение нужного типа или нет?
3. Может ли std::variant не содержать значение?
4. Как с помощью `std::visit` обработать все допустимые значения внутри `std::variant`?
5. Для чего нужен `std::monotype`? Приведите пример.
6. Реализуйте операцию `StringOrInt operator+(const StringOrInt& a, const StringOrInt& b)`,
   где тип `StringOrInt` — это `std::variant<std::string, int>`.
   Сложение должно происходить по правилам языка JavaScript:
   1. 10 + 20 => 30
   2. 10 + "20" => "1020"
   3. "10" + 20 = "1020"
   4. "10" + "20" = "1020"

# Объектно-ориентированное программирование

## Общие сведения об объектно-ориентированном программировании

1. Что такое объектно-ориентированное программирование (ООП) и какие основные принципы его составляют?  
2. В чём разница между процедурным и объектно-ориентированным программированием? 
3. Что такое абстракция данных и как она помогает в проектировании программ?
4. Что такое инкапсуляция и как она реализуется в C++?
5. Как инкапсуляция упрощает разработку программ?
6. Что такое инварианты классы и как инкапсуляция способствует их сохранению?
7. Что такое наследование и для чего оно используется?
8. Что такое иерархия классов?
9. Что такое полиморфизм и как он реализуется в C++?
10. В чём разница между статическим и динамическим полиморфизмом?
11. Что такое абстрактный класс и как он используется в C++?
12. В чём разница между абстрактным классом и интерфейсом?
13. Как абстракция помогает в проектировании сложных систем?
14. В чём разница между композицией и наследованием? Приведите пример, где композиция предпочтительнее.

## Классы, данные и методы

1. Что такое класс в C++ и как он отличается от структуры?  
2. Из чего формируется состояние экземпляра класса?
3. Что такое инкапсуляция и как она реализуется?
4. Почему прямой доступ к полям класса через `public` считается плохой практикой? 
5. Что такое методы? Чем он отличается от обычной функции?
6. Как объявить метод класса внутри и вне тела класса?
7. Какие методы не могут быть вызваны у `const`-объекта?
8. Что такое константный методы и для чего они используются? 
9. В чём разница между физической и логической константностью?
10. Что нужно сделать, если требуется изменить значение поля класса внутри константных методов?
    Для чего этj можно использовать?
11. Как разделяется реализация класса между заголовочным и cpp-файлом?
12. Каким образом код внутри метода класса знает, у какого экземпляра класса он вызван?
13. В каких случаях в C++ обязательно использовать `this->`?
14. Что такое свойства и как они реализуются в C++?
15. Какой недостаток может быть у свойства, которое возвращает значение с побочными эффектами?
16. Какие спецификаторы уровня доступа есть в C++, в чем разница между ними?
17. Что такое статический метод класса и как он объявляется?  
18. В чём разница между статическим и нестатическим методом? 
19. Приведите пример вызова статического метода извне класса.
20. Что такое статическое поле и как оно отличается от обычного поля? 
21. Приведите примеры использования статических полей и методов.
22. Почему статические поля часто объявляются как `const`? 

## Жизненный цикл объекта

1. Что такое конструктор и для чего он используется?
2. В чём разница между конструктором и обычным методом класса? 
3. Что такое деструктор и когда он вызывается?
4. Какой синтаксис используется для объявления деструктора?
5. Что такое конструктор по умолчанию?
6. Как явно объявить конструктор по умолчанию в C++? 
7. В каких случаях компилятор автоматически генерирует конструктор по умолчанию?
8. В чём заключается проблема инициализации полей класса без конструктора по умолчанию?
9. Как вызвать конструктор с параметрами при создании объекта?
10. В чём разница между присвоением значений в теле конструктора и инициализацией в списке инициализации?
11. В каких случаях использование списка инициализации является обязательным?
12. Что такое конвертирующий конструктор?
13. В чём опасность неявного преобразования с помощью конвертирующего конструктора?
14. Для чего применяется explicit-конструктор? Когда следует делать конструктор explicit?
15. В каком порядке вызываются конструкторы базового и производного класса?
16. В каком порядке вызываются деструкторы полей класса?
17. Как порядок объявления полей влияет на их инициализацию и разрушение?
18. Что такое делегирующий конструктор и в чём его назначение?
19. В чём разница между обычным конструктором и делегирующим?
20. Почему нельзя указывать поля в списке инициализации делегирующего конструктора?
21. Какой конструктор выполняется первым — делегирующий или целевой?

## Копирование, присваивание и перемещение объектов

1. Что такое копирующий конструктор и как он объявляется?  
2. В чём разница между копирующим конструктором и обычным конструктором?  
3. Какой синтаксис используется для объявления копирующего конструктора?  
4. Что такое оператор присваивания и когда он вызывается?  
5. Какой тип ссылок используется для параметра копирующего конструктора?
6. В каких случаях компилятор автоматически генерирует копирующий конструктор?  
7. Что происходит, если класс содержит поле, не имеющее копирующего конструктора?
8. Когда автоматически сгенерированный копирующий конструктор не подходит?
9. Какая семантика у оператора присваивания?
10. Как запретить копирование и присваивание экземпляров класса?
11. Для чего применяется идиома copy and swap?
12. В чём заключается проблема "самоприсвоения" и как её избежать?
13. Чем копирование отличается от перемещения?
14. В каком случае перемещение может быть более оптимальным, чем копирование?
15. Что такое rvalue-ссылка и как она объявляется?
16. В чём разница между копирующим и перемещающим конструктором?
17. Как объявляется перемещающий конструктор?
18. Что делает функция std::exchange? Чем std::exchange отличается от std::swap?
19. В каком состоянии должен остаться объект после перемещения значения?
20. Приведите пример класса, где копирование невозможно, но перемещение полезно.

## Отношения между классами

1. Отношение композиции. Обозначение композиции на диаграмме классов.
2. Как композиция реализуется в C++?
3. Отношение агрегации. Обозначение агрегации на диаграмме классов.
4. Как агрегация реализуется в C++?
5. Чем композиция отличается от агрегации?
6. Что такое ассоциация и как она отображается на диаграммах классов? 
7. Как ассоциация отличается от композиции и агрегации?
8. Как композиция реализуется в коде на C++? Приведите пример.
9. Почему композиция считается более "сильной" связью, чем агрегация?
10. Как агрегация реализуется в коде? Приведите пример.  
11. Приведите пример двусторонней ассоциации между классами.
12. Зависимость. Обозначение зависимости на диаграмме классов.
13. В каких случаях возникает зависимость между классами? 
14. Объясните, почему зависимость транзитивна, в отличие от композиции.
15. Чем зависимость отличается от агрегации и композиции?
16. Когда применять зависимость, когда агрегацию, а когда композицию?

## Наследование

1. Смысл отношения наследования.
2. Что такое `базовый`, `родительский` и `производный` классы?
3. Обозначение наследования на диаграммах классов.
4. Вызов конструкторов и деструкторов при наследовании.
5. Каковы особенности публичного, приватного и защищённого наследования? Когда их следует применять?
6. К каким полям и методам класса может иметь доступ класс-наследник?
7. В каком случае возможно приведение типа вверх по иерархии классов. Как влияет тип наследования на приведение типа по иерархии наследования?
8. Что произойдёт, если в классе-наследнике будет объявлен метод с тем же именем, что в одном из его родителей?
9. Как класс-наследник может вызвать одноименный метод своего родителя?
10. Чем отличается  `class X final { /*...*/ };` от `class X { /*...*/ };`. Когда следует объявлять класс или структуру финальной?
11. Как в функцию `void F(Base&)` передать ссылку на объект класса `class Derived : private Base {...};`?

## Полиморфизм

1. Что такое виртуальные методы и для чего они нужны? Чем отличаются виртуальные методы от невиртуальных?
2. Как переопределить виртуальную функцию в производном классе?
3. Для чего в C++ деструктор объявляется виртуальным? В каких случаях деструктор не нужно объявлять виртуальным?
4. Особенности вызова виртуальных функций в конструкторе и деструкторе класса.
5. Как и для чего применяется спецификатор `override` у методов?
6. Как и для чего применяется спецификатор `final` у методов?
7. Может ли конструктор быть виртуальным?
8. Что такое полиморфизм?
9. Что такое абстрактный класс? Для чего он нужен?
10. Что такое интерфейс? Как объявить интерфейс в C++?
11. Чем отличается абстрактный класс от интерфейса?
12. Как наследование позволяет реализовывать полиморфизм времени выполнения?
13. Как в большинстве компиляторов реализованы виртуальные функции?
14. Приведение типа вниз по иерархии классов. Оператор `dynamic_cast`.

## Множественное наследование

1. Для чего применяется множественное наследование?
2. В каком порядке вызываются конструкторы и деструкторы при множественном наследовании?
3. Какие проблемы создаёт наследование от двух и более классов, которые имеют общего предка?
4. Для чего используется виртуальное наследование в C++? Как его применяют?
5. Как в C++ реализовать несколько интерфейсов?
6. Пусть класс `Derived` унаследован от несвязанных друг с другом классов `Base1` и `Base2`, в каждом из которых есть метод виртуальный метод `Foo()`. Как в `Derived` переопределить метод `Foo` класса `Base1`?
7. В чём заключается различие в структуре объекта при виртуальном и невиртуальном наследовании?

## Перегрузка арифметических операций и операций сравнения

1. Перегрузка присваивающих выражений: `+=`, `-=`, `*=`, `/=`.
2. Перегрузка бинарных арифметических операций: `+`, `-`, `*`, `/`.
3. Особенности перегрузки бинарных операций с разным типом аргументов.
4. Перегрузка унарного `+` и `-`.
5. Перегрузка операций сравнения: `<`, `>`, `<=`, `>=`, `==`, `!=`
6. Операция `<=>`. Типы ordering-а. default-реализация операции <=>.

## Перегрузка прочих операций

1. Перегрузка операций `<<` и `>>` для вывода в поток.
2. Перегрузка операции разыменования `*` и обращения к полю класса `->`. Для чего применяется?
3. Перегрузка операции индексации `[]`. Как перегрузить операцию `[]` для `чтения` и для `записи`.
4. Перегрузка операций `++` и `--`.
5. Перегрузка операций приведения типа.
6. Перегрузка операции вызова функции `()`. Для чего применяются?

## Обработка исключений

1. Выбрасывание исключения.
2. Перехват исключений заданного типа.
3. Перехват всех исключений.
4. Перевыброс пойманного исключения.
5. Особенности выбрасывания исключений в конструкторе и деструкторе класса
6. Как указать, что функция или метод не выбрасывают исключений?
7. Почему рекомендуется перемещающий конструктор и оператор присваивания делать не выбрасывающими исключений?
8. Что такое срезка? Как избежать срезки при обработке исключений?
9. Стандартные классы исключений.
10. Иерархия классов исключений.
11. Какие преимущества даёт возможность использовать классы в качестве объектов исключений?
12. Какие средства стандартной библиотеки позволяют узнать, что у класса или структуры конструктор копирования/перемещения не выбрасывает исключений.
13. Для чего служит класс `std::nested_exception`? Приведите пример использования.
14. Как перехватить все исключения стандартной библиотеки?

## Разработка кода, устойчивого к возникновению исключений

1. Какие существуют гарантии безопасности исключений? В чем они заключаются?
2. Принципы написания кода, устойчивого у возникновению исключений.
3. Идиома RAII (Resource acquisition is initialization)
4. Как обеспечить строгую гарантию безопасности исключений при реализации методов?
5. Как определить, какой уровень безопасности исключений предоставляет функция или метод?
6. Привести пример кода, небезопасного к возникновению исключений. Продемонстрировать, как обеспечить для этого кода базовую или строгую гарантию безопасности исключений.

## Шаблоны функций

1. Как объявить шаблон функции?
2. Может ли шаблонная функция не иметь аргументов?
3. Что может использоваться в качестве параметров шаблона? Приведите пример.
4. Для чего используется специализация шаблонов функций? Приведите пример специализации шаблонной функции.
5. Как объявить специализацию шаблонной функции?
6. Может ли специализация шаблонной функции сама быть шаблоном? Если да, приведите пример.
7. Как объявляются шаблонные операторы? Приведите пример.

## Шаблоны классов

1. Как объявить шаблон класса?
2. Как объявляется метод шаблонного класса вне класса?
3. Как объявляется шаблонный метод класса вне класса?
4. Как объявляется шаблонный метод шаблонного класса вне класса?
5. Чем отличается частичная и полная специализация шаблона класса. 
6. Как объявить частичную и полную специализацию шаблона класса?
7. Может ли виртуальный метод класса быть шаблонным?
8. Применение шаблонов при построении иерархий классов.

## Шаблоны с переменным числом аргументов

1. Как объявить функцию-шаблон с переменным количеством аргументов?
2. Как объявить класс-шаблон с переменным количеством аргументов?
3. Напишите шаблонную функцию Second, принимающую произвольное количество аргументов любого типа и возвращающую второй аргумент.
4. Как из шаблонной функции, принимающей произвольное число аргументов вызвать другую функцию с произвольным количеством аргументов и передать туда все аргументы?
5. Свёрточные выражения. Напишите шаблонную функцию `ApplyToMany`, которая принимает функциональный объект f и произвольное количество аргументов,
 а потом последовательно вызывает f с каждым из переданных аргументов.
6. Напишите шаблонную функцию `EqualsToOneOf`, принимающую один или более аргументов. Функция должна вернуть true, если ёё первый аргумент равен одному из остальных аргументов и false в противном случае.
7. Напишите шаблонную функцию Last, принимающую произвольное количество аргументов любого типа и возвращающую свой последний аргумент.
