# Лабораторная работа №3. Проектирование собственных классов

- [Лабораторная работа №3. Проектирование собственных классов](#лабораторная-работа-3-проектирование-собственных-классов)
  - [Практические задания](#практические-задания)
    - [Задание 1](#задание-1)
      - [Вариант 1 – Телевизор – 50 баллов](#вариант-1--телевизор--50-баллов)
        - [Формат входных данных](#формат-входных-данных)
        - [Формат выходных данных](#формат-выходных-данных)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных)
          - [Пример 1](#пример-1)
          - [Пример 2](#пример-2)
          - [Пример 3](#пример-3)
        - [Бонус в 10 баллов за возможность переключения на ранее просмотренный канал](#бонус-в-10-баллов-за-возможность-переключения-на-ранее-просмотренный-канал)
          - [Формат входных данных](#формат-входных-данных-1)
          - [Формат выходных данных](#формат-выходных-данных-1)
          - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-1)
        - [Бонус в 40 баллов за возможность задать имя для канала](#бонус-в-40-баллов-за-возможность-задать-имя-для-канала)
          - [Формат входных данных](#формат-входных-данных-2)
          - [Формат выходных данных](#формат-выходных-данных-2)
      - [Вариант 2 – Автомобиль – 150 баллов](#вариант-2--автомобиль--150-баллов)
        - [Сообщения об ошибках](#сообщения-об-ошибках)
          - [Сообщения, связанные с установкой передачи (SetGear)](#сообщения-связанные-с-установкой-передачи-setgear)
          - [Сообщения, связанные с установкой скорости (SetSpeed)](#сообщения-связанные-с-установкой-скорости-setspeed)
        - [Тестирование программы в системе Яндекс.Contest](#тестирование-программы-в-системе-яндексcontest)
        - [Примеры](#примеры)
          - [Пример 1: Включение двигателя и информация о состоянии](#пример-1-включение-двигателя-и-информация-о-состоянии)
          - [Пример 2: Установка первой передачи и проверка успешного изменения скорости](#пример-2-установка-первой-передачи-и-проверка-успешного-изменения-скорости)
          - [Пример 3: Уменьшение скорости на нейтральной передаче](#пример-3-уменьшение-скорости-на-нейтральной-передаче)
          - [Пример 4: Попытка выключить двигатель на ненулевой скорости](#пример-4-попытка-выключить-двигатель-на-ненулевой-скорости)
          - [Пример 5: Попытка установки передачи на неподходящей скорости](#пример-5-попытка-установки-передачи-на-неподходящей-скорости)
      - [Вариант 3 – Прямоугольник - 50 баллов](#вариант-3--прямоугольник---50-баллов)
    - [Задание 2 – Калькулятор – 300 баллов ](#задание-2--калькулятор--300-баллов-)
      - [Сообщения об ошибках](#сообщения-об-ошибках-1)
      - [Тестирование программы в системе Яндекс.Contest](#тестирование-программы-в-системе-яндексcontest-1)
      - [Примеры работы программы](#примеры-работы-программы)
        - [Пример 1: Базовая подстановка параметров](#пример-1-базовая-подстановка-параметров)
        - [Пример 2: Объявление функций](#пример-2-объявление-функций)
        - [Пример 3: Различие между fn и let](#пример-3-различие-между-fn-и-let)
        - [Пример 4: Вычисление площади круга](#пример-4-вычисление-площади-круга)
        - [Пример 5: Вычисление последовательности Фибоначчи](#пример-5-вычисление-последовательности-фибоначчи)
      - [Бонус в 100 баллов за оптимизацию вычислений функций](#бонус-в-100-баллов-за-оптимизацию-вычислений-функций)
      - [Бонус в 50 баллов за возможность вычисления очень больших последовательностей функций](#бонус-в-50-баллов-за-возможность-вычисления-очень-больших-последовательностей-функций)
    - [Задание 3](#задание-3)
      - [Вариант 1 — Эмуляция экономики — 300 баллов](#вариант-1--эмуляция-экономики--300-баллов)
        - [Бонус за добавление дополнительных персонажей — 100 баллов](#бонус-за-добавление-дополнительных-персонажей--100-баллов)
  - [Ссылки](#ссылки)

## Практические задания

На оценку «**удовлетворительно**» необходимо набрать **не менее 200 баллов**.

На оценку «**хорошо**» набрать **не менее 400 баллов**.

На оценку «**отлично**» набрать **не менее 600 баллов**.

### Задание 1

Выполните один из предложенных вариантов задания.

#### Вариант 1 – Телевизор – 50 баллов

Спроектируйте **с использованием TDD или BDD** класс `TVSet`, моделирующий телевизор,
который может находиться либо в выключенном, либо включенном состоянии.
Находясь во включенном состоянии, телевизор способен отображать один из 99 каналов (от 1 до 99).

Над телевизором можно выполнять следующие действия:

- Выключить. В выключенном состоянии нельзя переключать каналы.
- Включить. При своем включении телевизор включается на том канале, на котором он был ранее выключен.
При самом первом включении телевизор включается на первом канале.
- Выбрать заданный канал (от 1 до 99) или остаться на том же самом канале, если номер канала за пределами данного диапазона.

Телевизор обладает следующими свойствами:

- Включен или выключен
- Номер текущего канала. В выключенном состоянии номер текущего канала должен быть равен нулю,
и метод, возвращающий текущий канал, также должен возвращать 0, если телевизор выключен.

Разработайте программу, использующую разработанный Вами класс `TVSet`,
которая обрабатывает команды пользователя, вводимые им со стандартного потока ввода:

- **TurnOn**. Включает телевизор, если он был выключен
- **TurnOff**. Выключает телевизор, если он был включен
- **SelectChannel** *<номер канала>*. Выбирает указанный номер канала.
- **Info**. Выводит текущее состояние телевизора (выключен или включен, номер канала).

##### Формат входных данных

Синтаксис команды `TurnOn`:

```txt
TurnOn
```

Синтаксис команды `TurnOff`:

```txt
TurnOff
```

Синтаксис команды `Info`:

```txt
Info
```

Синтаксис команды `SelectChannel`:

```txt
SelectChannel НОМЕР_КАНАЛА
```

##### Формат выходных данных

- Команда `TurnOn`:

При успешном включении телевизора выводится:

```txt
TV is turned on
```

- Команда `TurnOff`:

При успешном выключении телевизора выводится:

```txt
TV is turned off
```

- Команда `SelectChannel`:

Если канал успешно переключён, выводится:

```txt
Channel switched to: <номер канала>
```

- Команда `Info`:

Если телевизор выключен, выводится:

```txt
TV is turned off
```

Если телевизор включён, выводится:

```txt
TV is turned on
Channel is: <номер канала>
```

- Ошибки:

Например, если введена некорректная команда или канал выходит за пределы допустимого диапазона, выводится:

```txt
ERROR
```

##### Примеры входных и выходных данных

###### Пример 1

Ввод:

```txt
TurnOn
Info
TurnOff
Info
```

Вывод:

```txt
TV is turned on
TV is turned on
Channel is: 1
TV is turned off
TV is turned off
```

Объяснение: Телевизор включается на 1-ом канале, затем выключается,
и информация о его состоянии отображается после каждой команды.

###### Пример 2

Ввод:

```txt
TurnOn
SelectChannel 5
Info
```

Вывод:

```txt
TV is turned on
Channel switched to: 5
TV is turned on
Channel is: 5
```

Объяснение: Телевизор включается и переключается на 5-й канал, после чего команда Info отображает текущий канал.

###### Пример 3

Ввод:

```txt
TurnOn
SelectChannel 100
Info
```

Вывод:

```txt
TV is turned on
ERROR
TV is turned on
Channel is: 1
```

Объяснение: Попытка переключить канал на 100 (недопустимый) вызывает ошибку, и телевизор остаётся на 1-ом канале.

##### Бонус в 10 баллов за возможность переключения на ранее просмотренный канал

Бонус присуждается за добавление в класс телевизора метода `SelectPreviousChannel()`,
выполняющего переключение телевизора на канал, на котором телевизор находился ранее, либо остаться на том же канале.
После выключения телевизора информация о предыдущем канале должна сохраняться.
Эта операция также доступна только у включенного телевизора.

Интерфейс пользователя должен поддерживать соответствующую команду, вводимую с `stdin`.

###### Формат входных данных

Синтаксис команды `SelectPreviousChannel`:

```txt
SelectPreviousChannel
```

###### Формат выходных данных

- Команда `SelectPreviousChannel`:

Если переключение на предыдущий канал успешно выполнено, выводится:

```txt
Switched to previous channel
```

- Ошибки:

Если переключение на предыдущий канал невозможно (например, если телевизор выключен или канал не менялся), выводится:

```txt
ERROR
```

###### Примеры входных и выходных данных

**Пример 1**:

Ввод:

```txt
TurnOn
SelectChannel 2
SelectChannel 5
SelectPreviousChannel
Info
```

Вывод:

```txt
TV is turned on
Channel switched to: 2
Channel switched to: 5
Switched to previous channel
TV is turned on
Channel is: 2
```

Объяснение: Телевизор включается, переключается на канал 2, затем на 5.
После команды SelectPreviousChannel возвращается на предыдущий канал 2. Команда Info выводит текущий канал - 2.

**Пример 2**:

Ввод:

```txt
TurnOn
SelectChannel 10
TurnOff
SelectPreviousChannel
TurnOn
SelectPreviousChannel
Info
```

Вывод:

```txt
TV is turned on
Channel switched to: 10
TV is turned off
ERROR
TV is turned on
Switched to previous channel
TV is turned on
Channel is: 1
```

Объяснение: Телевизор включается, переключается на канал 10, затем выключается.
Попытка выбрать предыдущий канал при выключенном телевизоре вызывает ошибку.
После включения телевизор успешно возвращается на канал 1.

**Пример 3**:

Ввод:

```txt
TurnOn
SelectPreviousChannel
Info
```

Вывод:

```txt
TV is turned on
ERROR
TV is turned on
Channel is: 1
```

Объяснение: Телевизор включается, но канал не переключался ранее,
поэтому попытка выбрать предыдущий канал приводит к ошибке.
Команда Info выводит текущий канал - это начальный канал 1.

##### Бонус в 40 баллов за возможность задать имя для канала

Реализовать возможность задания имени для канала с допустимым номером при помощи метода `SetChannelName(номер канала, имя)`.
Именем канала может являться непустая строка.
Имя канала может содержать пробелы, но не должно состоять из одних только пробелов.
Пробелы в начале и в конце имени канала, а также лишние пробелы в середине должны игнорироваться.

Добавить версию метода `SelectChannel`, принимающую строку, задающую имя канала.

Должна иметься возможность удалить имя канала при помощи метода `DeleteChannelName(имя канала)`,
узнать имя канала по его порядковому номеру при помощи метода `GetChannelName(номер канала)`,
а также получить номер канала по его имени при помощи метода `GetChannelByName(имя канала)`.

Все эти операции доступны только у **включенного** телевизора.

Если указанное имя уже было закреплено за другим каналом, то происходит смена ассоциации.
Если за текущим каналом ранее было закреплено другое имя, то старая ассоциация должна быть удалена.
Иными словами, с каждым каналом может быть связано не более одного имени.
Одному имени может соответствовать только один канал.

Интерфейс пользователя предоставлять возможность задавать и удалять имена каналов,
переключать каналы при помощи `SelectChannel` не только по номеру, но и имени.
Обновить формат вывода команды `Info`, чтобы выводился еще и список каналов,
с которыми ассоциированы имена, отсортированный в порядке возрастания номера канала:

```txt
1 – ОРТ
17 – Discovery
35 – Русский экстрим
```

###### Формат входных данных

Синтаксис команды `SetChannelName`:

```txt
SetChannelName НОМЕР_КАНАЛА ИМЯ_КАНАЛА
```

Синтаксис команды `DeleteChannelName`:

```txt
DeleteChannelName ИМЯ_КАНАЛА
```

Синтаксис команды `SelectChannel` (по имени):

```txt
SelectChannel ИМЯ_КАНАЛА
```

Синтаксис команды `GetChannelName`:

```txt
GetChannelName НОМЕР_КАНАЛА
```

Синтаксис команды `GetChannelByName`:

```txt
GetChannelByName ИМЯ_КАНАЛА
```

###### Формат выходных данных

- Команда `SetChannelName`:

Если имя канала успешно установлено, выводится:

```txt
Channel name set: <номер канала> – <имя канала>
```

- Команда `DeleteChannelName`:

Если имя канала успешно удалено, выводится:

```txt
Channel name deleted: <имя канала>
```

- Команда `SelectChannel` (по имени):

Если переключение на канал по имени выполнено успешно, выводится:

```txt
Channel switched to: <имя канала>
```

- Команда `GetChannelName`:

Если имя канала по заданному номеру существует, выводится:

```txt
Channel <номер канала> name: <имя канала>
```

- Команда `GetChannelByName`:

Если канал с заданным именем существует, выводится:

```txt
Channel for name <имя канала>: <номер канала>
```

- Команда `Info` (обновленный формат):

Если телевизор включен и существуют ассоциации каналов с именами, они выводятся после информации о текущем состоянии:

```txt
TV is turned on
Channel is: <номер канала>
<список каналов с именами>
```

Если каналов с именами нет, выводится только текущий канал:

```txt
TV is turned on
Channel is: <номер канала>
```

Если телевизор выключен, выводится:

```txt
TV is turned off
```

- Ошибки:

Если команда не может быть выполнена (например, из-за некорректного ввода,
попытки установить имя для недопустимого канала или попытки удалить несуществующее имя), выводится:

```txt
ERROR
```

**Пример 1**:

Ввод:

```txt
TurnOn
SetChannelName 5 OTP
SelectChannel OTP
Info
```

Вывод:

```txt
TV is turned on
Channel name set: 5 - OTP
Channel switched to: OTP
TV is turned on
Channel is: 5
5 - OTP
```

Объяснение: Телевизор включается, устанавливается имя "OTP" для канала 5,
переключение происходит на "OTP", и команда Info показывает текущий канал 5, а также все каналы с их именами.

**Пример 2**:

Ввод:

```txt
TurnOn
SetChannelName 3 MTV
GetChannelByName MTV
Info
DeleteChannelName MTV
GetChannelByName MTV
Info
```

Вывод:

```txt
TV is turned on
Channel name set: 3 - MTV
Channel for name MTV: 3
TV is turned on
Channel is: 1
3 - MTV
Channel name deleted: MTV
ERROR
TV is turned on
Channel is: 1
```

Объяснение: Телевизор включается, устанавливается имя "MTV" для канала 3,
и команда GetChannelByName возвращает номер канала 3.
Команда Info показывает текущий канал 1 и имя "MTV" для канала 3.
Затем имя "MTV" удаляется, и повторная попытка получить его номер приводит к ошибке.
Последняя команда Info показывает, что текущее состояние канала - 1, а имени для канала 3 больше нет.

**Пример 3**:

Ввод:

```txt
TurnOn
SetChannelName 7 National Geographic
SetChannelName 10 BBC
GetChannelName 7
GetChannelName 10
GetChannelByName National Geographic
GetChannelByName BBC
Info
```

Вывод:

```txt
TV is turned on
Channel name set: 7 - National Geographic
Channel name set: 10 - BBC
Channel 7 name: National Geographic
Channel 10 name: BBC
Channel for name National Geographic: 7
Channel for name BBC: 10
TV is turned on
Channel is: 1
7 - National Geographic
10 - BBC
```

Объяснение: Телевизор включается, устанавливаются имена "National Geographic" для канала 7 и "BBC" для канала 10.
Команды GetChannelName и GetChannelByName возвращают правильные имена и номера каналов.
Команда Info показывает текущий канал 1 и все каналы с их именами.

#### Вариант 2 – Автомобиль – 150 баллов

Разработать класс `Car`, моделирующий автомобиль в следующей предметной области.
Для разработанного класса должны быть также разработаны модульные тесты.

Двигатель автомобиля может находиться как во включенном состоянии, так и в выключенном.

В автомобиле может быть включена одна из следующих передач:

- Задний ход (-1)
- Нейтральная передача (0)
- Первая передача (1)
- Вторая передача (2)
- Третья передача (3)
- Четвертая передача (4)
- Пятая передача (5)

Каждая передача автомобиля имеет свой диапазон скоростей.

<table>
    <thead>
        <tr>
            <th>Передача</th>
            <th>Диапазон скоростей</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>Задний ход</th>
            <th>0 – 20</th>
        </tr>
        <tr>
            <th>Нейтраль</th>
            <th>Без ограничений</th>
        </tr>
        <tr>
            <th>Первая</th>
            <th>0 – 30</th>
        </tr>
        <tr>
            <th>Вторая</th>
            <th>20 – 50</th>
        </tr>
        <tr>
            <th>Третья</th>
            <th>30 – 60</th>
        </tr>
        <tr>
            <th>Четвертая</th>
            <th>40 – 90</th>
        </tr>
        <tr>
            <th>Пятая</th>
            <th>50 – 150</th>
        </tr>
    </tbody>
</table>

На каждой передаче можно развить скорость в пределах отведенного данной передаче диапазона.
**Исключение – нейтральная передача**, на которой скорость можно **только уменьшить (по модулю)**.

**При включенном двигателе** переключиться можно с любой передачи на любую при условии,
что текущая скорость автомобиля находится в диапазоне скоростей новой передачи,
и направление движения автомобиля допускает включение данной передачи. Например:

- на задний ход можно переключиться только **на нулевой скорости**;
  даже при движении назад на нейтральной передаче не допускается включать заднюю передачу.
- с заднего хода можно переключиться на переднюю передачу **только на нулевой скорости**;
- переключившись на заднем ходу на нейтральную передачу на ненулевой скорости,
  переключиться на переднюю передачу **можно только после остановки**

Двигатель данного автомобиля может быть **выключен** только при **нулевой** скорости на **нейтральной** передаче.
При выключенном двигателе переключиться можно только на нейтральную передачу. Как следствие,
автомобиль **после включения двигателя** находится на **нейтральной** передаче **в состоянии покоя**.

Автомобиль обладает следующими свойствами:

- Состояние двигателя (включен или выключен) – метод `IsTurnedOn()`
- Направление движения (вперед, назад или стоим на месте) – метод `GetDirection()`
- Текущая скорость движения (целое число от 0 до максимальной скорости) – метод `GetSpeed()`
- Текущая выбранная передача [-1..5] – метод `GetGear()`

Автомобиль может выполнять следующие действия:

- Включить двигатель (если он выключен). Возвращает `true`, если двигатель включился (или уже был включен).

```c++
bool TurnOnEngine()
```

- Выключить двигатель (если он включен и текущая передача – нейтральная, а автомобиль стоит).
  Возвращает true, если двигатель был успешно выключен (или уже был выключен), и false,
  если двигатель не может быть в данный момент выключен.

```c++
bool TurnOffEngine() 
```

- Выбрать указанную передачу [-1..5]. В случае успешного переключения передачи (в том числе и на саму себя) возвращает true.

```c++
bool SetGear(int gear) 
```

- Задать указанную скорость. Возвращает true, если скорость удалось изменить и false,
- если изменить скорость движения на указанную невозможно (например, на нейтральной передаче нельзя разогнаться).

```c++
bool SetSpeed(int speed) 
```

Альтернативная реализация:

```c++
void TurnOnEngine()
void TurnOffEngine()
void SetGear(int gear)
void SetSpeed(int speed)
```

Методы ничего не возвращают. При ошибке выкидывается исключение (`std::runtime_error`, `std::invalid_argument` и тд).

На основе данного класса разработать приложение, позволяющее пользователю управлять виртуальным автомобилем при помощи
следующих команд, вводимых со стандартного потока ввода:

- `Info`. Выводит состояние двигателя автомобиля, направление движения, скорость и передачу:
  - Состояние двигателя (`Engine`) должно выводиться в виде «on» либо «off»
  - Направление движения (`Direction`) выводится в виде: «forward», «backward» или «standing still»
  - Скорость (`Speed`) выводится по модулю. Например, при движении задом скорость должна выводиться
  в виде неотрицательного числа.
  - Передача (`Gear`) выводится в виде числа от -1 до 5
  - Пример вывода для команды `Info`:
  
     ```txt
     Engine: оn
     Direction: standing still
     Speed: 0
     Gear: 0
     ```

- `EngineOn`. Включает двигатель.
- `EngineOff`. Выключает двигатель.
- `SetGear` передача. Включает заданную передачу, заданную числом от -1 до 5.
- `SetSpeed` скорость. Устанавливает указанную скорость движения, заданную неотрицательным целым числом.

Для команд `EngineOn`, `EngineOff`, `SetGear` и `SetSpeed` какие-либо сообщения
должны выводиться только в случае возникновения ошибки. Они описаны ниже.

##### Сообщения об ошибках

В зависимости от ошибки в стандартный поток `stdout` должны выводиться следующие сообщения:

- Введена неизвестная команда: "Unknown command"
- Попытка выключить двигатель при ненулевой скорости или если текущая передача не нейтральная:
  "Сar must be stopped and in neutral gear"
- Неправильный формат аргумента для команд `SetGear` или `SetSpeed` (например, строка или нецелочисленное значение):  
  "Invalid command argument" – **перекрывает по приоритету все остальные сообщения, связанные с этими командами**

###### Сообщения, связанные с установкой передачи (SetGear)

- Передача из аргумента не находится в диапазоне -1..5
  (**перекрывает по приоритету все следующие сообщения для данной команды**): "Invalid gear"
- Попытка переключить передачу при выключенном двигателе: "Сannot set gear while engine is off"
- Попытка установить передачу, для которой текущая скорость не находится в пределах
  диапазона передачи (**двигатель включен**): "Unsuitable current speed"
- Попытка переключиться на задний ход (-1), когда скорость не равна 0 (**двигатель включен**):
  "Cannot reverse while moving"

###### Сообщения, связанные с установкой скорости (SetSpeed)

- Попытка установить отрицательное значение скорости (**перекрывает по приоритету все следующие сообщения для данной команды**):
  "Speed cannot be negative"
- Попытка установить скорость при выключенном двигателе: "Cannot set speed while engine is off"
- Попытка увеличить скорость на нейтральной передаче (**двигатель включен**): "Cannot accelerate on neutral"
- Попытка установить скорость, выходящую за допустимый диапазон для текущей передачи (**двигатель включен**):
  "Speed is out of gear range"

##### Тестирование программы в системе Яндекс.Contest

**Тестирование в Яндекс.Contest настроено только для программ, написанных на языке C++ стандарта C++20.**

Для корректного тестирования программы в системе Яндекс.Contest необходимо заархивировать файлы программы в **формат zip**
и загрузить архив в систему Яндекс.Contest,
**даже если решение состоит всего из одного файла**.
В архиве должны находиться только исходные файлы программы (**файлов среды разработки в архиве быть не должно**).

##### Примеры

###### Пример 1: Включение двигателя и информация о состоянии

Ввод:

```txt
EngineOn
Info
```

Вывод:

```txt
Engine: on
Direction: standing still
Speed: 0
Gear: 0
```

Объяснение: Включаем двигатель командой `EngineOn`. Затем запрашиваем состояние автомобиля с помощью `Info`:
двигатель включен, автомобиль стоит на месте, скорость 0, нейтральная передача.

###### Пример 2: Установка первой передачи и проверка успешного изменения скорости

Ввод:

```txt
EngineOn
SetGear 1
SetSpeed 15
Info
```

Вывод:

```txt
Engine: on
Direction: forward
Speed: 15
Gear: 1
```

Объяснение: Включаем двигатель, переключаемся на первую передачу командой `SetGear 1`.
Устанавливаем скорость 15 с помощью команды `SetSpeed 15`.
Проверяем текущее состояние: двигатель включен, автомобиль движется вперед, первая передача, скорость 15.

###### Пример 3: Уменьшение скорости на нейтральной передаче

Ввод:

```txt
EngineOn
SetGear 1
SetSpeed 30
SetGear 0
SetSpeed 10
Info
```

Вывод:

```txt
Engine: on
Direction: forward
Speed: 10
Gear: 0
```

Объяснение: Включаем двигатель, переключаемся на первую передачу и разгоняемся до 30.
Затем включаем нейтральную передачу и уменьшаем скорость до 10 –
на нейтральной передаче мы можем только снижать скорость, но не увеличивать её.
Проверяем, что двигатель включен, автомобиль движется вперед, нейтральная передача, скорость 10.

###### Пример 4: Попытка выключить двигатель на ненулевой скорости

```txt
EngineOn
SetGear 1
SetSpeed 10
EngineOff
```

Вывод:

```txt
Сar must be stopped and in neutral gear
```

Объяснение: Включаем двигатель, включаем первую передачу и устанавливаем скорость 10.
Пытаемся выключить двигатель командой `EngineOff`, но получаем сообщение об ошибке:
двигатель можно выключить только на нейтральной передаче и на нулевой скорости.

###### Пример 5: Попытка установки передачи на неподходящей скорости

```txt
EngineOn
SetGear 1
SetSpeed 19
SetGear 2
```

Вывод:

```txt
Unsuitable current speed
```

Включаем двигатель, включаем первую передачу, разгоняемся до 19.
Пробуем переключиться на вторую передачу, но получаем сообщение об ошибке:
текущая скорость не подходит для второй передачи, т.к. не находится в диапазоне от 20 до 50 км/ч.

#### Вариант 3 – Прямоугольник - 50 баллов

Разработайте **с использованием TDD** класс CRectangle, моделирующий сущность «Прямоугольник».

Прямоугольник обладает следующими свойствами (т.к. в C++ отсутствует поддержка свойств, следует вместо них использовать соответствующие `Get*` и `Set*` методы.) (не путать с членами-данными (используйте тот набор переменных-членов класса, который необходим и достаточен для реализации упомянутых свойств)):

- Ширина (width), доступна как для чтения, так и для записи
- Высота (height), доступна как для чтения, так и для записи
- Координата X левого края (Left), доступна как для чтения, так и для записи
- Координата Y верхнего края (Top), доступна как для чтения, так и для записи
- Координата X правого края (Right), доступна как для чтения, так и для записи
- Координата Y нижней стороны (Bottom), доступна как для чтения, так и для записи
- Площадь (Area), доступна только для чтения
- Периметр (Perimeter), доступен только для чтения

Координаты и размеры прямоугольника **задаются целыми числами**.

Ширина и высота

Размеры (ширина и высота) прямоугольника не могут быть отрицательными (конструкторе и set-методах следует заменять отрицательные размеры на 0).

![rectangle](images/rectangle.png)

Конструктор данного класса принимает координаты левого верхнего угла прямоугольника, а также его ширину и высоту.

Над прямоугольником можно выполнить следующие действия:
- Перенести вдоль заданного вектора на dx и dy, не изменяя размеров прямоугольника

```c++
void Move(int dx,int dy) 
```

- Отмасштабировать прямоугольник с использованием масштабных коэффициентов sx и sy. При масштабировании координаты левого верхнего угла прямоугольника остаются без изменения, а изменяется только его размер. Если sx или sy является отрицательным числом, то масштабирования не происходит

```c++ 
void Scale(int sx, int sy) 
```

- Найти пересечение данного прямоугольника с другим прямоугольником. Данный метод возвращает `true`, если прямоугольники пересекаются, и изменяет характеристики текущего прямоугольника. Если прямоугольники не пересекаются, то данный метод возвращает `false` и сбрасывает ширину и высоту прямоугольника в 0 (координаты верхнего левого угла остаются без изменений).

```c++
bool Intersect(CRectangle const& other) 
```

Разработать на основе данного класса программу, выполняющую считывание двух текстовых файлов, имена которых передаются программе через параметры командной строки, содержащих произвольное количество команд (по одной команде в каждой строке), управляющих размерами и трансформациями двух прямоугольников.

- `Rectangle <left> <top> <width> <height>`. Инициализирует текущий прямоугольник указанными координатами и размерами.
- `Move <dx> <dy>`. Переносит текущий прямоугольник вдоль заданного вектора, не изменяя его размеров
- `Scale <sx> <sy>`. Масштабирует (увеличивает в указанное количество раз ширину и высоту) текущий прямоугольник с использованием масштабных коэффициентов относительно его верхнего левого угла

До первого появления команды Rectangle в файле текущий прямоугольник **имеет нулевые размеры и нулевые координаты верхнего левого угла**.

После выполнения команд, задаваемых в текстовых файлах программа должна вывести в стандартный поток вывода координаты и размеры прямоугольников после применения указанных преобразований, их периметр и площадь, а также результат их пересечения в следующем формате:

```txt
Rectangle 1:
    Left top: (<left1>; <top1>)
    Size: <width1>*<height1>
    Right bottom: (<right1>; <bottom1>)
    Area: <area1>
    Perimeter: <perimeter1>
Rectangle 2:
    Left top: (<left2>; <top2>)
    Size: <width2>*<height2>
    Right bottom: (<right2>; <bottom2>)
    Area: <area2>
    Perimeter: <perimeter2>
Intersection rectangle:
    Left top: (<left>; <top>)
    Size: <width>*<height>
    Right bottom: (<right>; <bottom>)
    Area: <area>
    Perimeter: <perimeter>
```

<span style="color:gray">**Бонус  в 50 баллов за визуализацию исходных прямоугольников и результата их пересечения**</span> <a name="1-3-b-1"></a>

Разработайте класс `CCanvas`, моделирующий прямоугольное растровое полотно для рисования в текстовом режиме, а также метод `FillRectangle`, выполняющий закрашивание области, соответствующей прямоугольнику на данном полотне.

Каркас класса `CCanvas` представлен ниже:

```c++
/*
 Класс, моделирующий сущность Canvas (полотно, холст для рисования, картинка, канва),
 хранящую прямоугольный массив пикселей. Для каждого пикселя изображения можно задать
 свой код символа, что позволяет выводить простейшие картинки в текстовом режиме, вроде таких:

  +----+
 /    /|
+----+ |
|    | +
|    |/
+----+
*/
class CCanvas
{
public:
    // Создает канву для рисования размером width*height
    // После своего создания содержимое канвы заполнено пробельными символами
    // Допускается создание канвы нулевых размеров
    CCanvas(unsigned width, unsigned height);

     // Возвращает ширину канвы
     unsigned GetWidth()const;

     // Возвращает высоту канвы
     unsigned GetHeight()const;

     // Очищает канву (заполняет содержимое символами с указанным кодом)
     // Если код символа находится в диапазоне от 0 до ' ', команда игнорируется
     void Clear(char code = ' ');

     // Задает код символа code для пикселя в координатах (x, y)
     // Координаты верхнего левого угла канвы принимаются равными 0, 0.
     // Если координаты выходят за пределы канвы, либо код символа 
     // находится в диапазоне от 0 до (' ' - 1), содержимое канвы не должно меняться
     void SetPixel(int x, int y, char code);

     // Возвращает код символа пикселя в координатах (x, y)
     // Координаты верхнего левого угла канвы принимаются равными 0, 0.
     // Если координаты пикселя выходят за пределы канвы, должен возвращаться
     // код символа "пробел"
     char GetPixel(int x, int y)const;

     // Выводит содержимое в поток вывода, производный от std::ostream 
     // (например, std::cout, экземпляр ofstream, или ostringstream)
     // В конце каждой строки должен выводиться символ \n
     void Write(std::ostream & ostream)const;
private:
    // Закрытые данные и методы класса
};
```

Объявление функции FillRectangle представлено ниже

```c++
// Заполняет пиксели, соответствующие прямоугольнику rect в канве,
// символом с кодом code
void FillRectangle(CRectangle const& rect, char code, CCanvas & canvas);
```

Первый прямоугольник должен быть отображен при помощи символов “`+`”, второй – при помощи символа “`-`“, а результат их пересечения – при помощи символа “`#`”. На следующем рисунке показан ожидаемый результат работы программы при следующих входных данных:

- Прямоугольник 1. Left: 5, Top: 2, Width: 9, Height: 5
- Прямоугольник 2. Left: 11, Top: 5, Width: 14, Height: 4

![rectangle-intersection](images/rectangle-intersection.png)

Программа должна вывести визуальный результат пересечения прямоугольников в файл,
имя которого передано в качестве 3-го аргумента командной строки,
а при отсутствии 3-го аргумента – в стандартный поток вывода
(сразу после текстовой информации, указанной в обязательной части задания).
В обоих случаях принят размер полотна для рисования равным 60 * 20.

### Задание 2 – Калькулятор – 300 баллов <a name="2"></a>

Разработать **с использованием подхода TDD** программу «Калькулятор», позволяющую выполнять простейшие
арифметические операции над переменными и пользовательскими функциями.  
Спроектируйте классы, моделирующие основные сущности предметной области, и напишите для них тесты.

Нарисуйте диаграмму классов получившейся программы (можно использовать программу [draw.io](https://www.drawio.com/),
[mermaid](https://mermaid.js.org/) или аналоги, а также нарисовать на бумаге).

Входные данные поступают из `stdin`. Работа программы завершается при обнаружении конца файла.
Каждая строка содержит одну из следующих команд:

- `var <идентификатор>`

  **Объявляет переменную** типа double с именем <идентификатор>. Идентификатор **не должен совпадать** ни с одним из
  **ранее объявленных** имен переменных и функций. Значение переменной после ее объявления не определено
  (использовать значение `nan` для этих целей)

- `let <идентификатор1> = <число с плавающей запятой>` либо

  `let <идентификатор1> = <идентификатор2>`.

  Присваивает **переменной** с именем *<идентификатор1>* числовое значение, либо **текущее значение ранее объявленного**
   идентификатора с именем *<идентификатор2>*. Если переменная с именем *<идентификатор1>* не была ранее объявлена,
   происходит объявление новой переменной. В качестве *<идентификатора1>* не может выступать имя функции.
- `fn <идентификатор1> = <идентификатор2>` либо

  `fn <идентификатор1> = <идентификатор2><операция><идентификатор3>`

  Объявляет новую функцию с ранее **необъявленным именем** *<идентификатор1>*, значением которой будет либо значение
  идентификатора *<идентификатор2>*, либо результат применения одной из следующих бинарных операций к значениям
  **ранее объявленных** идентификаторов *<идентификатор2>* и *<идентификатор3>* **в момент вычисления значения функции**:
  - `+`. Сложение.
  - `-`. Вычитание.
  - `*`. Умножение
  - `/`. Деление

  Если значение хотя бы одного из операндов операции не определено, результатом операции должно быть неопределенное значение.

- `print <идентификатор>`

  Выводит в `stdout` значение **ранее объявленного** идентификатора. Если идентификатором являлась переменная, то
  выводится ее значение, а если функция, то выводится вычисленное значение функции.
  Если при вычислении функции произошло **деление на ноль**, её
  значение считается неопределенным (**nan**), а сообщение об ошибке не выводится.  
  **Значение идентификатора
  выводится с точностью в 2 знака** после запятой. В случае, когда значение идентификатора не определено, должно быть
  выведено **nan**.
- `printvars`

  Выводит в `stdout` имена и значения всех ранее объявленных переменных, **отсортированных по алфавиту**, по одному в
   каждой строке в следующем формате:

  `<идентификатор>:<значение>` – **без каких-либо пробелов и табуляций**

  Значение переменной выводится с точностью **2 знака после запятой**. Если значение переменной не определено, должно
  быть выведено **nan**. Если ни одной переменной не было объявлено к моменту выполнения команды `printvars`,
  в `stdout` выводиться ничего не должно.
- `printfns`

  Выводит в `stdout` имена и значения всех ранее объявленных функций, **отсортированных по алфавиту**,
  по одному в каждой строке в следующем формате:

  `<идентификатор>:<значение>` – **без каких-либо пробелов и табуляций**

  Значение функции выводится с точностью в **2 знака после запятой**. Если значение функции не определено, должно быть
  выведено **nan**.
  Если при вычислении функции произошло **деление на ноль**, её
  значение считается неопределенным (**nan**), а сообщение об ошибке не выводится.  
  Если ни одной функции не было объявлено к моменту выполнения команды `printfns`, в `stdout`
  выводиться ничего не должно

**Идентификатором** является непустая строка, в которой допускается использовать буквы английского алфавита,
цифры и символ подчеркивания. Идентификатор не может начинаться с цифры. Идентификаторы используются в качестве
имен переменных и функций.

Программа должна корректно распознавать операнды как в слитном виде (например, `fn XPlusY=x+y`),  
так и через пробел (`fn XPlusY = x + y`). Оба варианта записи должны приводить к одинаковым результатам,  
и программа должна корректно интерпретировать их при объявлении переменных и функций.

#### Сообщения об ошибках

В случае ошибки команда игнорируется, а в стандартный поток `stdout` выводятся следующие сообщения:

- Если введена неизвестная команда: "Unknown command"
- Если синтаксис введенной команды не удовлетворяет правилам (в том числе недопустимый идентификатор): "Invalid usage"
- Если переменная с таким именем уже была объявлена: "Name already exists"
- Если в команде используется необъявленная переменная: “Name does not exist”

#### Тестирование программы в системе Яндекс.Contest

**Тестирование в Яндекс.Contest настроено только для программ, написанных на языке C++ стандарта C++20.**

Для корректного тестирования программы в системе Яндекс.Contest необходимо заархивировать файлы программы в **формат zip**
и загрузить архив в систему Яндекс.Contest,
**даже если решение состоит всего из одного файла**.
В архиве должны находиться только исходные файлы программы (**файлов среды разработки в архиве быть не должно**).

#### Примеры работы программы

##### Пример 1: Базовая подстановка параметров

<table>
     <thead>
          <tr>
               <th>stdin</th>
               <th>stdout</th>
               <th>Пояснение</th>
          </tr>
     </thead>
     <tbody>
          <tr>
               <td>var x</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>print x</td>
               <td>nan</td>
               <td>Значение переменной x пока не определено</td>
          </tr>
          <tr>
               <td>let x=42</td>
               <td></td>
               <td>Присваиваем переменной x значение 42</td>
          </tr>
          <tr>
               <td>print x</td>
               <td>42.00</td>
               <td></td>
          </tr>
          <tr>
               <td>let x=1.234</td>
               <td></td>
               <td>Значение переменной можно изменить</td>
          </tr>
          <tr>
               <td>print x</td>
               <td>1.23</td>
               <td>Значение выводится с точностью 2 знака после запятой</td>
          </tr>
          <tr>
               <td>let y=x</td>
               <td></td>
               <td>Автоматически объявляем переменную y и присваиваем ей текущее значение x</td>
          </tr>
          <tr>
               <td>let x=99</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>printvars</td>
               <td>x:99.00
                   <br>y:1.23</td>
               <td>Переменная y хранит присвоенное ей значение x. Последующие манипуляции над x не оказывают на нее влияния.</td>
          </tr>
     </tbody>
</table>

##### Пример 2: Объявление функций

<table>
     <thead>
          <tr>
               <th>stdin</th>
               <th>stdout</th>
               <th>Пояснение</th>
          </tr>
     </thead>
     <tbody>
          <tr>
               <td>var x</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>var y</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn XPlusY=x+y</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>print XPlusY</td>
               <td>nan</td>
               <td>Значение функции не определено, т.к. не определены значения ее аргументов</td>
          </tr>
          <tr>
               <td>let x=3</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>let y=4</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>print XPlusY</td>
               <td>7.00</td>
               <td>Теперь значение функции определено</td>
          </tr>
          <tr>
               <td>let x=10</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>print XPlusY</td>
               <td>14.00</td>
               <td>Значение функции зависит от значений ее аргументов</td>
          </tr>
          <tr>
               <td>let z=3.5</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn XPlusYDivZ=XPlusY/z</td>
               <td></td>
               <td>Значение функции может зависеть не только от значений переменных, но и от значений других функций</td>
          </tr>
          <tr>
               <td>printfns</td>
               <td>XPlusY:14.00
                   <br>XPlusYDivZ:4.00</td>
               <td>Значения функций выводятся в алфавитном порядке</td>
          </tr>
     </tbody>
</table>

##### Пример 3: Различие между fn и let

<table>
     <thead>
          <tr>
               <th>Stdin</th>
               <th>stdout</th>
               <th>Пояснение</th>
          </tr>
     </thead>
     <tbody>
          <tr>
               <td>let v=42</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>let variable=v</td>
               <td></td>
               <td>variable хранит значение v (42)</td>
          </tr>
          <tr>
               <td>fn function=v</td>
               <td></td>
               <td>function хранит действие, которое будет вычислено при получении значения функции</td>
          </tr>
          <tr>
               <td>let v=43</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>print variable</td>
               <td>42.00</td>
               <td></td>
          </tr>
          <tr>
               <td>print function</td>
               <td>43.00</td>
               <td>Значением function будет значение переменной v, вычисленное в момент вызова функции (а не ее объявления)</td>
          </tr>
     </tbody>
</table>

##### Пример 4: Вычисление площади круга

<table>
     <thead>
          <tr>
               <th>Stdin</th>
               <th>stdout</th>
               <th>Пояснение</th>
          </tr>
     </thead>
     <tbody>
          <tr>
               <td>var radius</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>let pi=3.14159265</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn radiusSquared=radius*radius</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn circleArea=pi*radiusSquared</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>let radius=10</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>print circleArea</td>
               <td>314.16</td>
               <td></td>
          </tr>
          <tr>
               <td>let circle10Area=circleArea</td>
               <td></td>
               <td>circle10Area хранит значение функции circleArea, вычисленной при radius=10</td>
          </tr>
          <tr>
               <td>let radius=20</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>let circle20Area=circleArea</td>
               <td></td>
               <td>circle20Area хранит значение функции circleArea, вычисленной при radius=20</td>
          </tr>
          <tr>
               <td>printfns</td>
               <td>circleArea:1256.64
                   <br>radiusSquared:400.00</td>
               <td></td>
          </tr>
          <tr>
               <td>printvars</td>
               <td>circle10Area:314.16
                   <br>circle20Area:1256.64
                   <br>pi:3.14
                   <br>radius:20.00</td>
               <td></td>
          </tr>
     </tbody>
</table>

##### Пример 5: Вычисление последовательности Фибоначчи

<table>
     <thead>
          <tr>
               <th>Stdin</th>
               <th>stdout</th>
               <th>Пояснение</th>
          </tr>
     </thead>
     <tbody>
           <tr>
               <td>let v0=0</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>let v1=1</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib0=v0</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib1=v1</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib2=fib1+fib0</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib3=fib2+fib1</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib4=fib3+fib2</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib5=fib4+fib3</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib6=fib5+fib4</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>printfns</td>
               <td>fib0:0.00
                   <br>fib1:1.00
                   <br>fib2:1.00
                   <br>fib3:2.00
                   <br>fib4:3.00
                   <br>fib5:5.00
                   <br>fib6:8.00</td>
               <td></td>
          </tr>
          <tr>
               <td>let v0=1</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>let v1=1</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>printfns</td>
               <td>fib0:1.00
                   <br>fib1:1.00
                   <br>fib2:2.00
                   <br>fib3:3.00
                   <br>fib4:5.00
                   <br>fib5:8.00
                   <br>fib6:13.00</td>
               <td></td>
          </tr>
     </tbody>
</table>

#### Бонус в 100 баллов за оптимизацию вычислений функций

Наивный подход к вычислению значений функций может в ряде случаев приводить к экспоненциальной вычислительной сложности.
Например, попытка вычислить значение хотя бы 50-го числа последовательности Фибоначчи, заданного в виде «рекурсивной»
последовательности функций, потребует весьма продолжительного времени. Придумайте способ, позволяющий значительно
сократить вычислительную сложность алгоритма в таких ситуациях.

Пример с вычислением 50-го числа последовательности Фибоначчи:

<table>
     <thead>
          <tr>
               <th>Stdin</th>
               <th>stdout</th>
               <th>Пояснение</th>
          </tr>
     </thead>
     <tbody>
           <tr>
               <td>let v0=0</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>let v1=1</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib0=v0</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib1=v1</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib2=fib1+fib0</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib3=fib2+fib1</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib4=fib3+fib2</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>...</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>fn fib50=fib49+fib48</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>print fib50</td>
               <td>12586269025.00</td>
               <td>Наивный подход без оптимизации вычисления значений функций может занять несколько минут,
               прежде чем будет посчитано 50-ое число Фибоначчи</td>
          </tr>
          <tr>
               <td>let v0=1</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>print fib50</td>
               <td>20365011074.00</td>
               <td></td>
          </tr>
     </tbody>
</table>

#### Бонус в 50 баллов за возможность вычисления очень больших последовательностей функций

Использование рекурсии в процессе вычислений функций с большой глубиной вычислений (десятки или сотни тысяч) может
привести к переполнению стека (win32-приложениям по умолчанию доступно около 2МБ стека). Придумайте способ решить
проблему с переполнением стека из-за глубокой рекурсии, не изменяя размер стека в настройках компоновщика.

Пример входных данных, которые потенциально могут приводить к указанной проблеме:

<table>
     <thead>
          <tr>
               <th>stdin</th>
               <th>stdout</th>
               <th>Пояснение</th>
          </tr>
     </thead>
     <tbody>
          <tr>
               <td>let x=1
                   <br>fn x2=x+x
                   <br>fn x3=x2+x
                   <br>fn x4=x3+x
                   <br>fn x5=x3+x
                   <br>…
                   <br>fn x1000000=x999999+x</td>
               <td></td>
               <td>Объявляется большая последовательность функций, каждая из которых прибавляет x к значению предыдущей функции.</td>
          </tr>
          <tr>
               <td>print x1000000</td>
               <td>1000000.00</td>
               <td>Наивное рекурсивное вычисление функции x1000000 может привести к переполнению стека.</td>
          </tr>
          <tr>
               <td>let x=2</td>
               <td></td>
               <td></td>
          </tr>
          <tr>
               <td>print x1000000</td>
               <td>2000000.00</td>
               <td></td>
          </tr>
     </tbody>
</table>

### Задание 3

#### Вариант 1 — Эмуляция экономики — 300 баллов

Напишите программу, которая симулирует работу экономики в отдельно взятом городке.
Для сдачи программы обязательно нужно посмотреть UML-диаграмму классов.

Изначально в экономике находится некоторое количество наличных денег,
распределённых между её гражданами в некоторой пропорции (например, равномерно).

Граждане могут открывать и закрывать счёт в банке, помещать деньги на своё счёт (Deposit)
и снимать деньги со своего счёта (Withdraw).
Банк учитывает количество денег в наличном обороте при снятии денег и помещении на счёт.
Поэтому нельзя поместить деньги на счёт больше, чем имеется в наличии.

Можно переводить деньги со своего счёта на счёт другого человека.
Перевод денег должен выполняться транзакционно: если некоторая сумма была зачислена на счёт получателя,
то эта же сумма должна быть списана со счёта отправителя.
В случае ошибки при переводе количество денег на счетах отправителя и получателя должно
откатываться к значениям до операции.

Для этого разработайте класс `Bank` со следующими методами:

```cpp
using AccountId = unsigned long long;
using Money = long long;

// Это исключение должно выбрасываться в случае ошибок
class BankOperationError : std::runtime_error
{
public:
  using runtime_error::runtime_error;
};

// Контролирует все деньги в обороте (как наличные, так и безналичные)
class Bank
{
public:
  // Инициализирует монетарную систему. cash — количество денег в наличном обороте
  // При отрицательном количестве денег, выбрасывается BankOperationError
  explicit Bank(Money cash);

  Bank(const Bank&) = delete;
  Bank& operator=(const Bank&) = delete;

  // Перевести деньги с исходного счёта (srcAccountId) на целевой (dstAccountId)
  // Нельзя перевести больше, чем есть на исходном счёте
  // Нельзя перевести отрицательное количество денег
  // Исключение BankOperationError выбрасывается, при отсутствии счетов или
  // недостатке денег на исходном счёте
  // При отрицательном количестве переводимых денег выбрасывается std::out_of_range
  void SendMoney(AccountId srcAccountId, AccountId dstAccountId, Money amount);

  // Перевести деньги с исходного счёта (srcAccountId) на целевой (dstAccountId)
  // Нельзя перевести больше, чем есть на исходном счёте
  // Нельзя перевести отрицательное количество денег
  // При нехватке денег на исходном счёте возвращается false
  // Если номера счетов невалидны, выбрасывается BankOperationError
  // При отрицательном количестве денег выбрасывается std::out_of_range
  [[nodiscard]] bool TrySendMoney(AccountId srcAccountId, AccountId dstAccountId, Money amount);

  // Возвращает количество наличных денег в обороте
  [[nodiscard]] Money GetCash() const;

  // Сообщает о количестве денег на указанном счёте
  // Если указанный счёт отсутствует, выбрасывается исключение BankOperationError
  Money GetAccountBalance(AccountId accountId) const;

  // Снимает деньги со счёта. Нельзя снять больше, чем есть на счете
  // Нельзя снять отрицательное количество денег
  // Снятые деньги переходят добавляются к массе наличных денег
  // При невалидном номере счёта или отсутствии денег, выбрасывается исключение BankOperationError
  // При отрицательном количестве денег выбрасывается std::out_of_range
  void WithdrawMoney(AccountId account, Money amount);

  // Попытаться снять деньги в размере amount со счёта account.
  // Объем денег в наличном обороте увеличивается на величину amount
  // При нехватке денег на счёте возвращается false, а количество наличных денег остаётся неизменным
  // При невалидном номере аккаунта выбрасывается BankOperationError.
  // При отрицательном количестве денег выбрасывается std::out_of_range
  [[nodiscard]] bool TryWithdrawMoney(AccountId account, Money amount);

  // Поместить наличные деньги на счёт. Количество денег в наличном обороте
  // уменьшается на величину amount.
  // Нельзя поместить больше, чем имеется денег в наличном обороте
  // Нельзя поместить на счёт отрицательное количество денег
  // Нельзя поместить деньги на отсутствующий счёт
  // При невалидном номере аккаунта или нехватке наличных денег в обороте выбрасывается BankOperationError.
  // При отрицательном количестве денег выбрасывается std::out_of_range
  void DepositMoney(AccountId account, Money amount);

  // Открывает счёт в банке. После открытия счёта на нём нулевой баланс.
  // Каждый открытый счёт имеет уникальный номер.
  // Возвращает номер счёта
  [[nodiscard]] AccountId OpenAccount();

  // Закрывает указанный счёт.
  // Возвращает количество денег, которые были на счёте в момент закрытия
  // Эти деньги переходят в наличный оборот
  [[nodiscard]] Money CloseAccount(AccountId accountId);
};
```

Для класса `Bank` должны быть разработаны юнит тесты.

Методы класса `Bank` должны быть безопасными с точки зрения исключений:
предоставлять гарантию безопасности не ниже базовой
(см. [лекцию про обработку исключений](https://youtu.be/hZcOnNmUFKE) и [лекцию про безопасность исключений](https://youtu.be/Gc12f_1fZic)).

Во время сдачи лабораторных работу нужно обосновать, что ваш код безопасен с точки зрения исключений.

Разработайте приложение, в котором ряд [акторов](https://ru.wikipedia.org/wiki/%D0%90%D0%BA%D1%82%D0%BE%D1%80_(%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%BD%D0%B0%D1%83%D0%BA%D0%B8))
участвуют в экономике.
Каждый из акторов на очередном шаге симуляции выполняет действия в соответствии со следующим сценарием:

- Гомер, отец семейства. Гомер работает на электростанции.
  Он регулярно выдаёт некоторую сумму денег своей жене Мардж. Перевод осуществляет путём перевода денег на карту Мардж.
  Некоторую сумму денег Гомер платит за электричество в доме.
  
  Также Гомер регулярно снимает наличные деньги со счёта и даёт их своим детям: Барту и Лизе.

  ![Homer](images/homer.png)
- Мардж, жена Гомера, домохозяйка. Покупает продукты у Апу, владельца супермаркета.
  При покупке переводит деньги на счёт Апу в банке.

  ![Marge](images/marge.png)
- Барт и Лиза, когда у них есть наличные деньги, тратят их небольшими порциями на покупку
  товаров у Апу.
  У них нет банковской карты, поэтому они расплачиваются с Апу наличкой.

  ![Bart](images/bart.png)![Lisa](images/lisa.png)
- Апу, владелец супермаркета. Регулярно платит за электроэнергию электростанции,
  на которой работает Гомер.
  Когда у Апу появляются наличные деньги, они помещает их на свой счёт в банке.

  ![Apu](images/apu.png)
- Владелец электростанции Мистер Бернс, на которой работает Гомер, регулярно платит ему зарплату из тех денег,
  которые перечисляют ему за электричество.

  ![Burns](images/burns.png)

В процессе симуляции возможна ситуация, когда у кого-то из участников не будет достаточного количества денег.
В этом случае он должен пропустить ход.

Для каждого из персонажей спроектируйте классы, моделирующие его поведение. Проверьте юнит-тестами.

В процессе симуляции в stdout должна выводиться диагностическая информация о действиях, выполняемых участниками.

Симуляция заканчивается спустя некоторое количество шагов, передаваемых приложению с командной строки:

```bash
economy [NUM_ITERATIONS]
```

Если количество итераций не передано с командной строки, его надо считать из stdin.

В конце работы приложение должно вывести количество денег на счетах и в карманах участников,
а также удостовериться в том, что банковская система находится в согласованном состоянии:

- Сумма наличных денег у персонажей совпадает с суммой наличных денег, зарегистрированных в банке.
- Общая сумма всех наличных и безналичных денег на счетах равна сумме, которая изначально была положена в банк в виде наличных.

##### Бонус за добавление дополнительных персонажей — 100 баллов

- Хулиган Нельсон. Время от времени втайне ворует случайную сумму наличных денег у Барта.
  Покупает на эти деньги сигареты у Апу.
  
  ![Nelson](images/nelson.png)

- Преступник Честер "Змей" Турли. Время от времени взламывает компьютер Гомера
  и переводит некоторую сумму денег с его счёта на свой. Покупает продукты у Апу.

  ![Snake](images/snake.png)

- Вейлон Смиттерс. Личный помощник Мистера Бернса, владельца электростанции.
  Получает деньги за свою работу от владельца электростанции.
  Тратит их на покупку продуктов в супермаркете. Оплачивает деньги переводом.
  Параноик, поэтому время от времени закрывает и заново открывает счёт в банке.

  Не всегда вовремя уведомляет владельца электростанции о смене счёта, поэтому
  возможна ситуация,
  при которой владелец электростанции пытается перевести деньги на ставший невалидным счёт,
  и перевод заканчивается неудачей.

  ![Smitters](images/smitters.png)

Добавление этих новых персонажей должно также сохранять общее количество денег в системе.

## Ссылки

1. [Разработка через тестирование](https://ru.wikipedia.org/wiki/Разработка_через_тестирование)
