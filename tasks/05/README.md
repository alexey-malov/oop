# Лабораторная работа №5. Перегрузка операторов

- [Лабораторная работа №5. Перегрузка операторов](#лабораторная-работа-5-перегрузка-операторов)
  - [Практические задания](#практические-задания)
  - [Обязательные задания](#обязательные-задания)
    - [Задание 1](#задание-1)
      - [Вариант 1. Комплексные числа. До 140 баллов](#вариант-1-комплексные-числа-до-140-баллов)
      - [Вариант 2. До 120 баллов](#вариант-2-до-120-баллов)
      - [Вариант 3. До 156 баллов](#вариант-3-до-156-баллов)
      - [Вариант 4. До 90 баллов](#вариант-4-до-90-баллов)
      - [Вариант 5. До 220 баллов](#вариант-5-до-220-баллов)
  - [Дополнительные задания](#дополнительные-задания)
    - [Задание 2 – До 300 баллов](#задание-2--до-300-баллов)

## Практические задания

На оценку «**удовлетворительно**» необходимо выполнить обязательное задание и набрать **не менее 60 баллов**.

На оценку «**хорошо**» необходимо выполнить дополнительное задание и (возможно, обязательное), набрав **не менее 400 баллов**.

На оценку «**отлично**» необходимо выполнить обязательное и дополнительное задания, набрав **не менее 600 баллов**.

## Обязательные задания

### Задание 1

#### Вариант 1. Комплексные числа. До 140 баллов

Разработайте класс `CComplex`, моделирующий работу с [комплексными числами](https://ru.wikipedia.org/wiki/Комплексное_число).

Каркас класса:

```c++
class CComplex
{
public:
    // инициализация комплексного числа значениями действительной и мнимой частей
    CComplex(double real = 0, double image = 0);

    // возвращает действительную часть комплексного числа
    double Re()const;

    // возвращает мнимую часть комплексного числа
    double Im()const;

    // возвращает модуль комплексного числа
    double GetMagnitude()const;

    // возвращает аргумент комплексного числа
    double GetArgument()const;
};
```

Реализуйте конструктор и методы класса, а также следующие операторы:

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Оператор</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>1</th>
            <th>Бинарный +</th>
            <th>Реализовать две версии данного оператора:
                <br>1. Возвращает сумму двух комплексных чисел
                <br>2 Возвращает сумму действительного и комплексного числа
                <br>Явная реализация суммы комплексного и действительного числа не потребуется, т.к. будет вызван оператор суммы двух комплексных чисел благодаря конструктору класса CComplex, который выполнит необходимое преобразование типа double в CComplex автоматически</th>
        </tr>
        <tr>
            <th>2</th>
            <th>Бинарный -</th>
            <th>Реализовать две версии данного оператора:
                <br>1.Возвращает разность двух комплексных чисел
                <br>2.Возвращает разность действительного и комплексного числа
                <br>Явная реализация разности комплексного и действительного числа не потребуется, т.к. будет вызван оператор разности двух комплексных чисел благодаря конструктору класса CComplex, который выполнит необходимое преобразование типа double в CComplex автоматически</th>
        </tr>
        <tr>
            <th>3</th>
            <th>*</th>
            <th>Реализовать две версии данного оператора:
                <br>1.Возвращает произведение двух комплексных чисел
                <br>2.Возвращает произведение действительного и комплексного числа</th>
        </tr>
        <tr>
            <th>4</th>
            <th>/</th>
            <th>Реализовать две версии данного оператора:
                <br>1.Возвращает частное двух комплексных чисел
                <br>2.Возвращает частное действительного и комплексного числа</th>
        </tr>
        <tr>
            <th>5</th>
            <th>Унарный + и Унарный -</th>
            <th>Убедиться в том, что комплексные числа возвращают копию комплексного числа и противоположное комплексное число, соответственно.</th>
        </tr>
        <tr>
            <th>6</th>
            <th>+=</th>
            <th>Достаточно реализовать лишь следующую версию данного оператора:
                <br>complex += complex
                <br>Благодаря конструктору класса CComplex она будет вызываться и для приращения на величину действительного числа</th>
        </tr>
        <tr>
            <th>7</th>
            <th>-=</th>
            <th>Аналогично +=</th>
        </tr>
        <tr>
            <th>8</th>
            <th>*=</th>
            <th>Аналогично -=</th>
        </tr>
        <tr>
            <th>9</th>
            <th>/=</th>
            <th>Аналогично /=</th>
        </tr>
        <tr>
            <th>10</th>
            <th>==</th>
            <th>Реализовать две версии данного оператора, выполняющие сравнение:
                <br>1.Комплексного числа с комплексным числом (она же будет вызываться при сравнении комплексного числа с действительным)
                <br>2.Действительного числа с комплексным числом
                <br>Внимание, т.к. действительная и мнимая части комплексного числа хранятся в виде чисел с плавающей запятой для их сравнения следует использовать сравнение с заданной точностью:
                <br>bool numbersAreEqual = (fabs(number1 – number2) < DBL_EPSILON);
                <br>Примечание: константа `DBL_MIN` – объявлена в заголовочном файле `cfloat`, а функция `fabs` – в `cmath`</th>
        </tr>
        <tr>
            <th>11</th>
            <th>!=</th>
            <th>Проверяет комплексные числа (а также действительное число и комплексное) на неравенство</th>
        </tr>
        <tr>
            <th>12</th>
            <th><<</th>
            <th>Оператор вывода в выходной поток `std::ostream` в формате Re±Imi, например:
                <br>-3.5-4.8i
                <br>4+2i
                <br>-3+2i
                <br>0-2i
                <br>0+0i
                <br>-3+0i</th>
        </tr>
        <tr>
            <th>13</th>
            <th>>></th>
            <th>Оператор ввода из входного потока `std::istream` в формате Re±Imi, например:
                <br>-3.5-4.8i
                <br>4+2i
                <br>-3+2i
                <br>3-2i</th>
        </tr>
    </tbody>
</table>

<span style="color:red">В процессе разработки класса использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.</span>

#### Вариант 2. До 120 баллов

Разработайте класс, моделирующий работу с трехмерными векторами. Каркас класса:

```c++
class CVector3D
{
public:
    // Конструирует нулевой вектор
    CVector3D();

    // Конструирует вектор с заданными координатами
    CVector3D(double x0, double y0, double z0);

    // Возвращает длину вектора
    double GetLength()const;

    // Нормализует вектор (приводит его к единичной длине)
    void Normalize();

    // Другие методы и операции класса

    // В данном случае данные можно сделать публичными
    double x, y, z;
};
```

Реализуйте следующие операторы над трехмерными векторами:

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Операции</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>1</th>
            <th>Унарный + и -</th>
            <th>Унарный минус возвращает вектор с противоположным направлением:
                <br>v1 = -v2
                <br>Унарный плюс возвращает тот же вектор (для полноты)</th>
        </tr>
        <tr>
            <th>2</th>
            <th>Бинарный +</th>
            <th>Возвращает результат сложения векторов</th>
        </tr>
        <tr>
            <th>3</th>
            <th>Бинарный -</th>
            <th>Возвращает результат вычитания векторов</th>
        </tr>
        <tr>
            <th>4</th>
            <th>+=</th>
            <th>Выполняют увеличение длины вектора на длину второго вектора:
                <br>a += b;</th>
        </tr>
        <tr>
            <th>5</th>
            <th>-=</th>
            <th>Аналогично +=</th>
        </tr>
        <tr>
            <th>6</th>
            <th>*</th>
            <th>Умножает вектор на скаляр и скаляр на вектор.</th>
        </tr>
        <tr>
            <th>7</th>
            <th>/</th>
            <th>Выполняет деление вектора на скаляр.</th>
        </tr>
        <tr>
            <th>8</th>
            <th>*=</th>
            <th>Умножает вектор на скаляр:
                <br>v *= 3.7;</th>
        </tr>
        <tr>
            <th>9</th>
            <th>/=</th>
            <th>Делит вектор на скаляр:
                <br>v /= 17;</th>
        </tr>
        <tr>
            <th>10</th>
            <th>== и !=</th>
            <th>Выполняет проверку векторов на приблизительное равенство (или неравенство).
                <br>Вектора считаются равными, если абсолютная величина (модуль) разности их соответствующих координат не превышает некоторой величины (можно использовать DBL_EPSILON из заголовочного файла float.h)</th>
        </tr>
        <tr>
            <th>11</th>
            <th><<</th>
            <th>Оператор вывода в выходной поток std::ostream в формате x, y, z, например:
                <br>3, -2.5, 7</th>
        </tr>
        <tr>
            <th>12</th>
            <th>>></th>
            <th>Оператор ввода из входного потока std::istream в формате x, y, z, например:
                <br>3, -2.5, 7</th>
        </tr>
    </tbody>
</table>

Реализуйте следующие свободные функции для работы с трехмерными векторами:

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Функция</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>13</th>
            <th>DotProduct</th>
            <th>Вычисляет результат скалярного произведения двух трехмерных векторов:
                <br>double DotProduct(CVector3D const& v1, CVector3D const& v2);</th>
        </tr>
        <tr>
            <th>14</th>
            <th>CrossProduct</th>
            <th>Вычисляет результат векторного произведения двух трехмерных векторов:
                <br>CVector3D CrossProduct(CVector3D const& v1, CVector3D const& v2);</th>
        </tr>
        <tr>
            <th>15</th>
            <th>Normalize</th>
            <th>Возвращает единичный вектор, имеющий то же направление, что и вектор, выступающий в качестве аргумента функции:
                <br>CVector3D Normalize(CVector3D const& v);</th>
        </tr>
    </tbody>
</table>

<span style="color:red">В процессе разработки класса использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.</span>

#### Вариант 3. До 156 баллов

Разработайте класс `CRational`, моделирующий [рациональное число](https://ru.wikipedia.org/wiki/Рациональное_число) и реализующий основные арифметические операций над рациональными числами.

Каркас класса CRational приведен ниже

```cpp
class CRational
{
public:
    // Конструирует рациональное число, равное нулю (0/1)
    CRational();

    // Конструирует рациональное число, равное value (value/1)
    CRational(int value);

    // Конструирует рациональное число, равное numerator/denominator
    // Рациональное число должно храниться в нормализованном виде:
    // знаменатель положительный (числитель может быть отрицательным)
    // числитель и знаменатель не имеют общих делителей (6/8 => 3/4 и т.п.)
    // Если знаменатель равен нулю, должно конструироваться рациональное число, равное нулю,
    // либо должно быть выброшено исключение std::invalid_argument.
    CRational(int numerator, int denominator);

    // Возвращает числитель
    int GetNumerator()const;

    // Возвращает знаменатель (натуральное число)
    int GetDenominator()const;

    // Возвращает отношение числителя и знаменателя в виде числа double
    double ToDouble()const;

    // Прочие операторы согласно заданию
};
```

Реализуйте следующие операторы над рациональными числами. **В результате данных операций должны получаться нормализованные рациональные (нормализация необходима для того, чтобы в результате арифметических операций избежать чрезмерных значений числителя и знаменателя, способных выйти за пределы диапазона `int`. например, (49/100 + 1/100) * 9/30 в денормализованном виде равно 450/3000, а в нормализованном – 3/20). числа**.

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Операция</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>1</th>
            <th>Унарный + и -</th>
            <th>Унарный минус возвращает рациональное число с противоположным знаком:
                <br>$\frac{3}{5}$ => $-\frac{3}{5}$
                <br>Унарный плюс рациональное число, равное текущему.</th>
        </tr>
        <tr>
            <th>2</th>
            <th>Бинарный +</th>
            <th>Возвращает результат сложения двух рациональных чисел, рационального числа с целым, целого числа с рациональным (подсказка: есть возможность реализовать все три типа сложения: CRational+int, CRational+CRational, int+CRational, написав оператор сложения всего один раз. Подумайте, каким образом этого можно добиться.):
                <br>$\frac{1}{2}+\frac{1}{6}=\frac{2}{3}$
                <br>$\frac{1}{2}+1=\frac{3}{2}$
                <br>$1+\frac{1}{2}=\frac{3}{2}$</th>
        </tr>
        <tr>
            <th>3</th>
            <th>Бинарный -</th>
            <th>Возвращает разность двух рациональных чисел, рационального числа и целого, либо целого числа и рационального (см. пояснение насчет бинарного оператора сложения):
                <br>$\frac{1}{2}-\frac{1}{6}=\frac{1}{3}$
                <br>$\frac{1}{2}-1=-\frac{1}{2}$
                <br>$1-\frac{1}{2}=\frac{1}{2}$</th>
        </tr>
        <tr>
            <th>4</th>
            <th>+=</th>
            <th>Выполняет увеличение рационального числа на величину второго рационального, либо целого числа (здесь так же можно реализовать поддержку обоих случаев сложения, написав оператор += всего один раз. Объясните, почему?):
                <br>$\frac{1}{2} += \frac{1}{6}→\frac{2}{3}$
                <br>$\frac{1}{2} += 1→\frac{3}{2}$</th>
        </tr>
        <tr>
            <th>5</th>
            <th>-=</th>
            <th>Выполняет уменьшение рационального числа на величину второго рационального либо целого числа (см. пояснение насчет оператора +=):
                <br>$\frac{1}{2} -= \frac{1}{6}→\frac{1}{3}$
                <br>$\frac{1}{2} -= 1→-\frac{1}{2}$</th>
        </tr>
        <tr>
            <th>6</th>
            <th>*</th>
            <th>Возвращает результат произведения рациональных чисел, рационального и целого, либо целого и рационального (см. пояснение насчет бинарного оператора +):
                <br>$\frac{1}{2}*\frac{2}{3}=\frac{1}{3}$
                <br>$\frac{1}{2}*(-3)=-\frac{3}{2}$
                <br>$7*\frac{2}{3}=\frac{14}{3}$</th>
        </tr>
        <tr>
            <th>7</th>
            <th>/</th>
            <th>Возвращает частное двух рациональных чисел, рационального и целого, целого и рационального (см. пояснение насчет бинарного оператора +):
                <br>$\frac{\frac{1}{2}}{\frac{2}{3}}=\frac{3}{4}$
                <br>$\frac{\frac{1}{2}}=\frac{1}{10}$
                <br>$\frac{7}{\frac{2}{3}}=\frac{21}{2}$</th>
        </tr>
        <tr>
            <th>8</th>
            <th>*=</th>
            <th>Умножает значение первого рационального числа на другое рациональное, либо целое (см. пояснение насчет оператора +=):
                <br>$\frac{1}{2} *= \frac{2}{3}→\frac{1}{3}$
                <br>\frac{1}{2} *= 3→\frac{3}{2}</th>
        </tr>
        <tr>
            <th>9</th>
            <th>/=</th>
            <th>Делит первое рациональное число на другое рациональное, либо целое (см. пояснение насчет оператора +=):
                <br>$\frac{1}{2} /= \frac{2}{3}→\frac{3}{4}$
                <br>$\frac{1}{2} /= 3→\frac{1}{6}$
                <br>$\frac{3}{4} /= \frac{3}{8}→\frac{2}{1}$</th>
        </tr>
        <tr>
            <th>10</th>
            <th>== и !=</th>
            <th>Проверяют равенство (и неравенство) двух рациональных чисел, целого и рационального, рационального и целого (есть возможность реализовать все три варианта сравнения в операторах == и !=, разработав по одной версии операторов == и !=. Подумайте, как?):
                <br>$\frac{1}{2} == \frac{1}{2}$→true
                <br>$\frac{1}{2} == \frac{2}{3}$→false
                <br>$\frac{4}{1} == 4$→true
                <br>$\frac{1}{2} == 7$→false
                <br>$3 == \frac{3}{1}$→true
                <br>$3 == \frac{2}{3}$→false
                <br>$\frac{1}{2} != \frac{1}{2}$→false
                <br>$\frac{1}{2} != \frac{2}{3}$→true
                <br>$\frac{4}{1} != 4$→false
                <br>$\frac{1}{2} != 7$→true
                <br>$3 != \frac{3}{1}$→false
                <br>$3 != \frac{2}{3}$→true</th>
        </tr>
        <tr>
            <th>11</th>
            <th><, <=, >, >=</th>
            <th>Сравнивают два рациональных числа, рациональное с целым, целое с рациональным (см. указания насчет операторов != и ==):
                <br>$\frac{1}{2} >= \frac{1}{3}$→true
                <br>$\frac{1}{2} <= \frac{1}{3}$→false
                <br>$\frac{3}{1}>2$→true
                <br>$\frac{1}{2} < 7$→true
                <br>$3 <= \frac{7}{2}$→true
                <br>$3 >= \frac{8}{2}$→false</th>
        </tr>
        <tr>
            <th>12</th>
            <th><<</th>
            <th>Оператор вывода рационального числа в выходной поток std::ostream в формате <числитель>/<знаменатель>, например: 7/15</th>
        </tr>
        <tr>
            <th>13</th>
            <th>>></th>
            <th>Оператор ввода рационального числа из входного потока std::istream в формате <числитель>/<знаменатель>, например: 7/15</th>
        </tr>
    </tbody>
</table>

<span style="color:red">В процессе разработки класса использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.</span>

<span style="color:gray">**Бонус в 30 баллов за возможность получения смешанной дроби из рационального числа**</span> <a name="1-3-b-1"></a>

[Смешанная дробь](https://ru.wikipedia.org/wiki/Дробь_%28математика%29#.D0.A1.D0.BC.D0.B5.D1.88.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B4.D1.80.D0.BE.D0.B1.D0.B8) – дробь, представленная в виде суммы целого числа и [правильной дроби](https://ru.wikipedia.org/wiki/Дробь_%28математика%29#.D0.9F.D1.80.D0.B0.D0.B2.D0.B8.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.B8_.D0.BD.D0.B5.D0.BF.D1.80.D0.B0.D0.B2.D0.B8.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.B4.D1.80.D0.BE.D0.B1.D0.B8) (правильной называется дробь, у которой модуль числителя меньше модуля знаменателя.):

Например, рациональное число $\frac{9}{4}$ может быть представлено в виде смешанной дроби 2$\frac{1}{4}$, а число $-\frac{9}{4}$ (минус девять четвертых) – в виде смешанной дроби: $-2+(-\frac{1}{4})=-(2\frac{1}{4})$.

```c++
class CRational
{
public:
    // Возвращает представление рационального числа в виде смешанной дроби
    std::pair<int, CRational> ToCompoundFraction()const;
};
```

#### Вариант 4. До 90 баллов

Реализуйте класс CTime, моделирующий время суток (количество часов, минут и секунд).

Каркас класса:

```c++
// моделирует время суток, задаваемое количеством часов (0-23), минут (0-59) и
// секунд (0-59)
class CTime
{
public:
    // инициализирует время заданным количеством часов, минут и секунд
    CTime(unsigned hours, unsigned minutes, unsigned seconds = 0);

    // инициализирует время количеством секунд после полуночи
    CTime(unsigned timeStamp = 0);

    // возвращает количество часов
    unsigned GetHours()const;

    // возвращает количество минут
    unsigned GetMinutes()const;

    // возвращает количество секунд
    unsigned GetSeconds()const;

    // возвращает информацию о корректности времени.
    // Например, после вызова конструктора CTime time(99, 32, 83);
    // метод time.IsValid() должен возвращать false
    bool IsValid()const;
};
```

Реализуйте конструкторы и методы данного класса, а также следующие операторы.

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Оператор</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>1</th>
            <th>++ (префиксная и постфиксная формы)</th>
            <th>Увеличивает время на 1 секунду</th>
        </tr>
        <tr>
            <th>2</th>
            <th>-- (префиксная и постфиксная формы)</th>
            <th>Уменьшает время на 1 секунду</th>
        </tr>
        <tr>
            <th>3</th>
            <th>+</th>
            <th>Выполняет сложение двух времен. Например:
                <br>14:30:25 + 03:18:44 = 17:49:09</th>
        </tr>
        <tr>
            <th>4</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>5</th>
            <th>+=</th>
            <th></th>
        </tr>
        <tr>
            <th>6</th>
            <th>-=</th>
            <th></th>
        </tr>
        <tr>
            <th>7</th>
            <th>*</th>
            <th>Умножает время на целое число (и наоборот). Например:
                <br>03:05:15 * 3 = 3 * 03:05:15 = 09:15:45</th>
        </tr>
        <tr>
            <th>8</th>
            <th>/</th>
            <th>2 формы:
                <br>1.Деление времени на целое число. Например:
                <br>09:15:40 / 3 = 03:05:13
                <br>2.Деление времени на время (нацело). Например:
                <br>09:15:40 / 03:05:13 = 3</th>
        </tr>
        <tr>
            <th>9</th>
            <th>*=</th>
            <th></th>
        </tr>
        <tr>
            <th>10</th>
            <th>/=</th>
            <th></th>
        </tr>
        <tr>
            <th>11</th>
            <th><<</th>
            <th>Оператор вывода времени в поток вывода в формате ЧЧ:ММ:СС, либо INVALID, если время невалидно</th>
        </tr>
        <tr>
            <th>12</th>
            <th>>></th>
            <th>Оператор ввода времени из потока ввода в формате ЧЧ:ММ:СС, либо INVALID, если время невалидно</th>
        </tr>
        <tr>
            <th>13</th>
            <th>== и !=</th>
            <th>Проверка двух значений времени на равенство и неравенство</th>
        </tr>
        <tr>
            <th>14</th>
            <th>< и ></th>
            <th>Проверка двух временных значений на строгое неравенство</th>
        </tr>
        <tr>
            <th>15</th>
            <th><= и >=</th>
            <th>Проверка двух временных значений на нестрогое неравенство</th>
        </tr>
    </tbody>
</table>

Результат выполнения арифметических операций, в которых один из аргументов является невалидным значением, должен также давать невалидное значение времени (см. примечание).

При выходе результата после выполнения операций за пределы диапазона 00:00:00 – 23:59:59 приводить результат к этому диапазону. Например:

- 23:59:59 + 00:00:03 = 00:00:02
- 00:00:05 – 00:00:10 = 23:59:55

**Подсказка**: данный класс будет проще реализовать, если вместо трех приватных переменных (часы, минуты и секунды) вы будете использовать только одну единственную переменную для хранения секунд после полуночи и все операции производить над нею.

**Примечание**: если проводить валидацию параметров в конструкторе и выбрасывать исключение в случае ошибки, то метод IsValid реализовывать не нужно. Автоматически решится проблема с выполнением арифметических операций, в которых участвуют невалидные значения времени.

<span style="color:red">В процессе разработки класса использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.</span>

#### Вариант 5. До 220 баллов

Реализуйте класс `CDate`, моделирующий дату начиная с 1 января 1970 года. Каркас класса выглядит так:

```c++
// Месяц
enum class Month
{
    JANUARY = 1, FEBRUARY, MARCH, APRIL,
    MAY, JUNE, JULY, AUGUST, SEPTEMBER,
    OCTOBER, NOVEMBER, DECEMBER
};

// День недели
enum class WeekDay
{
    SUNDAY = 0, MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY
};

// Дата в формате день-месяц-год. Год в диапазоне от 1970 до 9999
class CDate
{
public:
    // инициализируем дату заданными днем, месяцем и годом.
    // примечание: год >= 1970
    CDate(unsigned day, Month month, unsigned year);

    // инициализируем дату количеством дней, прошедших после 1 января 1970 года
    // например, 2 = 3 января 1970, 32 = 2 февраля 1970 года и т.д.
    CDate(unsigned timestamp = 0);

    // возвращает день месяца (от 1 до 31)
    unsigned GetDay()const;

    // возвращает месяц
    Month GetMonth()const;

    // возвращает год
    unsigned GetYear()const;

    // возвращает день недели
    WeekDay GetWeekDay()const;

    // возвращает информацию о корректности хранимой даты.
    // Например, после вызова CDate date(99, static_cast<Month>(99), 10983);
    // или после:
    // CDate date(1, January, 1970); --date;
    // метод date.IsValid() должен вернуть false;
    bool IsValid()const;
};
```

Реализуйте конструкторы и методы данного класса, а также следующие операторы.

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Оператор</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>1</th>
            <th>++ (префиксная и постфиксная формы)</th>
            <th>Переводит дату на следующий день</th>
        </tr>
        <tr>
            <th>2</th>
            <th>-- (префиксная и постфиксная формы)</th>
            <th>Переводит дату на предыдущий день</th>
        </tr>
        <tr>
            <th>3</th>
            <th>+</th>
            <th>Прибавляет к дате заданное целое количество дней. Например:
                <br>28/02/2010 + 3 = 03/03/2010</th>
        </tr>
        <tr>
            <th>4</th>
            <th>-</th>
            <th>Реализовать 2 версии данного оператора:
                <br>1.Вычитает из даты заданное количество дней. Например:
                <br>01/01/2010 - 2 = 30/12/2009
                <br>2.Находит разность двух дат в днях. Например:
                <br>01/01/2010 - 30/12/2009 = 3
                <br>01/01/2010 - 03/01/2010 = -2</th>
        </tr>
        <tr>
            <th>5</th>
            <th>+=</th>
            <th><Дата> += <кол-во дней></th>
        </tr>
        <tr>
            <th>6</th>
            <th>-=</th>
            <th><Дата> -= <кол-во дней></th>
        </tr>
        <tr>
            <th>7</th>
            <th><<</th>
            <th>Оператор вывода даты в поток вывода в формате ДД.ММ.ГГГГ, либо INVALID, если дата является недопустимой</th>
        </tr>
        <tr>
            <th>8</th>
            <th>>></th>
            <th>Оператор ввода времени из потока ввода в формате ДД.ММ.ГГГГ, либо INVALID, если дата является недопустимой</th>
        </tr>
        <tr>
            <th>9</th>
            <th>== и !=</th>
            <th>Проверка двух дат на равенство и неравенство</th>
        </tr>
        <tr>
            <th>10</th>
            <th>< и ></th>
            <th>Проверка двух дат на строгое неравенство</th>
        </tr>
        <tr>
            <th>11</th>
            <th><= и >=</th>
            <th>Проверка двух дат на нестрогое неравенство</th>
        </tr>
    </tbody>
</table>

Результат применения данных операций к недопустимой дате не изменяет ее значения.

При выходе результата после выполнения операций за пределы диапазона 01:01:1970 – 31:12:9999 дата должна стать недопустимой.

**Подсказка**: данный класс будет проще реализовать, если вместо трех приватных переменных (день, месяц и год) вы будете использовать только одну единственную переменную для хранения количества дней после 1 января 1970 года и все операции производить над нею.

<span style="color:red">В процессе разработки класса использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.</span>

## Дополнительные задания

### Задание 2 – До 300 баллов

Реализовать и протестировать класс `CMyString`, моделирующий строку произвольной длины.

Внимание, **строка должна позволять хранить в середине символы с нулевым кодом** (подсказка: реализация класса строк должна помимо адреса первого элемента массива символов в динамической памяти хранить еще и длину строки, т.к. использование функций вроде `strlen`, `strcpy` и им подобных, воспринимающих символ с нулевым кодом как символ конца строки, не решает данную проблему.
Кроме того в массиве потребуется зарезервировать место под символ с нулевым кодом в конце строки, т.к. метод GetStringData(), объявленный в классе CMyString, согласно условиям задачи возвращает указатель на строку с завершающим нулевым символом.). Проинициализировать такую строку можно при помощи конструктора, принимающего кроме адреса первого символа длину строки.

Каркас класса:

```c++
class CMyString
{
public:
    // конструктор по умолчанию
    CMyString();

    // конструктор, инициализирующий строку данными строки
    // с завершающим нулевым символом
    CMyString(const char * pString);

    // конструктор, инициализирующий строку данными из 
    // символьного массива заданной длины
    CMyString(const char * pString, size_t length);

    // конструктор копирования
    CMyString(CMyString const& other);

    // перемещающий конструктор (для компиляторов, совместимых с C++11)
    //  реализуется совместно с перемещающим оператором присваивания 
    CMyString(CMyString && other);

    // конструктор, инициализирующий строку данными из 
    // строки стандартной библиотеки C++
    CMyString(std::string const& stlString);

    // деструктор класса - освобождает память, занимаемую символами строки
    ~CMyString();

    // возвращает длину строки (без учета завершающего нулевого символа)
    size_t GetLength()const;

    // возвращает указатель на массив символов строки.
    // В конце массива обязательно должен быть завершающий нулевой символ
    // даже если строка пустая 
    const char* GetStringData()const;

    // возвращает подстроку с заданной позиции длиной не больше length символов
    CMyString SubString(size_t start, size_t length = SIZE_MAX)const;

    // очистка строки (строка становится снова нулевой длины)
    void Clear();
};
```

Для хранения символов строки не допускается использовать классы вроде std::string и std::vector. Управление данными в динамической памяти должно быть реализовано целиком силами Вашего класса.

<span style="color:red">Внимание:</span>

Реализуйте конструктор, деструктор и перечисленные в каркасе методы класса, а также следующие операторы:

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Оператор</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>1</th>
            <th>=</th>
            <th>Присваивание CMyString (присваивание других типов, принимаемые конструктором класса будут реализованы автоматически)
                <br>Корректно должна обрабатываться ситуации с самоприсваиванием, вроде:
                <br>CMyString s(“SomeString”);
                <br>s = s;</th>
        </tr>
        <tr>
            <th>2</th>
            <th>+</th>
            <th>Реализуйте следующие версии оператора конкатенации:
                <br>1.CMyString с CMyString
                <br>2.std::string с CMyString
                <br>3.const char* с CMyString</th>
        </tr>
        <tr>
            <th>3</th>
            <th>+=</th>
            <th>Конкатенация CMyString с CMyString с присваиванием</th>
        </tr>
        <tr>
            <th>4</th>
            <th>==</th>
            <th>Посимвольное сравнение содержимого двух строк</th>
        </tr>
        <tr>
            <th>5</th>
            <th>!=</th>
            <th>Проверка двух строк на неравенство</th>
        </tr>
        <tr>
            <th>6</th>
            <th><</th>
            <th>Лексикографическое сравнение содержимого двух строк. Осуществляет проверку того, предшествует ли строка слева от знака «<» строке, находящейся справа, если сравнивать их содержимое в алфавитном порядке.</th>
        </tr>
        <tr>
            <th>7</th>
            <th>></th>
            <th>Лексикографическое сравнение содержимого двух строк. Аналогично оператору <</th>
        </tr>
        <tr>
            <th>8</th>
            <th><= и >=</th>
            <th>Лексикографическое сравнение содержимого двух строк. Аналогично операторам < и ></th>
        </tr>
        <tr>
            <th>9</th>
            <th>[]</th>
            <th>Реализуйте две версии данного оператора:
                <br>1.Индексированный доступ к символам строки по целочисленному индексу для чтения
                <br>2.Индексированный доступ к символам строки по целочисленному индексу для записи</th>
        </tr>
        <tr>
            <th>10</th>
            <th><<</th>
            <th>Оператор вывода в выходной поток</th>
        </tr>
        <tr>
            <th>11</th>
            <th>>></th>
            <th>Оператор ввода из входного потока</th>
        </tr>
        <tr>
            <th>12</th>
            <th>Перемещающий конструктор и оператор присваивания</th>
            <th>Реализуется совместно с перемещающим конструктором.</th>
        </tr>
    </tbody>
</table>

<span style="color:gray">**Бонус до 200 баллов за реализацию STL-совместимых итераторов**</span> <a name="2-b-1"></a>

Реализовать поддержку итераторов в STL-совместимой манере, позволяющих перебирать символы строки, использоваться совместно с основными алгоритмами стандартной библиотеки.

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Функционал</th>
            <th>Балл</th>
            <th>Обязательно</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>1</th>
            <th>Итерация по константным (для константных строк должен возвращаться итератор, предоставляющий доступ к содержимому строки только для чтения) и неконстантным строкам в прямом направлении и обратном направлении.
                <br>Получение итератора, указывающего на начальный символ и на позицию, следующую за конечным символом строки (аналоги методов begin()/end() класса std::string)
                <br>Разыменование итератора
                <br>Нахождение разницы между двумя итераторами, сложение итератора с числом и числа с итератором</th>
            <th>100</th>
            <th>Да</th>
        </tr>
        <tr>
            <th>2</th>
            <th>Индексированный (для константных строк доступ должен предоставляться только для чтения символов строки) доступ к элементам строки относительно итератора при помощи оператора []</th>
            <th>20</th>
            <th>Нет</th>
        </tr>
        <tr>
            <th>3</th>
            <th>Поддержка итерации по символам строки в обратном направлении (аналогично итерации при помощи методов std::string::rbegin(), std::string::rend()).</th>
            <th>30</th>
            <th>Нет</th>
        </tr>
        <tr>
            <th>4</th>
            <th>Проверка границ (при помощи assert) в отладочной конфигурации.</th>
            <th>30</th>
            <th>Нет</th>
        </tr>
        <tr>
            <th>5</th>
            <th>Поддержка итерации по элементам при помощи range-based версии оператора for.</th>
            <th>20</th>
            <th>Нет</th>
        </tr>
    </tbody>
</table>

<span style="color:red">В процессе разработки классов использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.</span>
