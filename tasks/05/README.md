# Лабораторная работа №5. Перегрузка операторов
## Практические задания
На оценку «**удовлетворительно**» необходимо выполнить обязательное задание и набрать **не менее 60 баллов**.

На оценку «**хорошо**» необходимо выполнить дополнительное задание и (возможно, обязательное), набрав **не менее 400 баллов**.

На оценку «**отлично**» необходимо выполнить обязательное и дополнительное задания, набрав **не менее 600 баллов**.

## Обязательные задания
### Задание 1
#### Вариант 1. Комплексные числа. До 140 баллов
Разработайте класс `CComplex`, моделирующий работу с [комплексными числами](https://ru.wikipedia.org/wiki/Комплексное_число).

Каркас класса:

```c++
class CComplex
{
public:
// инициализация комплексного числа значениями действительной и мнимой частей
CComplex(double real = 0, double image = 0);

	// возвращает действительную часть комплексного числа
	double Re()const;

	// возвращает мнимую часть комплексного числа
	double Im()const;

	// возвращает модуль комплексного числа
	double GetMagnitude()const;

	// возвращает аргумент комплексного числа
	double GetArgument()const;
};
```
Реализуйте конструктор и методы класса, а также следующие операторы:

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Оператор</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>1</th>
            <th>Бинарный +</th>
            <th>Реализовать две версии данного оператора:
                <br>1. Возвращает сумму двух комплексных чисел
                <br>2 Возвращает сумму действительного и комплексного числа
                <br>Явная реализация суммы комплексного и действительного числа не потребуется, т.к. будет вызван оператор суммы двух комплексных чисел благодаря конструктору класса CComplex, который выполнит необходимое преобразование типа double в CComplex автоматически</th>
        </tr>
        <tr>
            <th>2</th>
            <th>Бинарный -</th>
            <th>Реализовать две версии данного оператора:
                <br>1.Возвращает разность двух комплексных чисел
                <br>2.Возвращает разность действительного и комплексного числа
                <br>Явная реализация разности комплексного и действительного числа не потребуется, т.к. будет вызван оператор разности двух комплексных чисел благодаря конструктору класса CComplex, который выполнит необходимое преобразование типа double в CComplex автоматически</th>
        </tr>
        <tr>
            <th>3</th>
            <th>*</th>
            <th>Реализовать две версии данного оператора:
                <br>1.Возвращает произведение двух комплексных чисел
                <br>2.Возвращает произведение действительного и комплексного числа</th>
        </tr>
        <tr>
            <th>4</th>
            <th>/</th>
            <th>Реализовать две версии данного оператора:
                <br>1.Возвращает частное двух комплексных чисел
                <br>2.Возвращает частное действительного и комплексного числа</th>
        </tr>
        <tr>
            <th>5</th>
            <th>Унарный + и Унарный -</th>
            <th>Убедиться в том, что комплексные числа возвращают копию комплексного числа и противоположное комплексное число, соответственно.</th>
        </tr>
        <tr>
            <th>6</th>
            <th>+=</th>
            <th>Достаточно реализовать лишь следующую версию данного оператора:
                <br>complex += complex
                <br>Благодаря конструктору класса CComplex она будет вызываться и для приращения на величину действительного числа</th>
        </tr>
        <tr>
            <th>7</th>
            <th>-=</th>
            <th>Аналогично +=</th>
        </tr>
        <tr>
            <th>8</th>
            <th>*=</th>
            <th>Аналогично -=</th>
        </tr>
        <tr>
            <th>9</th>
            <th>/=</th>
            <th>Аналогично /=</th>
        </tr>
        <tr>
            <th>10</th>
            <th>==</th>
            <th>Реализовать две версии данного оператора, выполняющие сравнение:
                <br>1.Комплексного числа с комплексным числом (она же будет вызываться при сравнении комплексного числа с действительным)
                <br>2.Действительного числа с комплексным числом
                <br>Внимание, т.к. действительная и мнимая части комплексного числа хранятся в виде чисел с плавающей запятой для их сравнения следует использовать сравнение с заданной точностью:
                <br>bool numbersAreEqual = (fabs(number1 – number2) < DBL_EPSILON);
                <br>Примечание: константа DBL _MIN – объявлена в заголовочном файле float.h, а функция fabs – в math.h</th>
        </tr>
        <tr>
            <th>11</th>
            <th>!=</th>
            <th>Проверяет комплексные числа (а также действительное число и комплексное) на неравенство</th>
        </tr>
        <tr>
            <th>12</th>
            <th><<</th>
            <th>Оператор вывода в выходной поток std::ostream в формате Re±Imi, например:
                <br>-3.5-4.8i
                <br>4+2i
                <br>-3+2i
                <br>0-2i
                <br>0+0i
                <br>-3+0i</th>
        </tr>
        <tr>
            <th>13</th>
            <th>>></th>
            <th>Оператор ввода из входного потока std::istream в формате Re±Imi, например:
                <br>-3.5-4.8i
                <br>4+2i
                <br>-3+2i
                <br>3-2i</th>
        </tr>
    </tbody>
</table>

<span style="color:red">В процессе разработки класса использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.</span>

#### Вариант 2. До 120 баллов
Разработайте класс, моделирующий работу с трехмерными векторами. Каркас класса:

```c++
class CVector3D
{
public:
// Конструирует нулевой вектор
CVector3D();

	// Конструирует вектор с заданными координатами
	CVector3D(double x0, double y0, double z0);

	// Возвращает длину вектора
	double GetLength()const;

	// Нормализует вектор (приводит его к единичной длине)
	void Normalize();

	// Другие методы и операции класса

	// В данном случае данные можно сделать публичными
	double x, y, z;
};
```

Реализуйте следующие операторы над трехмерными векторами:

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Операции</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>1</th>
            <th>Унарный + и -</th>
            <th>Унарный минус возвращает вектор с противоположным направлением:
                <br>v1 = -v2
                <br>Унарный плюс возвращает тот же вектор (для полноты)</th>
        </tr>
        <tr>
            <th>2</th>
            <th>Бинарный +</th>
            <th>Возвращает результат сложения векторов</th>
        </tr>
        <tr>
            <th>3</th>
            <th>Бинарный -</th>
            <th>Возвращает результат вычитания векторов</th>
        </tr>
        <tr>
            <th>4</th>
            <th>+=</th>
            <th>Выполняют увеличение длины вектора на длину второго вектора:
                <br>a += b;</th>
        </tr>
        <tr>
            <th>5</th>
            <th>-=</th>
            <th>Аналогично +=</th>
        </tr>
        <tr>
            <th>6</th>
            <th>*</th>
            <th>Умножает вектор на скаляр и скаляр на вектор.</th>
        </tr>
        <tr>
            <th>7</th>
            <th>/</th>
            <th>Выполняет деление вектора на скаляр.</th>
        </tr>
        <tr>
            <th>8</th>
            <th>*=</th>
            <th>Умножает вектор на скаляр:
                <br>v *= 3.7;</th>
        </tr>
        <tr>
            <th>9</th>
            <th>/=</th>
            <th>Делит вектор на скаляр:
                <br>v /= 17;</th>
        </tr>
        <tr>
            <th>10</th>
            <th>== и !=</th>
            <th>Выполняет проверку векторов на приблизительное равенство (или неравенство).
                <br>Вектора считаются равными, если абсолютная величина (модуль) разности их соответствующих координат не превышает некоторой величины (можно использовать DBL_EPSILON из заголовочного файла float.h)</th>
        </tr>
        <tr>
            <th>11</th>
            <th><<</th>
            <th>Оператор вывода в выходной поток std::ostream в формате x, y, z, например:
                <br>3, -2.5, 7</th>
        </tr>
        <tr>
            <th>12</th>
            <th>>></th>
            <th>Оператор ввода из входного потока std::istream в формате x, y, z, например:
                <br>3, -2.5, 7</th>
        </tr>
    </tbody>
</table>

Реализуйте следующие свободные функции для работы с трехмерными векторами:

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Функция</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>13</th>
            <th>DotProduct</th>
            <th>Вычисляет результат скалярного произведения двух трехмерных векторов:
                <br>double DotProduct(CVector3D const& v1, CVector3D const& v2);</th>
        </tr>
        <tr>
            <th>14</th>
            <th>CrossProduct</th>
            <th>Вычисляет результат векторного произведения двух трехмерных векторов:
                <br>CVector3D CrossProduct(CVector3D const& v1, CVector3D const& v2);</th>
        </tr>
        <tr>
            <th>15</th>
            <th>Normalize</th>
            <th>Возвращает единичный вектор, имеющий то же направление, что и вектор, выступающий в качестве аргумента функции:
                <br>CVector3D Normalize(CVector3D const& v);</th>
        </tr>
    </tbody>
</table>

<span style="color:red">В процессе разработки класса использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.</span>

#### Вариант 3. До 156 баллов
Разработайте класс `CRational`, моделирующий [рациональное число](https://ru.wikipedia.org/wiki/Рациональное_число) и реализующий основные арифметические операций над рациональными числами.

Каркас класса CRational приведен ниже

```c++
class CRational
{
public:
// Конструирует рациональное число, равное нулю (0/1)
CRational();

	// Конструирует рациональное число, равное value (value/1)
	CRational(int value);
	
	// Конструирует рациональное число, равное numerator/denominator
	// Рациональное число должно храниться в нормализованном виде:
	//	знаменатель положительный (числитель может быть отрицательным)
	//	числитель и знаменатель не имеют общиз делителей (6/8 => 3/4 и т.п.)
	// Если знаменатель равен нулю, должно сконструироваться рациональное число, равное нулю,
	// либо должно быть выброшено исключение std::invalid_argument.
	CRational(int numerator, int denominator);

	// Возвращает числитель
	int GetNumerator()const;

	// Возвращает знаменатель (натуральное число)
	int GetDenominator()const;

	// Возвращает отношение числителя и знаменателя в виде числа double
	double ToDouble()const;

	// Прочие операторы согласно заданию
};
```

Реализуйте следующие операторы над рациональными числами. **В результате данных операций должны получаться нормализованные рациональные (нормализация необходима для того, чтобы в результате арифметических операций избежать чрезмерных значений числителя и знаменателя, способных выйти за пределы диапазона `int`. например, (49/100 + 1/100) * 9/30 в денормализованном виде равно 450/3000, а в нормализованном – 3/20).) числа**.

<table>
    <thead>
        <tr>
            <th>№</th>
            <th>Операция</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>1</th>
            <th>Унарный + и -</th>
            <th>Унарный минус возвращает рациональное число с противоположным знаком:
                <br>$\frac{3}/{5}$ => $\frac{-3}/{5}$
                <br>Унарный плюс рациональное число, равное текущему.</th>
        </tr>
        <tr>
            <th>2</th>
            <th>Бинарный +</th>
            <th>Возвращает результат сложения двух рациональных чисел, рационального числа с целым, целого числа с рациональным (подсказка: есть возможность реализовать все три типа сложения: CRational+int, CRational+CRational, int+CRational, написав оператор сложения всего один раз. Подумайте, каким образом этого можно добиться.):
                <br>$\frac{1}/{2}+\frac{1}/{6}$=$\frac{2}/{3}$
                <br>$\frac{1}/{2}+1$=$\frac{3}/{2}$
                <br>$1+\frac{1}/{2}$=$\frac{3}/{2}$</th>
        </tr>
        <tr>
            <th>3</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>4</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>5</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>6</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>7</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>8</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>9</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>10</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>11</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>12</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>13</th>
            <th></th>
            <th></th>
        </tr>
    </tbody>
</table>

№	Операция	Описание
1	Унарный + и -	Унарный минус возвращает рациональное число с противоположным знаком:
3/5 => -3/5
Унарный плюс рациональное число, равное текущему.
2	Бинарный +	Возвращает результат сложения двух рациональных чисел, рационального числа с целым, целого числа с рациональным :
1/2+1/6=2/3

1/2+1=3/2

1+1/2=3/2
3	Бинарный -	Возвращает разность двух рациональных чисел, рационального числа и целого, либо целого числа и рационального :
1/2-1/6=1/3

1/2-1=-1/2

1-1/2=1/2
4	+=	Выполняет увеличение рационального числа на величину второго рационального, либо целого числа :
1/2 □(+=) 1/6→2/3

1/2 □(+=) 1→3/2
5	-=	Выполняет уменьшение рационального числа на величину второго рационального либо целого числа :
1/2 □(-=) 1/6→1/3

1/2 □(-=) 1→-1/2
6	*	Возвращает результат произведения рациональных чисел, рационального и целого, либо целого и рационального :
1/2*2/3=1/3

1/2*(-3)=-3/2

7*2/3=14/3
7	/	Возвращает частное двух рациональных чисел, рационального и целого, целого и рационального :
(1/2)⁄(2/3)=3/4

(1/2)⁄5=1/10

7⁄(2/3)=21/2
8	*=	Умножает значение первого рационального числа на другое рациональное, либо целое :
1/2 □(*=) 2/3→1/3

1/2 □(*=) 3→3/2
9	/=	Делит первое рациональное число на другое рациональное, либо целое :
1/2 □(/=) 2/3→3/4

1/2 □(/=) 3→1/6
3/4 □(/=) 3/8→2/1

10	== и !=	Проверяют равенство (и неравенство) двух рациональных чисел, целого и рационального, рационального и целого :
1/2 □(==) 1/2→true

1/2 □(==) 2/3→false

4/1 □(==) 4→true

1/2 □(==) 7→false

3□(==) 3/1→true

3□(==) 2/3→false

1/2 □(!=) 1/2→false

1/2 □(!=) 2/3→true

4/1 □(!=) 4→false

1/2 □(!=) 7→true

3□(!=) 3/1→false

3□(!=) 2/3→true
11	<, <=, >, >=	Сравнивают два рациональных числа, рациональное с целым, целое с рациональным :

1/2 □(>=) 1/3→true

1/2 □(<=) 1/3→false

3/1>2→true

1/2 □(<) 7→true

3□(<=) 7/2→true

3□(>=) 8/2→false
12	<<	Оператор вывода рационального числа в выходной поток std::ostream в формате <числитель>/<знаменатель>, например: 7/15
13	>>	Оператор ввода рационального числа из входного потока std::istream в формате <числитель>/<знаменатель>, например: 7/15
В процессе разработки класса использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.
Бонус в 30 баллов за возможность получения смешанной дроби из рационального числа
Смешанная дробь – дробь, представленная в виде суммы целого числа и правильной дроби :
Например, рациональное число 9/4 может быть представлено в виде смешанной дроби 2 1/4, а число -9/4 (минус девять четвертых) – в виде смешанной дроби: -2+(-1/4)=-(2 1/4).
class CRational
{
public:
// Возвращает представление рационального числа в виде смешанной дроби
std::pair<int, CRational> ToCompoundFraction()const;
};


Вариант 4. До 90 баллов
Реализуйте класс CTime, моделирующий время суток (количество часов, минут и секунд).
Каркас класса:
// моделирует время суток, задаваемое количеством часов (0-23), минут (0-59) и
// секунд (0-59)
class CTime
{
public:
// инициализирует время заданным количеством часов, минут и секунд
CTime(unsigned hours, unsigned minutes, unsigned seconds = 0);

	// инициализирует время количеством секунд после полуночи
	CTime(unsigned timeStamp = 0);

	// возвращает количество часов
	unsigned GetHours()const;

	// возвращает количество минут
	unsigned GetMinutes()const;

	// возвращает количество секунд
	unsigned GetSeconds()const;

	// возвращает информацию о корректности времени.
	// Например, после вызова конструктора CTime time(99, 32, 83);
	//	метод time.IsValid() должен возвращать false
	bool IsValid()const;
};
Реализуйте конструкторы и методы данного класса, а также следующие операторы.
№	Оператор	Описание
1	++ (префиксная и постфиксная формы)	Увеличивает время на 1 секунду
2	-- (префиксная и постфиксная формы)	Уменьшает время на 1 секунду
3	+	Выполняет сложение двух времен. Например:
14:30:25 + 03:18:44 = 17:49:09
4	-	Выполняет вычитание двух времен. Например:
14:30:25 - 03:18:44 = 11:11:41
5	+=
6	-=
7	*	Умножает время на целое число (и наоборот). Например:
03:05:15 * 3 = 3 * 03:05:15 = 09:15:45
8	/	2 формы:
Деление времени на целое число. Например:
09:15:40 / 3 = 03:05:13
Деление времени на время (нацело). Например:
09:15:40 / 03:05:13 = 3
9	*=
10	/=
11	<<	Оператор вывода времени в поток вывода в формате ЧЧ:ММ:СС, либо INVALID, если время невалидно
12	>>	Оператор ввода времени из потока ввода в формате ЧЧ:ММ:СС, либо INVALID, если время невалидно
13	== и !=	Проверка двух значений времени на равенство и неравенство
14	< и >	Проверка двух временных значений на строгое неравенство
15	<= и >=	Проверка двух временных значений на нестрогое неравенство
Результат выполнения арифметических операций, в которых один из аргументов является невалидным значением, должен также давать невалидное значение времени (см. примечание).
При выходе результата после выполнения операций за пределы диапазона 00:00:00 – 23:59:59 приводить результат к этому диапазону. Например:
23:59:59 + 00:00:03 = 00:00:02
00:00:05 – 00:00:10 = 23:59:55
Подсказка: данный класс будет проще реализовать, если вместо трех приватных переменных (часы, минуты и секунды) вы будете использовать только одну единственную переменную для хранения секунд после полуночи и все операции производить над нею.
Примечание: если проводить валидацию параметров в конструкторе и выбрасывать исключение в случае ошибки, то метод IsValid реализовывать не нужно. Автоматически решится проблема с выполнением арифметических операций, в которых участвуют невалидные значения времени.
В процессе разработки класса использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.
Вариант 5. До 220 баллов
Реализуйте класс CDate, моделирующий дату начиная с 1 января 1970 года. Каркас класса выглядит так:
// Месяц
enum class Month
{
JANUARY = 1, FEBRUARY, MARCH, APRIL,
MAY, JUNE, JULY, AUGUST, SEPTEMBER,
OCTOBER, NOVEMBER, DECEMBER
};

// День недели
enum class WeekDay
{
SUNDAY = 0, MONDAY, TUESDAY, WEDNESDAY,
THURSDAY, FRIDAY, SATURDAY
};

// Дата в формате день-месяц-год. Год в диапазоне от 1970 до 9999
class CDate
{
public:
// инициализируем дату заданными днем, месяцем и годом.
// примечание: год >= 1970
CDate(unsigned day, Month month, unsigned year);

	// инициализируем дату количеством дней, прошедших после 1 января 1970 года
	// например, 2 = 3 января 1970, 32 = 2 февраля 1970 года и т.д.
	CDate(unsigned timestamp = 0);

	// возвращает день месяца (от 1 до 31)
	unsigned GetDay()const;
	
	// возвращает месяц
	Month GetMonth()const;

	// возвращает год
	unsigned GetYear()const;

	// возвращает день недели
	WeekDay GetWeekDay()const;

	// возвращает информацию о корректности хранимой даты.
	// Например, после вызова CDate date(99, static_cast<Month>(99), 10983);
	// или после:
	//	CDate date(1, January, 1970); --date;
	// метод date.IsValid() должен вернуть false;
	bool IsValid()const;
};
Реализуйте конструкторы и методы данного класса, а также следующие операторы.
№	Оператор	Описание
1	++ (префиксная и постфиксная формы)	Переводит дату на следующий день
2	-- (префиксная и постфиксная формы)	Переводит дату на предыдущий день
3	+	Прибавляет к дате заданное целое количество дней. Например:
28/02/2010 + 3 = 03/03/2010
4	-	Реализовать 2 версии данного оператора:
Вычитает из даты заданное количество дней. Например:
01/01/2010 - 2 = 30/12/2009
Находит разность двух дат в днях. Например:
01/01/2010 - 30/12/2009 = 3
01/01/2010 - 03/01/2010 = -2
5	+=	<Дата> += <кол-во дней>
6	-=	<Дата> -= <кол-во дней>
7	<<	Оператор вывода даты в поток вывода в формате ДД.ММ.ГГГГ, либо INVALID, если дата является недопустимой
8	>>	Оператор ввода времени из потока ввода в формате ДД.ММ.ГГГГ, либо INVALID, если дата является недопустимой
9	== и !=	Проверка двух дат на равенство и неравенство
10	< и >	Проверка двух дат на строгое неравенство
11	<= и >=	Проверка двух дат на нестрогое неравенство
Результат применения данных операций к недопустимой дате не изменяет ее значения.
При выходе результата после выполнения операций за пределы диапазона 01:01:1970 – 31:12:9999 дата должна стать недопустимой.
Подсказка: данный класс будет проще реализовать, если вместо трех приватных переменных (день, месяц и год) вы будете использовать только одну единственную переменную для хранения количества дней после 1 января 1970 года и все операции производить над нею.
В процессе разработки класса использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.
Дополнительные задания
Задание 2 – До 300 баллов
Реализовать и протестировать класс CMyString, моделирующий строку произвольной длины.
Внимание, строка должна позволять хранить в середине символы с нулевым кодом . Проинициализировать такую строку можно при помощи конструктора, принимающего кроме адреса первого символа длину строки.
Каркас класса:
class CMyString
{
public:
// конструктор по умолчанию
CMyString();

	// конструктор, инициализирующий строку данными строки
// с завершающим нулевым символом
CMyString(const char * pString);

	// конструктор, инициализирующий строку данными из 
// символьного массива заданной длины
CMyString(const char * pString, size_t length);

	// конструктор копирования
	CMyString(CMyString const& other);

	// перемещающий конструктор (для компиляторов, совместимых с C++11)
	//  реализуется совместно с перемещающим оператором присваивания 
	CMyString(CMyString && other);

	// конструктор, инициализирующий строку данными из 
// строки стандартной библиотеки C++
CMyString(std::string const& stlString);

	// деструктор класса - освобождает память, занимаемую символами строки
	~CMyString();

	// возвращает длину строки (без учета завершающего нулевого символа)
	size_t GetLength()const;

	// возвращает указатель на массив символов строки.
	// В конце массива обязательно должен быть завершающий нулевой символ
	// даже если строка пустая 
	const char* GetStringData()const;

	// возвращает подстроку с заданной позиции длиной не больше length символов
	CMyString SubString(size_t start, size_t length = SIZE_MAX)const;

	// очистка строки (строка становится снова нулевой длины)
	void Clear();
};
Для хранения символов строки не допускается использовать классы вроде std::string и std::vector. Управление данными в динамической памяти должно быть реализовано целиком силами Вашего класса.
Внимание:
Реализуйте конструктор, деструктор и перечисленные в каркасе методы класса, а также следующие операторы:
№	Оператор	Описание
1	=	Присваивание CMyString (присваивание других типов, принимаемые конструктором класса будут реализованы автоматически)
Корректно должна обрабатываться ситуации с самоприсваиванием, вроде:
CMyString s(“SomeString”);
s = s;
2	+	Реализуйте следующие версии оператора конкатенации:
CMyString с CMyString
std::string с CMyString
const char* с CMyString
3	+=	Конкатенация CMyString с CMyString с присваиванием
4	==	Посимвольное сравнение содержимого двух строк
5	!=	Проверка двух строк на неравенство
6	<	Лексикографическое сравнение содержимого двух строк. Осуществляет проверку того, предшествует ли строка слева от знака «<» строке, находящейся справа, если сравнивать их содержимое в алфавитном порядке.
7	>	Лексикографическое сравнение содержимого двух строк. Аналогично оператору <
8	<= и >=	Лексикографическое сравнение содержимого двух строк. Аналогично оператор < и >
9	[]	Реализуйте две версии данного оператора:
Индексированный доступ к символам строки по целочисленному индексу для чтения
Индексированный доступ к символам строки по целочисленному индексу для записи
10	<<	Оператор вывода в выходной поток
11	>>	Оператор ввода из входного потока
12	Перемещающий конструктор и оператор присваивания	Реализуется совместно с перемещающим конструктором.
Бонус до 200 баллов за реализацию STL-совместимых итераторов,
Реализовать поддержку итераторов в STL-совместимой манере, позволяющих перебирать символы строки, использоваться совместно с основными алгоритмами стандартной библиотеки.
№	Функционал	Балл	Обязательно
1	Итерация по константным  и неконстантным строкам в прямом направлении и обратном направлении.
Получение итератора, указывающего на начальный символ и на позицию, следующую за конечным символом строки (аналоги методов begin()/end() класса std::string)
Разыменование итератора
Нахождение разницы между двумя итераторами, сложение итератора с числом и числа с итератором	100	Да
2	Индексированный  доступ к элементам строки относительно итератора при помощи оператора []	20	Нет
3	Поддержка итерации по символам строки в обратном направлении (аналогично итерации при помощи методов std::string::rbegin(), std::string::rend()).	30	Нет
4	Проверка границ (при помощи assert) в отладочной конфигурации.	30	Нет
5	Поддержка итерации по элементам при помощи range-based версии оператора for.
20	Нет
В процессе разработки классов использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.
