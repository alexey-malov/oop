# Лабораторная работа №2. Знакомство со стандартной библиотекой шаблонов языка C++

- [Лабораторная работа №2. Знакомство со стандартной библиотекой шаблонов языка C++](#лабораторная-работа-2-знакомство-со-стандартной-библиотекой-шаблонов-языка-c)
  - [Практические задания](#практические-задания)
    - [Важное замечание](#важное-замечание)
  - [Обязательные задания](#обязательные-задания)
    - [Задание 1. Основы работы с контейнером vector. 20 баллов](#задание-1-основы-работы-с-контейнером-vector-20-баллов)
      - [Вариант 1](#вариант-1)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных)
          - [Пример 1](#пример-1)
          - [Пример 2](#пример-2)
          - [Пример 3](#пример-3)
          - [Пример 4](#пример-4)
      - [Вариант 2](#вариант-2)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-1)
          - [Пример 1](#пример-1-1)
          - [Пример 2](#пример-2-1)
          - [Пример 3](#пример-3-1)
          - [Пример 4](#пример-4-1)
      - [Вариант 3](#вариант-3)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-2)
          - [Пример 1](#пример-1-2)
          - [Пример 2](#пример-2-2)
          - [Пример 3](#пример-3-2)
      - [Вариант 4](#вариант-4)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-3)
      - [Вариант 5](#вариант-5)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-4)
          - [Пример 1](#пример-1-3)
          - [Пример 2](#пример-2-3)
          - [Пример 3](#пример-3-3)
      - [Вариант 6](#вариант-6)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-5)
          - [Пример 1](#пример-1-4)
          - [Пример 2](#пример-2-4)
          - [Пример 3](#пример-3-4)
      - [Вариант 7](#вариант-7)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-6)
          - [Пример 1](#пример-1-5)
          - [Пример 2](#пример-2-5)
          - [Пример 3](#пример-3-5)
      - [Вариант 8](#вариант-8)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-7)
          - [Пример 1](#пример-1-6)
          - [Пример 2](#пример-2-6)
          - [Пример 3](#пример-3-6)
    - [Задание 2 – работа с контейнером string](#задание-2--работа-с-контейнером-string)
      - [Вариант 1 – TrimBlanks – 20 баллов](#вариант-1--trimblanks--20-баллов)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-8)
          - [Пример 1](#пример-1-7)
          - [Пример 2](#пример-2-7)
          - [Пример 3](#пример-3-7)
      - [Вариант 2 – RemoveExtraSpaces – 30 баллов](#вариант-2--removeextraspaces--30-баллов)
        - [Примеры ввода-вывода](#примеры-ввода-вывода)
      - [Вариант 3 – FindAndReplace – 40 баллов](#вариант-3--findandreplace--40-баллов)
      - [Вариант 4 – HTML Encode – 40 баллов](#вариант-4--html-encode--40-баллов)
      - [Вариант 5 – HTML Decode – 60 баллов](#вариант-5--html-decode--60-баллов)
    - [Задание 3 – работа с контейнером map](#задание-3--работа-с-контейнером-map)
      - [Вариант 1- Подсчет частоты встречаемости слов – 40 баллов](#вариант-1--подсчет-частоты-встречаемости-слов--40-баллов)
        - [Бонус 10 баллов за подсчет слов, записанных в case-insensitive формате](#бонус-10-баллов-за-подсчет-слов-записанных-в-case-insensitive-формате)
      - [Вариант 2 – мини-словарь – 90 баллов](#вариант-2--мини-словарь--90-баллов)
        - [Бонус 10 баллов за возможность распознавания слов, записанных в разном регистре](#бонус-10-баллов-за-возможность-распознавания-слов-записанных-в-разном-регистре)
        - [Бонус 20 баллов за реализацию двунаправленного перевода](#бонус-20-баллов-за-реализацию-двунаправленного-перевода)
    - [Задание 4. Работа с контейнером set](#задание-4-работа-с-контейнером-set)
      - [Вариант 1 – Cross Sets - 30 баллов](#вариант-1--cross-sets---30-баллов)
        - [Формат входных данных](#формат-входных-данных)
        - [Формат выходных данных](#формат-выходных-данных)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-9)
          - [Пример 1](#пример-1-8)
          - [Пример 2](#пример-2-8)
      - [Вариант 2 – Спортшкола – 40 баллов](#вариант-2--спортшкола--40-баллов)
      - [Вариант 3 – Фильтр нецензурных слов – 60 баллов](#вариант-3--фильтр-нецензурных-слов--60-баллов)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-10)
        - [Бонус в 10 баллов за распознавание нецензурных слов, записанных в разном регистре](#бонус-в-10-баллов-за-распознавание-нецензурных-слов-записанных-в-разном-регистре)
      - [Вариант 4 – Генератор простых чисел – 100 баллов](#вариант-4--генератор-простых-чисел--100-баллов)
  - [Дополнительные задания](#дополнительные-задания)
    - [Задание 5. – регулярные выражения](#задание-5--регулярные-выражения)
      - [Вариант 1 – парсер URL-ов – 80 баллов](#вариант-1--парсер-url-ов--80-баллов)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-11)
          - [Пример 1](#пример-1-8)
          - [Пример 2](#пример-2-8)
          - [Пример 3](#пример-3-7)
          - [Пример 4](#пример-4-2)
    - [Задание 6](#задание-6)
      - [Вариант №1 – Expand Template – 100 баллов ](#вариант-1--expand-template--100-баллов-)
        - [Правила подстановки](#правила-подстановки)
        - [Формат входных данных](#формат-входных-данных-1)
        - [Формат выходных данных](#формат-выходных-данных-1)
        - [Сообщения об ошибках](#сообщения-об-ошибках)
        - [Примеры использования программы](#примеры-использования-программы)
        - [Требования к тестированию](#требования-к-тестированию)
        - [Примеры входных и выходных данных](#примеры-входных-и-выходных-данных-12)
          - [Пример 1: Базовая подстановка параметров](#пример-1-базовая-подстановка-параметров)
          - [Пример 2: Шаблонный параметр с пустым значением](#пример-2-шаблонный-параметр-с-пустым-значением)
          - [Пример 3: Подстановка с вложенными параметрами](#пример-3-подстановка-с-вложенными-параметрами)
          - [Пример 4: Выбор наиболее длинного совпадения](#пример-4-выбор-наиболее-длинного-совпадения)
          - [Пример 5: Неуникальный ключ](#пример-5-неуникальный-ключ)
          - [Пример 6: Отсутствует текст-шаблон](#пример-6-отсутствует-текст-шаблон)
        - [Бонус в 150 баллов за эффективное решение данной задачи с использованием алгоритма Ахо-Корасик](#бонус-в-150-баллов-за-эффективное-решение-данной-задачи-с-использованием-алгоритма-ахо-корасик)
    - [Задание 7](#задание-7)
      - [Вариант 1 — разбор выражения — 100 баллов](#вариант-1--разбор-выражения--100-баллов)
        - [Бонус в 50 баллов за обработку ошибок](#бонус-в-50-баллов-за-обработку-ошибок)
        - [Бонус в 80 баллов за нерекурсивное решение задачи](#бонус-в-80-баллов-за-нерекурсивное-решение-задачи)

## Практические задания

Для получения оценки «**удовлетворительно**» необходимо набрать **не менее 80 баллов**.

Для получения оценки «**хорошо**» необходимо набрать **не менее 300 баллов**.

Для получения оценки «**отлично**» необходимо набрать **не менее 500 баллов**.

**Внимание**, дополнительные задания принимаются только после успешной защиты обязательных заданий.

### Важное замечание

<span style="color:red">При выполнении заданий следует отдавать предпочтение использованию алгоритмов STL, нежели написанию «сырых» циклов.
Рекомендуется посмотреть доклад (англ.) C++ Seasoning c конференции Going Native 2013, доступный по ссылке:</span>

<https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning>

## Обязательные задания

### Задание 1. Основы работы с контейнером vector. 20 баллов

Ознакомьтесь с возможностями класса [vector](https://en.cppreference.com/w/cpp/container/vector) библиотеки STL,
а также с основными [алгоритмами STL](https://en.cppreference.com/w/cpp/algorithm).

Разработайте программу, которая считывает из stdin в std::vector массив чисел с плавающей запятой.
Числа разделяются пробелами, табуляциями и символами перевода строки.

Программа должна обработать вектор чисел согласно заданию выбранного вами варианта
и вывести результирующие элементы в stdout в порядке неубывания.
Числа должны быть разделены пробелом и выводиться с точностью 3 знака после запятой.
Например, число `3.1415927` должно быть выведено как `3.142`, а число `2.3` — как `2.300`.

В программе должны быть выделены функции:

- Функция `ReadNumbers`, которая считывает числа в vector.
- Функция `ProcessNumbers`, которая обрабатывает переданный ей vector.
- Функция `PrintSortedNumbers`, которая выводит переданный ей вектор в порядке неубывания.
  Эта функция не должна модифицировать переданный ей vector видимым для вызывающего кода образом.

**Подсказка**: чтобы вывести числа с желаемой точностью, воспользуйтесь манипуляторами вывода в поток:
[std::setprecision](https://en.cppreference.com/w/cpp/io/manip/setprecision), и [std::fixed](https://en.cppreference.com/w/cpp/io/manip/fixed).

Пустой массив, переданный программе – допустимые входные данные. При его обработке пустой массив должен оставаться пустым.

Если входные данные некорректны (например, содержат нечисловые значения),
программа должна выводить в стандартный поток вывода «**ERROR**» и завершиться с **кодом возврата 0**.
Это необходимо для корректного тестирования программы в системе Яндекс.Contest

<span style="color:red">Для тестирования разрабатываемых функций должны быть разработаны тесты,
проверяющие корректность их работы на некотором разумном наборе входных параметров.</span>

#### Вариант 1

Прибавить к каждому элементу массива среднее арифметическое его положительных элементов.
Подсказка: используйте алгоритм `std::accumulate`, чтобы найти сумму положительных элементов.

##### Примеры входных и выходных данных

###### Пример 1

Ввод:

```txt
1.0 2 3.659512
```

Вывод:

```txt
3.220 4.220 5.879
```

Объяснение: среднее арифметическое равно 2.2198373,
прибавляем его к всем элементам и округляем результат до трёх знаков и выводим в порядке неубывания.

###### Пример 2

Ввод:

```txt
4 16 -30 10
```

Вывод:

```txt
-20.000 14.000 20.000 26.000
```

Объяснение: положительные числа - 4, 16, 10, их среднее арифметическое - 10, прибавляем его к всем элементам,
выводим в порядке неубывания.

###### Пример 3

Ввод:

```txt
-1.0004000 -703 -3.659512 -11
```

Вывод:

```txt
-703.000 -11.000 -3.660 -1.000
```

Объяснение: все числа отрицательные, выводим их в порядке неубывания без изменений, с точностью в три знака после запятой.

###### Пример 4

Ввод:

```txt
- 2 3
```

Вывод:

```txt
ERROR
```

Объяснение: "-" - символ, выводим сообщение об ошибке, неправильно введено значение.

#### Вариант 2

Каждый элемент массива должен быть умножен на минимальный элемент исходного массива.
Подсказка: используйте алгоритм `std::min_element`, чтобы найти минимальный элемент массива.

##### Примеры входных и выходных данных

###### Пример 1

Ввод:

```txt
2.0 4 -1.5
```

Вывод:

```txt
-3.000 -6.000 2.250
```

Объяснение: минимальный элемент - -1.5, умножаем каждый элемент массива на -1.5.

###### Пример 2

Ввод:

```txt
10 7 4
```

Вывод:

```txt
40.000 28.000 16.000
```

Объяснение: минимальный элемент - 4, умножаем каждый элемент массива на 4.

###### Пример 3

Ввод:

```txt
-1.5 -2.0 -3.0
```

Вывод:

```txt
4.500 6.000 9.000
```

Объяснение: минимальный элемент - -3.0, умножаем каждый элемент массива на -3.0.

###### Пример 4

Ввод:

```txt
abc 4.5 7
```

Вывод:

```txt
ERROR
```

Объяснение: `abc` не является числом, выводим сообщение об ошибке.

#### Вариант 3

Разделите элементы массива на половину максимального элемента.
Подсказка: используйте алгоритм `std::max_element`.

##### Примеры входных и выходных данных

###### Пример 1

Ввод:

```txt
20 30 40 56
```

Вывод:

```txt
0.714 1.071 1.429 2.000
```

Объяснение: каждый элемент разделили на 28, так как максимальный элемент равен 56.

- 20 / (56 / 2) = 0.714
- 30 / (56 / 2) = 1.071  
- 40 / (56 / 2) = 1.429  
- 56 / (56 / 2) = 2.000  

###### Пример 2

Ввод:

```txt
1.0 2.0 3.0 4.0
```

Вывод:

```txt
0.500 1.000 1.500 2.000
```

Объяснение: каждый элемент разделили на 2, так как максимальный элемент равен 4.0.

- 1.0 / (4.0 / 2) = 0.500  
- 2.0 / (4.0 / 2) = 1.000
- 3.0 / (4.0 / 2) = 1.500  
- 4.0 / (4.0 / 2) = 2.000  

###### Пример 3

Ввод:

```txt
-1.0 -2.0 -3.0
```

Вывод:

```txt
2.000 4.000 6.000
```

Объяснение: каждый элемент разделили на -0.5, так как максимальный элемент равен -1.0

- -1.0 / (-1.0 / 2) = 2.000  
- -2.0 / (-1.0 / 2) = 4.000
- -3.0 / (-1.0 / 2) = 6.000

#### Вариант 4

Умножить каждый отрицательный элемент массива на произведение максимального и минимального элементов исходного массива.
Подсказка: используйте `std::minmax_element`, чтобы найти минимальный и максимальный элементы массива.

##### Примеры входных и выходных данных

#### Вариант 5

Умножить каждый элемент массива на максимальный элемент исходного массива и разделить
на минимальный элемент исходного массива. В случае, если минимальное значение массива равно нулю,
программа должна вывести в стандартный поток вывода «**ERROR**» и завершиться с **кодом возврата 0**.
Подсказка: используйте `std::minmax_element`, чтобы найти минимальный и максимальный элементы.

##### Примеры входных и выходных данных

###### Пример 1

Ввод:

```txt
1 2 3
```

Вывод:

```txt
3.000 6.000 9.000
```

Объяснение: минимальное число - 1, максимальное - 3. Мы умножаем каждое число на 3 и делим на 1

- (1 × 3) / 1 = 3.000  
- (2 × 3) / 1 = 6.000  
- (3 × 3) / 1 = 9.000  

###### Пример 2

Ввод:

```txt
3.5 1 2 -1
```

Вывод:

```txt
-12.250 -7.000 -3.500 3.500
```

Объяснение: минимальное число - (-1), максимальное - 3.5. Мы умножаем каждое число на 3.5 и делим на (-1)

- (3.5 × 3.5) / (-1) = -12.250  
- (2 × 3.5) / (-1) = -7.000  
- (1 × 3.5) / (-1) = -3.500  
- (-1 × 3.5) / (-1) = 3.500  

###### Пример 3

Ввод:

```txt
1 a 2
```

Вывод:

```txt
ERROR
```

Объяснение: программа выводит «ERROR», поскольку введенные данные содержат недопустимый символ «a»,
который не является числом.

#### Вариант 6

Прибавить к каждому элементу массива сумму трех минимальных элементов массива.
Если массив содержит меньше трех элементов, надо прибавить сумму имеющихся.
Подсказка: используйте `std::partial_sort_copy`, чтобы найти три минимальных элемента.

##### Примеры входных и выходных данных

###### Пример 1

Ввод:

```txt
1 2 3
```

Вывод:

```txt
7.000 8.000 9.000
```

Объяснение: сумма трех минимальных элементов массива равна 6 (1 + 2 + 3 = 6).
Прибавляем эту сумму к каждому элементу массива - (1 + 6 = 7), (2 + 6 = 8), (3 + 6 = 9).

###### Пример 2

Ввод:

```txt
5 2
```

Вывод:

```txt
9.000 12.000
```

Объяснение: так как в массиве меньше трёх элементов, мы берём сумму всех имеющихся элементов - (5 + 2 = 7).
Прибавляем эту сумму к каждому элементу массива - (5 + 7 = 12), (2 + 7 = 9).

###### Пример 3

Ввод:

```txt
1 a 2
```

Вывод:

```txt
ERROR
```

Объяснение: программа выводит «ERROR», поскольку введенные данные содержат недопустимый символ «a»,
который не является числом.

#### Вариант 7

Элементы, стоящие на четных позициях массива умножить на 2,
а из элементов, стоящих на нечетных позициях, вычесть сумму всех неотрицательных элементов.
Подсказка: используйте `std::accumulate`, чтобы найти сумму неотрицательных элементов.

##### Примеры входных и выходных данных

###### Пример 1

Ввод:

```txt
1 -2 3 4
```

Вывод:

```txt
-10.000 -4.000 2.000 6.000
```

Объяснение: элементы на чётных позициях умножаем на 2,
а из элементов на нечётных позициях вычитаем сумму неотрицательных чисел (1 + 3 + 4 = 8)

- 1 × 2 = 2  
- -2 - 8 = -10  
- 3 × 2 = 6  
- 4 - 8 = -4  

###### Пример 2

Ввод:

```txt
-3 -2 -1
```

Вывод:

```txt
-6.000 -2.000 -2.000
```

Объяснение: элементы на чётных позициях умножаем на 2,
а из элементов на нечётных позициях вычитаем сумму неотрицательных чисел
(в данном случае неотрицательных чисел нет, поэтому сумма равна 0)

- -3 × 2 = -6
- -2 - 0 = -2
- -1 × 2 = -2

###### Пример 3

Ввод:

```txt
1 a 2
```

Вывод:

```txt
ERROR
```

Объяснение: программа выводит «ERROR», поскольку введенные данные содержат недопустимый символ «a»,
который не является числом.

#### Вариант 8

Вычесть из каждого элемента исходного массива значение его медианы,
при этом для четного количества элементов медианой считать среднее значение двух центральных элементов.
Подсказка: используйте алгоритм `std::nth_element`, чтобы найти медианный элемент массива.
Учтите, что `nth_element` изменяет порядок элементов контейнера.

##### Примеры входных и выходных данных

###### Пример 1

Ввод:

```txt
4 1 7 3 9
```

Вывод:

```txt
-3.000 -1.000 0.000 3.000 5.000
```

Объяснение: медиана массива - 4, так как после сортировки [1, 3, 4, 7, 9] центральный элемент - это 4.
Из каждого числа вычитаем медиану:

- 4 - 4 = 0.000
- 1 - 4 = -3.000
- 7 - 4 = 3.000
- 3 - 4 = -1.000
- 9 - 4 = 5.000

###### Пример 2

Ввод:

```txt
10 30 20 40
```

Вывод:

```txt
-15.000 -5.000 5.000 15.000
```

Объяснение: медиана массива - это среднее арифметическое двух центральных элементов.
После сортировки массива [10, 20, 30, 40] два центральных элемента - это 20 и 30.
Среднее арифметическое этих элементов: (20 + 30) / 2 = 25.
Из каждого числа вычитаем медиану:

- 10 - 25 = -15.000
- 30 - 25 = 5.000
- 20 - 25 = -5.000
- 40 - 25 = 15.000

###### Пример 3

Ввод:

```txt
1 a 2
```

Вывод:

```txt
ERROR
```

Объяснение: программа выводит «ERROR», поскольку введенные данные содержат недопустимый символ «a»,
который не является числом.

### Задание 2 – работа с контейнером string

Ознакомьтесь с возможностями класса [string](https://en.cppreference.com/w/cpp/string/basic_string) (точнее, шаблона basic_string) библиотеки STL и
выполните задание, соответствующее номеру Вашего варианта.

<span style="color:red">Для тестирования разрабатываемых функций должны быть разработаны тесты,
проверяющие корректность их работы на некотором разумном наборе входных параметров.</span>

#### Вариант 1 – TrimBlanks – 20 баллов

Разработайте функцию

```c++
std::string TrimBlanks(std::string const& str)
```

выполняющую отрезание пробелов в начале и в конце строки str, и возвращающую результирующую строку.
Если строка состоит из одних пробелов, должна вернуться пустая строка.

Разработайте на ее основе программу, выполняющую отрезание пробелов в начале и конце **каждой строки**,
поступающей со стандартного потока ввода, и выводящую результат в стандартный поток вывода.

<span style="color:red">Внимание, реализация данной функции должна иметь сложность не более O(N).</span>

##### Примеры входных и выходных данных

###### Пример 1

Ввод:

```txt
hello
```

Вывод:

```txt
hello
```

Объяснение: у входной строки нет лишних пробелов, выводим "hello".

###### Пример 2

Ввод:

```txt
 hello
```

Вывод:

```txt
hello
```

Объяснение: у входной строки есть один пробел слева, обрезаем его, выводим "hello".

###### Пример 3

Ввод:

```txt
 hello 
```

Вывод:

```txt
hello
```

Объяснение: у входной строки есть один пробел слева и справа, обрезаем оба пробела, выводим "hello".

#### Вариант 2 – RemoveExtraSpaces – 30 баллов

Разработайте функцию

```c++
std::string RemoveExtraSpaces(std::string const& arg)
```

удаляющую из строки, переданной в параметре arg, лишние пробелы.
Лишними считаются все пробелы в начале и конце строки, а также дополнительные пробелы между словами.

Разработайте с ее использованием программу, выполняющую удаление лишних пробелов
из каждой строки входного потока символов и вывод результирующих строк в выходной поток.

<span style="color:red">Внимание, реализация данной функции должна иметь сложность не более O(N)</span>

##### Примеры ввода-вывода

Пользователь ввёл в консоль:

```txt
   abcd    2   qwe    ee e e   
```

Ожидаемый вывод:

```txt
abcd 2 qwe ee e e
```

#### Вариант 3 – FindAndReplace – 40 баллов

Разработайте функцию

```c++
std::string FindAndReplace(std::string const& subject, std::string const& search, std::string  const& replace)
```

возвращающую результат замены всех вхождений подстроки **search** в строке **subject** на строку **replace**.
Если искомая строка пустая, замены строк производиться не должно.

Вычислительная сложность алгоритма, лежащего в основе FindAndReplace, должна линейно зависеть от длины строки Subject

Разработайте на ее основе программу, заменяющую все вхождения искомой строки в стандартном потоке ввода на строку-заменитель и выводящую результат в стандартный поток вывода.
Чтение и замена вхождений подстроки должны проводиться строка за строкой. Ввод продолжается до появления символа конца файла в стандартном потоке ввода.

Синтаксис командной строки:

```sh
replace.exe <search-string> <replace-string>
```

<span style="color:red">Внимание, реализация данной функции должна иметь сложность близкую к O(N+M+k*L),
где N - длина текста, M - длина искомой строки, L - длина строки-заменителя, а k - количество вхождений искомой строки в тексте.</span>

Подсказка: воспользуйтесь алгоритмом [std::search](https://en.cppreference.com/w/cpp/algorithm/search)

#### Вариант 4 – HTML Encode – 40 баллов

Разработайте функцию

```c++
std::string HtmlEncode(std::string const& text)
```

выполняющую кодирование специальных символов строки text соответствующими сущностями HTML:

- `"` (двойная кавычка) заменяется на `&quot;`
- `'` (апостроф) заменяется на `&apos;`
- `<` (знак меньше) заменяется на `&lt;`
- `>` (знак больше) заменяется на `&gt;`
- `&` (амперсанд) заменяется на `&amp;`

Например, строка `Cat <says> "Meow". M&M’s` должна быть преобразована в строку
`Cat &lt;says&gt; &quot;Meow&quot;. M&amp;M&apos;s`

Разработайте на ее основе программу, выполняющую построчное html-кодирование текста, поступающего со стандартного потока ввода, и выводящую результат в стандартный поток вывода.

Символы &, полученные в процессе кодирования, не должны повторно кодироваться.

<span style="color:red">Внимание, реализация данной функции должна иметь сложность близкую к O(N)</span>

#### Вариант 5 – HTML Decode – 60 баллов

Разработайте функцию

```c++
std::string HtmlDecode(std::string const& html)
```

выполняющую декодирование HTML-сущностей строки **html**, перечисленных в варианте 4, обратно в их символьное представление.

Разработайте на ее основе программу, выполняющую построчное декодирование html-сущностей текста, поступающего со стандартного потока ввода,
и выводящую результат в стандартный поток вывода.

<span style="color:red">Внимание, реализация данной функции должна иметь сложность близкую к O(N)</span>

### Задание 3 – работа с контейнером map

Ознакомьтесь с возможностями контейнера [std::map](https://en.cppreference.com/w/cpp/container/map) библиотеки STL и выполните задание, соответствующее номеру Вашего варианта.

<span style="color:red">Для тестирования разрабатываемых функций должны быть разработаны тесты, проверяющие корректность их работы на некотором разумном наборе входных параметров.</span>

#### Вариант 1- Подсчет частоты встречаемости слов – 40 баллов

Разработайте программу, выполняющую подсчет частоты встречаемости слов, поступающих со стандартного потока ввода и выводящую слова их частоты их встречаемости в стандартный поток вывода.

Под словом понимается последовательность из одного и более символов, не являющихся пробелами, табуляциями, символами конца строки.

Частота встречаемости слов должна выводиться после того, как входной поток данных закончится (eof).

Для подсчета частоты встречаемости символов используйте отображение **слово→частота встречаемости**.

##### Бонус 10 баллов за подсчет слов, записанных в case-insensitive формате

**Дополнительно можно получить до 10 баллов**, если программа будет способна обнаруживать русские и английские слова, записанные в разном регистре символов,
т.е. считать слова **HeLLo** и **heLLO** одинаковыми.

#### Вариант 2 – мини-словарь – 90 баллов

Разработайте программу-словарь, осуществляющую перевод **слов и словосочетаний**, поступающих со стандартного потока ввода,
**с английского языка на русский** с использованием заданного файла словаря и выводящую результат перевода в стандартный поток вывода.

Если вводимое слово или словосочетание, отсутствует в словаре, программа должна попросить пользователя ввести перевод и запомнить его, в случае, если пользователь ввел непустую строку.

**Для выхода из диалога с программой** пользователь должен ввести строку, **состоящую из трех точек**.
Перед выходом программа спрашивает о необходимости сохранить изменения в файле словаря, в том случае, **если в словарь были добавлены фразы** во время текущей сессии работы с программой.

Имя файла словаря передается программе с помощью параметра командной строки.
Если файл словаря отсутствует, то программа должна считать его пустым и предложить сохранить словарь по окончании работы, если туда были добавлены фразы.

Пример диалога <span style="color:red">пользователя</span> с <span style="color:#4682B4">программой</span>:

```txt
>cat
кот, кошка
>ball
мяч
>meat
Неизвестное слово “meat”. Введите перевод или пустую строку для отказа.
>мясо
Слово “meat” сохранено в словаре как “мясо”.
>meat
мясо
>The Red Square
Неизвестное слово “The Red Square”. Введите перевод или пустую строку для отказа.
>Красная Площадь
Слово “The Red Square” сохранено в словаре как “Красная Площадь”.
>lkkvksmdv
Неизвестное слово “lkkvksmdv”. Введите перевод или пустую строку для отказа.
>
Слово “lkkvksmdv”проигнорировано.
>...
В словарь были внесены изменения. Введите Y или y для сохранения перед выходом.
>y
Изменения сохранены. До свидания.
```

##### Бонус 10 баллов за возможность распознавания слов, записанных в разном регистре

<span style="color:red">Дополнительно можно получить до 10 баллов</span>, если программа будет способна осуществлять перевод английских слов,
вводимых пользователем в произвольном регистре символов. Например, слова **CaT**, при известном переводе для слова **cat**. Регистр перевода теряться не должен.

##### Бонус 20 баллов за реализацию двунаправленного перевода

<span style="color:red">Дополнительно можно получить до 20 баллов</span>, если программа сможет осуществлять и обратный перевод словосочетаний.
При этом необходимо поддержать возможность существования **нескольких вариантов** перевода одного и того же слова.

Например, после добавления слов «кошка»→«cat» и «кот»→«cat», программа должна иметь возможность перевести слово cat, выдав 2 возможных перевода.

### Задание 4. Работа с контейнером set

Ознакомьтесь с возможностями контейнера [std::set](https://en.cppreference.com/w/cpp/container/set) и выполните задание, соответствующее номеру Вашего варианта.

<span style="color:red">Для тестирования разрабатываемых функций должны быть разработаны тесты, проверяющие корректность их работы на некотором разумном наборе входных параметров.</span>

#### Вариант 1 – Cross Sets - 30 баллов

Разработайте функцию

```c++
std::set<int> CrossSet(std::set<int> const& set1, std::set<int> const& set2);
```

возвращающую результат пересечения (пересечением двух множеств является множество, содержащее элементы,
присутствующие одновременно и в первом и во втором множестве) двух множеств целых чисел.

С ее использованием разработайте программу, выводящую в стандартный поток вывода элементы двух множеств целых чисел
и результат их пересечения.

Программа должна поддерживать три режима работы:

- **Ввод через командную строку:** Программа принимает число N в качестве параметра командной строки.
- **Ввод через stdin:** Если программа запускается без параметров, она должна принимать
число N из стандартного потока ввода (stdin).
- **Справка:** Если программа запускается с параметром **-h**, она должна вывести краткую справку
об использовании программы и завершить выполнение.

Описание множеств:

- **Первое множество** – множество чисел от 1 до N, делящихся без остатка на сумму своих цифр.

- **Второе множество** – множество целых чисел то 1 до N, сумма цифр которых является четной.

**Подсказка**: используйте алгоритм **set_intersection**.

##### Формат входных данных

Программа принимает одно целое положительное число N.

В случае **некорректных** входных данных:

- Если программа запущена с параметром командной строки, она должна вывести в стандартный поток вывода «**ERROR**»
и завершиться с кодом возврата 1.
- Если программа запущена без параметров (режим stdin), она должна вывести в стандартный поток вывода «**ERROR**»
и завершиться с кодом возврата 0.
  Это необходимо для корректного тестирования программы в системе Яндекс.Contest

##### Формат выходных данных

Программа должна вывести три строки:

- Элементы первого множества.
- Элементы второго множества.
- Элементы пересечения первого и второго множества.

Элементы в каждой строке должны быть отсортированы в порядке неубывания и разделены пробелами.
Если множество пустое, оставьте строку пустой.

##### Примеры входных и выходных данных

###### Пример 1

Ввод:

```txt
20
```

Вывод:

```txt
1 2 3 4 5 6 7 8 9 10 12 18 20
2 4 6 8 11 13 15 17 19 20
2 4 6 8 20
```

Объяснение:
Первое множество: включает числа, которые делятся на сумму своих цифр без остатка.
Например, для числа 18 сумма цифр = 1 + 8 = 9, и 18 делится на 9 без остатка, поэтому 18 входит в первое множество.
Для числа 19 сумма цифр = 1 + 9 = 10, но 19 не делится на 10, без остатка, поэтому 19 не входит в первое множество.

Второе множество: включает числа с чётной суммой цифр.
Например, у числа 13 сумма цифр = 1 + 3 = 4 (чётное), поэтому 13 входит во второе множество.
У числа 14 сумма цифр = 1 + 4 = 5 (нечётное), поэтому 14 не входит во второе множество.

Пересечение включает числа, которые соответствуют условиям обоих множеств - `2 4 6 8 20`.

###### Пример 2

Ввод:

```txt
-5
```

Вывод:

```txt
ERROR
```

Объяснение: Программа выводит «ERROR», так как N должно быть положительным числом.

#### Вариант 2 – Спортшкола – 40 баллов

В спортивной школе обучается некоторое количество учеников. Имена учеников – уникальны. Каждый ученик посещает одну или более спортивных секций школы.

У тренера каждой секции есть список учеников его секции, заданный в виде текстового файла, в котором в каждой строке записано ФИО ученика.

***Задача***: на основе файлов со списками учеников каждого тренера построить список всех учеников школы.

Программа принимает в качестве параметров командной строки имена файлов со списками учеников каждой секции (количество секций в школе, а,
следовательно, параметров командной строки – произвольно) и выводит в output список всех учащихся школы.

#### Вариант 3 – Фильтр нецензурных слов – 60 баллов

Для повышения культуры общения в чате необходимо написать программу-фильтр,
удаляющую из сообщений участников чата недопустимые слова.

Список недопустимых слов задается в первой строке из стандартного потока ввода.
Слова разделены последовательностью из одного и более пробелов или табуляций.

Все последующие строки, вводимые из стандартного потока ввода, являются текстом,
из которого нужно убрать недопустимые слова.
После обработки каждой строки нужно вывести результат в стандартный поток вывода.
Выводимые слова должны быть разделены одним пробелом.

Под словом понимается последовательность из одного и более символов,
разделенных последовательностью из одного и более символов-разделителей
(пробелы, табуляции, символы конца строки, знаки препинания, знаки арифметических операций, скобки).

**Указания**: считайте недопустимые слова во множество строк и при обработке текста
проверяйте вхождение каждого слова текста в данное множество.

##### Примеры входных и выходных данных

Ввод:

```txt
  stupid   idiot 
  This   stupid    idiot believes that   the Sun
rotates   around   the    Earth.   
```

Вывод:

```txt
This believes that the Sun
rotates around the Earth.
```

Объяснение: слова stupid и idiot вырезаны из каждой строки вводимого текста. Выводимые слова разделяются одним пробелом.

##### Бонус в 10 баллов за распознавание нецензурных слов, записанных в разном регистре

<span style="color:red">Дополнительно можно получить 10 баллов</span>,
если фильтрация слов будет производиться с **игнорированием регистра символов**, в котором они записаны.
Т.е. если недопустимым словом является слово «fool», то должны фильтроваться слова «FoOl», «foOl», «FOOL» и подобные.

#### Вариант 4 – Генератор простых чисел – 100 баллов

Разработайте функцию 

```c++
std::set<int> GeneratePrimeNumbersSet(int upperBound)
```

возвращающую множество всех простых чисел, **не превышающих** значения upperBound.

С ее использованием разработайте программу, выводящую в стандартный поток вывода элементы множества простых чисел,
не превышающие значения, переданного приложению через обязательный параметр командной строки.

Максимальное значение верхней границы множества принять равным 100 миллионам.

Время построения множества простых чисел в указанном диапазоне на компьютере с 2GHz-процессором не должно превышать 10-12 секунд (программа будет запускаться в Release-конфигурации).

Примечание: наивный поиск простых чисел не позволит добиться указанной производительности. Используйте «Решето Эратосфена».
Для предварительного просеивания воспользуйтесь `vector<bool>` (для хранения каждого элемента он использует 1 бит информации,
т.к. на хранение признака простоты 100 миллионов чисел потребуется всего 12,5 мегабайт памяти)

Для проверки программы используйте тот факт, что в диапазоне от 1 до 100000000 содержится 5761455 простых чисел.

## Дополнительные задания

### Задание 5. – регулярные выражения

Ознакомьтесь с возможностями класса [std::regex](https://cplusplus.com/reference/regex/) и функций для работы с регулярными выражениями библиотеки STL и выполните задание, соответствующее номеру Вашего варианта.

<span style="color:red">Для тестирования разрабатываемых функций должны быть разработаны тесты, проверяющие корректность их работы на некотором разумном наборе входных параметров.</span>

#### Вариант 1 – парсер URL-ов – 80 баллов

Разработайте функцию

```c++
bool ParseURL(string const& url, Protocol &  protocol, int & port, string & host, string & document)
```

выполняющую разбор строки url, и извлечение из нее информации об используемом протоколе, номере порта, имени хоста и имени документа.

В случае успеха функция должна возвращать true, в случае ошибки – false.

Protocol – это перечислимый тип, задающий один из известных программе протоколов:

```c++
enum class Protocol
{
    HTTP,
    HTTPS,
    FTP
};
```

Валидным (допустимым) URL-ом программа должна считать строку в следующем формате:

`протокол://хост[:порт][/документ]`, 

где протокол – http, https или ftp (**в любом регистре**),

порт – положительное число от 1 до 65535

хост – **непустая строка**

(в квадратных скобках указаны опциональные элементы URL-а)

Если порт не указан, то он должен считаться равным номеру порта по умолчанию для данного протокола (для HTTP – это 80, для HTTPS – 443, для FTP – 21).

Разработайте на ее основе программу, распознающую допустимые URL-строки в каждой вводимой пользователем строке ввода и выводящую в стандартный поток вывода информацию о **каждом URL-е** в следующем формате:

```sh
<Исходный URL>
HOST: <хост>
PORT: <порт>
DOC: <документ>
```

Если входные данные некорректны (например, не указан протокол http/https),
программа должна выводить в стандартный поток вывода «ERROR» и завершиться с кодом возврата 0.
Это необходимо для корректного тестирования программы в системе Яндекс.Contest.

##### Примеры входных и выходных данных

###### Пример 1

Ввод:

```txt
http://example.com
```

Вывод:

```txt
http://example.com
HOST: example.com
PORT: 80
DOC: 
```

Объяснение: в первой строке выводится переданная URL-строка, во второй — домен,
в третьей выводится порт по умолчания для http - 80.

###### Пример 2

Ввод:

```txt
htTp://example.com:8080/index.html
```

Вывод:

```txt
htTp://example.com:8080/index.html
HOST: example.com
PORT: 8080
DOC: index.html
```

Объяснение: в первой строке выводится переданная URL-строка, во второй — домен,
в третьей — порт, в четвертой выводится документ.

###### Пример 3

Ввод:

```txt
htp://example.com
```

Вывод:

```txt
ERROR
```

Объяснение: передан неправильный протокол, выводим "ERROR".

###### Пример 4

Ввод:

```txt
http://www.mysite.com/docs/document1.html?page=30&lang=en#title
```

Вывод:

```txt
http://www.mysite.com/docs/document1.html?page=30&lang=en#title
HOST: www.mysite.com
PORT: 80
DOC: docs/document1.html?page=30&lang=en#title
```

Объяснение: в первой строке выводится переданная URL-строка,
во второй — домен, в третьей выводится порт по умолчания для http — 80,
в четвертой выводится путь к документу.

### Задание 6

#### Вариант №1 – Expand Template – 100 баллов <a name="expand-template"></a>

Разработайте приложение expand_template.exe, выполняющее замену шаблонных параметров в тексте
на соответствующие значения согласно предоставленным правилам подстановки.

Базовая функциональность должна быть реализована в виде функции:

```c++
std::string ExpandTemplate(std::string const& tpl, std::map<std::string, std::string> const& params)
```

где:

- `tpl` — строка-шаблон, в которой необходимо произвести замены
- `params` — словарь (map) пар ключ-значение, где:
  - ключ — это строка-параметр для замены
  - значение — строка, на которую нужно заменить параметр

Программа должна быть способна работать в трёх режимах:

- При запуске без параметров командной строки программа считывает шаблон и параметры из stdin и выводит результат в stdout.
- При запуске из командной строки с параметрами программа считывает шаблон из указанного входного файла,
  использует пары ключ-значение из аргументов командной строки и записывает результат в выходной файл.
- Вывод справки при указании параметра `-h`.

##### Правила подстановки

1. Пустые строки, выступающие в роли ключа в params, должны игнорироваться
2. Любой шаблонный параметр может встречаться в строке tpl произвольное количество раз
3. При наличии нескольких возможных вариантов подстановки должен выбираться параметр, имеющий наибольшую длину
4. Та часть строки tpl, в которую уже была выполнена подстановка, не должна повторно модифицироваться
5. Если в шаблоне нет параметров для замены, текст остаётся без изменений
6. Ключи шаблонных параметров должны быть уникальными
7. Текст с шаблоном может быть пустым — в таком случае он остается без изменений

##### Формат входных данных

При работе через командную строку:

```sh
expand_template.exe <input-file> <output-file> [<param> <value> [<param> <value> ...]]
```

где:

- `<input-file>` — путь к файлу, содержащему текст-шаблон
- `<output-file>` — путь к файлу для записи результата
- `<param>` — строка-параметр (может содержать пробелы и спецсимволы)
- `<value>` — соответствующее значение для подстановки
- `[<param> <value> ...]` — произвольное количество дополнительных пар параметр-значение

При работе через `stdin`:

1. До первой пустой строки каждая строка `stdin` содержит пару параметр-значение в формате:

    ```txt
    <key> := <value>
    ```

    где:

    - `<key>` - строка-параметр (может содержать пробелы и спецсимволы)
    - `<value>` - значение для подстановки

2. После пустой строки и до конца файла идут строки текста-шаблона

Примечания:

- Если **до** разделителя `:=` нет ни одного символа - ключ считается пустым и должен игнорироваться
- Если **после** разделителя `:=` нет ни одного символа - значением для подстановки будет пустая строка
- Программа должна поддерживать оба формата задания шаблонных параметров:

  - Слитное написание с разделителем `:=`:
  
    ```txt
    ключ:=значение
    ```

  - Написание с пробелами вокруг разделителя `:=`:
  
    ```txt
    ключ := значение
    ```

##### Формат выходных данных

Программа должна записать в стандартный поток или файл результат замены всех шаблонных параметров
на соответствующие значения согласно правилам подстановки.

##### Сообщения об ошибках

В зависимости от ошибки в стандартный поток выводятся следующие сообщения:

- Если после пустой строки отсутствуют строки с текстом шаблоном: "No template specified"
- Если шаблонный параметр объявлен неверно (например, не указан разделитель `:=`): "Invalid input"
- Если ключ шаблонного параметра не является уникальным: "Non-unique key"

##### Примеры использования программы

Работа через командную строку:

```sh
expand_template.exe input.txt output.txt "тепло" "холодно" "соленый" "сладкий"
```

Работа через stdin:

```txt
тепло := холодно
соленый := сладкий
день := ночь

Сегодня на улице тепло, но иногда бывает и соленый ветер.
Чудо день!
```

Результат:

```txt
Сегодня на улице холодно, но иногда бывает и сладкий ветер.
Чудо ночь!
```

Вывод краткой справки об использовании программы:

```sh
expand_template.exe -h
```

##### Требования к тестированию

Для тестирования функционала необходимо разработать набор тестов с использованием одного из популярных
C++ фреймворков для тестирования.
Тесты должны проверять корректность работы программы на разумном наборе входных параметров.

##### Примеры входных и выходных данных

###### Пример 1: Базовая подстановка параметров

Ввод:

```txt
%USER_NAME% := Ivan Petrov
{WEEK_DAY} := Friday

Hello, %USER_NAME%.  
Today is {WEEK_DAY}.
```

Вывод:

```txt
Hello, Ivan Petrov.  
Today is Friday.
```

Объяснение: Каждый параметр в шаблоне (%USER_NAME% и {WEEK_DAY}) заменяется на соответствующее значение.
Остальной текст остаётся без изменений.

###### Пример 2: Шаблонный параметр с пустым значением

Ввод:

```txt
%USER_NAME% :=
{WEEK_DAY} := 

Hello, %USER_NAME%.  
Today is {WEEK_DAY}.
```

Вывод:

```txt
Hello, .  
Today is .
```

Объяснение: в указанных шаблонных параметрах за разделителем `:=` ничего не следует,
что соответствует замене на пустую строку.

###### Пример 3: Подстановка с вложенными параметрами

Ввод:

```txt
%USER_NAME% := Super %USER_NAME% {WEEK_DAY}
{WEEK_DAY} := Friday. {WEEK_DAY}

Hello, %USER_NAME%.  
Today is {WEEK_DAY}.
```

Вывод:

```txt
Hello, Super %USER_NAME% {WEEK_DAY}.  
Today is Friday. {WEEK_DAY}.
```

Объяснение: Параметры в значениях подстановки не обрабатываются повторно,
поэтому %USER_NAME% и {WEEK_DAY} внутри значений остаются без изменений.

###### Пример 4: Выбор наиболее длинного совпадения

Ввод:

```txt
A := [a]
AA := [aa]
B := [b]
BB := [bb]
C := [c]
CC := [cc]

-AABBCCCCCABC+
```

Вывод:

```txt
-[aa][bb][cc][cc][c][a][b][c]+
```

Объяснение: При наличии нескольких возможных вариантов подстановки (например, "A" или "AA") выбирается самый длинный вариант.

###### Пример 5: Неуникальный ключ

Ввод:

```txt
%USER_NAME% := Ivan Petrov
%USER_NAME% := John Doe

Hello, %USER_NAME%.
```

Вывод:

```txt
Non-unique key
```

Объяснение: Ключ `%USER_NAME%` определён дважды, что является ошибкой,
поскольку каждый ключ должен быть уникальным.

###### Пример 6: Отсутствует текст-шаблон

Ввод:

```txt
%USER_NAME% := Ivan Petrov
{WEEK_DAY} := Friday

```

Вывод:

```txt
No template specified
```

Объяснение: после пустой строки отсутствуют какие-либо строки с текстом-шаблоном (**даже пустые**), что является ошибкой.

##### Бонус в 150 баллов за эффективное решение данной задачи с использованием алгоритма Ахо-Корасик

Рекомендации по выполнению: для эффективной реализации данного задачи ознакомьтесь с алгоритмом «Ахо-Корасик» ([Википедия](https://ru.wikipedia.org/wiki/Алгоритм_Ахо_—_Корасик), [Хабрахабр](https://habr.com/ru/articles/198682/))

### Задание 7

#### Вариант 1 — разбор выражения — 100 баллов

Программе в каждой строке стандартного ввода поступает арифметическое выражение в небинарной скобочной [польской нотации](https://ru.wikipedia.org/wiki/Польская_запись).

Программа должна вывести результат каждого из этих выражений выражения в виде числа.

Выражение в небинарной скобочной польской нотации имеет вид:

- (операция аргумент1 … аргументN)
- Операция имеет не менее одного аргумента
- Операция: либо сложение (символ +), либо умножение (символ *).
- Каждый аргумент – либо целое (положительное либо отрицательное) число, либо выражение в скобочной польской нотации.

Результат выражения – операция, применяемая ко всем аргументам.

Примеры ввода-вывода:

<table>
    <thead>
        <tr>
            <th>Ввод</th>
            <th>Вывод</th>
            <th>Примечание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>(+ 7)</th>
            <th>7</th>
            <th>Если всего один аргумент, то результат выражения – этот самый аргумент</th>
        </tr>
        <tr>
            <th>(* 8)</th>
            <th>8</th>
            <th>Аналогично и тут</th>
        </tr>
        <tr>
            <th>(+ 2 3)</th>
            <th>5</th>
            <th>2 + 3 = 5</th>
        </tr>
        <tr>
            <th>(+ 2 3 4)</th>
            <th>9</th>
            <th>2 + 3 + 4 = 9</th>
        </tr>
        <tr>
            <th>(* 2 4)</th>
            <th>8</th>
            <th>2 * 4 = 8</th>
        </tr>
        <tr>
            <th>(* 2 3 4)</th>
            <th>24</th>
            <th>2 * 3 * 4 = 24</th>
        </tr>
        <tr>
            <th>(+ (* 2 3) (* 3 4))</th>
            <th>18</th>
            <th>(2 * 3) + (3 * 4) = 18</th>
        </tr>
        <tr>
            <th>(* (+ 1 2) (+ 3 1))</th>
            <th>12</th>
            <th>(1 + 2) * (3 + 1) = 12</th>
        </tr>
        <tr>
            <th>(+ 5 (* 2 3 2) (+ 5 (+ 2 5) (* 2 2) ))</th>
            <th>33</th>
            <th>5 + (2 * 3 * 2) + (5 + (2 + 5) + (2 * 2)) = 5 + 12 + 16 = 33</th>
        </tr>
        <tr>
            <th>(+ -2 3)</th>
            <th>1</th>
            <th>-2 + 3 = 1</th>
        </tr>
    </tbody>
</table>

Гарантируется, что программе поступают на вход синтаксически верные выражения.

Для работы над ней вам может понадобиться:

1) Уметь считывать символы из стандартного ввода:

   ```c++
   char ch;
   std::cin >> ch;
    ```

   Прочитает в переменную из cin первый непробельный символ.

2) Возвращать последний считанный символ обратно в поток `cin`:

   ```c++
   std::cin.unget();
   ```

Если после чтения символа вы решили вернуть его обратно в поток `cin`, то вызовите у потока метод `unget`.

Например

```c++
char ch1, ch2;
std::cin >> ch1;
std::cin.unget(); // вернули считанный символ в поток cin
std::cin >> ch2;
// В ch2 будет лежать тот же символ, что и в ch
```

Справочная информация

Нотация называется **скобочной**, так как выражение обязательно заключено в круглые скобки.

Нотация называется **небинарной**, так как количество аргументов может быть отлично от двух.

Нотация называется **польской**, так как её изобрёл польский математик Ян Лукасевич.

<span style="color:red">В программе должна быть выделена функция, вычисляющая значение выражения,
записанного в обратной скобочной нотации. Для этой функции должны быть разработаны модульные тесты.</span>

##### Бонус в 50 баллов за обработку ошибок

Если в строке содержится невалидное выражение, программа должна вывести строку **`ERROR`** вместо результата вычисления выражения.
Вы можете использовать для обработки ошибок коды возврата из функции, либо механизм исключений.

Из-за особенностей платформы Яндекс.Contest программа
в случае ошибки должна завершать работу с нулевым кодом возврата.

##### Бонус в 80 баллов за нерекурсивное решение задачи

Бонус начисляется, если для разбора выражения не используется рекурсия.
